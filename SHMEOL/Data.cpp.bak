#include "stdafx.h"
#include "Data.h"


CSystemData::CSystemData()
{
	int i, j;
	m_nSysNo = 0;
	m_nUnitNo = 0;

	_tcscpy_s(m_szModelName, SIZE_OF_100BYTE, _T("TESLA"));
	_tcscpy_s(m_szPassword, SIZE_OF_100BYTE, _T("1111"));

	for (i = 0; i < MAX_UNIT_COUNT; i++)
	{
		for (j = 0; j < MAX_MOTOR_COUNT; j++)
		{
			m_dMotorSpeed[i][j] = 0.0;
			m_dMotorAccTime[i][j] = 0.0;
			m_dMotorDecTime[i][j] = 0.0;
			m_dMotorResol[i][j] = 0.0;
			m_dOrgDataset[i][j] = 0.0;
		}
	} 

	for (i = 0; i < MAX_UNIT_COUNT; i++)
	{
		m_dLimitSFRBalance[i] = 0.01;
		m_clOCSpec[i].x = m_clOCSpec[i].y = 0.02;
		m_dOCSpecTh[i] = 0.02;

		m_nTopLightPort[i] = 0;
	}

	m_nLightPort = 0;

	memset(m_szMesPath, 0x00, sizeof(m_szMesPath));
}


CSystemData::~CSystemData()
{
}

//-----------------------------------------------------------------------------
//
//	시스템 데이터 로드
//
//-----------------------------------------------------------------------------
void CSystemData::Load()
{
	TCHAR szPath[SIZE_OF_1K];
	//TCHAR szIniIndex[SIZE_OF_100BYTE];
	TCHAR szIniBuff[SIZE_OF_1K];
	CString sToken = _T("");
	int i, j, k;
	
	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\SystemData.ini"), BASE_DATA_PATH);

	// SYSTEM NO
	m_nSysNo = GetPrivateProfileInt(_T("System"), _T("No"), 0, szPath);
	// Unit No
	m_nUnitNo = GetPrivateProfileInt(_T("System"), _T("Unit"), 0, szPath);

	// Motor
	for(i = 0; i < MAX_UNIT_COUNT; i++)
	{
		for (j = 0; j < MAX_MOTOR_COUNT; j++)
		{
			if(i == 0)		GetPrivateProfileString(_T("MotorPara1"), MOTOR_NAME[j], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
			else			GetPrivateProfileString(_T("MotorPara2"), MOTOR_NAME[j], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
			
			for (k = 0; k < 5; k++)
			{
				AfxExtractSubString(sToken, szIniBuff, k, _T('/'));

				switch (k)
				{
				case 0:		m_dMotorSpeed[i][j] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 1:		m_dMotorAccTime[i][j] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 2:		m_dMotorDecTime[i][j] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 3:		m_dMotorResol[i][j] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 4:		m_dOrgDataset[i][j] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				}
			}
		}
	}

	for (i = 0; i < MAX_UNIT_COUNT; i++)
	{
		if (i == 0)
		{
			// 코너 SFR 편차 LIMIT
			GetPrivateProfileString(_T("SFR_LIMIT1"), _T("CornerDeviation"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
			m_dLimitSFRBalance[i] = _ttof(szIniBuff);

			// OC SPEC X,Y,T
			GetPrivateProfileString(_T("OC_SPEC1"), _T("XYT"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
			for (j = 0; j < 3; j++)
			{
				AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
				switch (j)
				{
				case 0:		m_clOCSpec[i].x = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 1:		m_clOCSpec[i].y = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 2:		m_dOCSpecTh[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				}
			}
		}
		else
		{
			// 코너 SFR 편차 LIMIT
			GetPrivateProfileString(_T("SFR_LIMIT2"), _T("CornerDeviation"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
			m_dLimitSFRBalance[i] = _ttof(szIniBuff);

			// OC SPEC X,Y,T
			GetPrivateProfileString(_T("OC_SPEC2"), _T("XYT"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
			for (j = 0; j < 3; j++)
			{
				AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
				switch (j)
				{
				case 0:		m_clOCSpec[i].x = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 1:		m_clOCSpec[i].y = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				case 2:		m_dOCSpecTh[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
				}
			}
		}
	}

	// MES IP
	GetPrivateProfileString(_T("MES"), _T("Ip"), _T(""), m_szMesIp, sizeof(m_szMesIp), szPath);
	// MES Port
	m_nMesPort = GetPrivateProfileInt(_T("MES"), _T("Port"), 0, szPath);
	// MES FATORY CD
	GetPrivateProfileString(_T("MES"), _T("FactoryCd"), _T(""), m_szFactoryCd, sizeof(m_szFactoryCd), szPath);
	// MES LOG DATA 저장 경로
	GetPrivateProfileString(_T("MES"), _T("Path"), _T(""), m_szMesPath, sizeof(m_szMesPath), szPath);

	// Serial Port
	GetPrivateProfileString(_T("SERIAL"), _T("PortNum"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for (j = 0; j < 5; j++)
	{
		AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
		switch (j)
		{
		case 0:		m_nLightPort = _ttof((TCHAR*)(LPCTSTR)sToken);			break;		
		case 1:		m_nTopLightPort[0] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 2:		m_nTopLightPort[1] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 3:		m_nDomeLightPort[0] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 4:		m_nDomeLightPort[1] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		}
	}

	// MAIN PC IP
	GetPrivateProfileString(_T("MAIN_COMM"), _T("Ip"), _T(""), m_szAAIp, sizeof(m_szAAIp), szPath);
	// MAIN PC Port
	m_nAAPort = GetPrivateProfileInt(_T("MAIN_COMM"), _T("Port"), 0, szPath);

	// 화상검사기 PC IP
	GetPrivateProfileString(_T("INSP_COMM"), _T("Ip"), _T(""), m_szInspIp, sizeof(m_szInspIp), szPath);
	// 화상검사기 PC Port
	m_nInspPort = GetPrivateProfileInt(_T("INSP_COMM"), _T("Port"), 0, szPath);

	// 비밀번호
	GetPrivateProfileString(_T("PASSWORD"), _T("Passwd"), _T(""), m_szPassword, sizeof(m_szPassword), szPath);
}

//-----------------------------------------------------------------------------
//
//	시스템 데이터 저장
//
//-----------------------------------------------------------------------------
void CSystemData::Save()
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szData[SIZE_OF_1K];
	CString sToken = _T("");
	int i, j;
	CFileFind clFinder;
	if (clFinder.FindFile(BASE_DATA_PATH) == FALSE)
	{
		CreateDirectory(BASE_DATA_PATH, NULL);
	}

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\SystemData.ini"), BASE_DATA_PATH);

	// Motor
	for( i = 0; i < MAX_UNIT_COUNT; i++)
	{
		for (j = 0; j < MAX_MOTOR_COUNT; j++)
		{
			_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf / %.03lf / %.03lf"), m_dMotorSpeed[i][j], m_dMotorAccTime[i][j], m_dMotorDecTime[i][j], m_dMotorResol[i][j], m_dOrgDataset[i][j]);
			
			if( i == 0 )	WritePrivateProfileString(_T("MotorPara1"), MOTOR_NAME[j], szData, szPath);
			else			WritePrivateProfileString(_T("MotorPara2"), MOTOR_NAME[j], szData, szPath);
		}
	}

	for (i = 0; i < MAX_UNIT_COUNT; i++)
	{
		if (i == 0)
		{
			// 코너 SFR 편차 LIMIT
			_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dLimitSFRBalance[i]);
			WritePrivateProfileString(_T("SFR_LIMIT1"), _T("CornerDeviation"), szData, szPath);
			// OC SPEC X,Y,T
			_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf"), m_clOCSpec[i].x, m_clOCSpec[i].y, m_dOCSpecTh[i]);
			WritePrivateProfileString(_T("OC_SPEC1"), _T("XYT"), szData, szPath);
		}
		else
		{
			// 코너 SFR 편차 LIMIT
			_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dLimitSFRBalance[i]);
			WritePrivateProfileString(_T("SFR_LIMIT2"), _T("CornerDeviation"), szData, szPath);
			// OC SPEC X,Y,T
			_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf"), m_clOCSpec[i].x, m_clOCSpec[i].y, m_dOCSpecTh[i]);
			WritePrivateProfileString(_T("OC_SPEC2"), _T("XYT"), szData, szPath);
		}
	}

	// MES IP
	WritePrivateProfileString(_T("MES"), _T("Ip"), m_szMesIp, szPath);
	// MES Port
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nMesPort);
	WritePrivateProfileString(_T("MES"), _T("Port"), szData, szPath);
	// MES FATORY CD
	WritePrivateProfileString(_T("MES"), _T("FactoryCd"), m_szFactoryCd, szPath);
	// MES LOG DATA 저장 경로
	WritePrivateProfileString(_T("MES"), _T("Path"), m_szMesPath, szPath);
	// Serial Port
	_stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d"), m_nLightPort, m_nTopLightPort[0], m_nTopLightPort[1], m_nDomeLightPort[0], m_nDomeLightPort[1]);
	WritePrivateProfileString(_T("SERIAL"), _T("PortNum"), szData, szPath);

	// MAIN IP
	WritePrivateProfileString(_T("MAIN_COMM"), _T("Ip"), m_szAAIp, szPath);
	// AA Port
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nAAPort);
	WritePrivateProfileString(_T("MAIN_COMM"), _T("Port"), szData, szPath);

	// MAIN IP
	WritePrivateProfileString(_T("INSP_COMM"), _T("Ip"), m_szInspIp, szPath);
	// AA Port
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nInspPort);
	WritePrivateProfileString(_T("INSP_COMM"), _T("Port"), szData, szPath);

	// 비밀번호
	WritePrivateProfileString(_T("PASSWORD"), _T("Passwd"), m_szPassword, szPath);

	this->CopyBackup();
}

//-----------------------------------------------------------------------------
//
//	시스템 설정 파일 백업
//
//-----------------------------------------------------------------------------
void CSystemData::CopyBackup()
{
	TCHAR szBackupPath[SIZE_OF_1K];
	TCHAR szPath[SIZE_OF_1K];	
	SYSTEMTIME stSysTime;
	CFileFind clFinder;
		
	GetLocalTime(&stSysTime);
	
	if (clFinder.FindFile(BASE_DATA_PATH) == FALSE)
	CreateDirectory(BASE_DATA_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup"), BASE_DATA_PATH);
	if (clFinder.FindFile(szPath) == FALSE)
	CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%04d%02d"), BASE_DATA_PATH, stSysTime.wYear, stSysTime.wMonth);
	if (clFinder.FindFile(szPath) == FALSE)
	CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%04d%02d\\%02d"), BASE_DATA_PATH, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
	CreateDirectory(szPath, NULL);

	_stprintf_s(szBackupPath, SIZE_OF_1K, _T("%s\\Backup\\%04d%02d\\%02d\\SystemData_%02d_%02d_%02d_%03d.ini"),
	BASE_DATA_PATH, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond, stSysTime.wMilliseconds);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\SystemData.ini"), BASE_DATA_PATH);

	CopyFile(szPath, szBackupPath, TRUE);
}

//-----------------------------------------------------------------------------
//
//	모델 데이터 생성자
//
//-----------------------------------------------------------------------------
CModelData::CModelData()
{
	int i;

	m_nUnit = 0;

	memset(m_szIniPath, 0x00, sizeof(m_szIniPath));
	m_nWidth = 0;
	m_nHeight = 0;
	

	for (i = 0; i < 9; i++)
	{
        m_FovSpec[i] = 0.0;
	}
    m_OcSpec[0] = 0.0;
    m_OcSpec[1] = 0.0;

	m_ColorSensitivitySpec[0] = 0.0;
	for (i = 0; i < 7; i++)
	{
		m_UniformSpec[i] = 0.0;
	}

	
	n_DefectCountLimit = 0;
	n_ClusterCountLimit = 0;

	for (i = 0; i < MAX_POS_COUNT; i++)
	{
		memset(&m_stTeachData[i], 0x00, sizeof(m_stTeachData[i]));
	}

	m_nRoiSizeX = 50;
	m_nRoiSizeY = 70;
	m_dCcdCellSize = 1.12;

	m_nMTF_FinalMode = 0;
	m_nCcdFlipUse = 0;
	m_nOldChartMTF = 0;

	m_dMTFOffset = 0.0;

	m_dLimitSFRCent = 0.6;
	m_d2ndAAMoveDistance = 0.0;
	m_dLimitSFRSide = 0.4;

	m_nCountOfCheckSFR = 0;
	m_dSfrMoveDistance = 0.0;

	m_nSfrMode = 1;

	m_nSFR_N_POS = 0;

	for (i = 0; i < 2; i++)
	{
		m_dLaserMoveX[i] = 0.0;
		m_dLaserMoveY[i] = 0.0;
	}

	for (i = 0; i < 2; i++)
	{
		m_nStainCount[i] = 0;
	}

	m_dwUvTime = 50;

	m_dEscapePosPcbZ = 0.0;

	m_nSensorAlignRetryCount = 0;
	m_dSensorAlignDelay = 0.0;
	m_nLaserRetryCount = 0;
	m_dLaserDelay = 0.0;

	m_nDryRunMode = 0;
	m_nComplMode = 0;
	m_nUvUse = 0;
	m_nLaserInUse = 0;
	m_nLaserOutUse = 0;
	m_nUnloadAfter1stAAUse = 0;
	m_nStainInspUse = 0;
	m_nDarkInspUse = 0;
	m_nCcdDefectInfpUse = 0;
	m_nFpsStopUse = 0;
	m_nPinStopUse = 0;
	m_fFpsStopVal = 5.0;
	m_nLaserControlLock = 0;
	m_nDomeChartUse = 0;
	m_nUVLampAlarmUse = 0;
	m_nAAPass = 0;
	m_nInspectionPass = 0;
	
	
	m_dOffsetPrevUV_X = 0.0;
	m_dOffsetPrevUV_Y = 0.0;
	m_dOffsetPrevUV_Z = 0.0;
	m_dOffsetPrevUV_Tx = 0.0;
	m_dOffsetPrevUV_Ty = 0.0;
	m_dOffsetPrevUV_Th = 0.0;

	m_dPCBVacuumDelay = 0.0;
	m_dPCBGripDelay = 0.0;
	m_dPCBGripUpDelay = 0.0;
	m_dLaserTimeOut = 0.0;
	m_dFinalDelay = 0.0;
	m_dBondingDelay = 0.0;

	m_nSensorCnt = 1;

	for (i = 0; i < MAX_LIGHT_COUNT; i++)
	{
		m_nLight[i] = 0;
	}

	for (i = 0; i < 14; i++)
	{
		m_nDomeLightVal[i] = 0;
	}

	for (i = 0; i < MAX_MOTOR_COUNT; i++)
	{
		m_dOkLimit[i] = 0.0;
		m_dErrLimit[i] = 0.0;
	}

	m_dStainLsbCenter = 0.0;
	m_dStainLsbCorner = 0.0;
	m_dStainLsbEdge = 0.0;

	m_dStainYMeanCenter = 0.0;
	m_dStainYMeanCorner = 0.0;
	m_dStainYMeanEdge = 0.0;

	m_nMarkNo = 0;
	m_nMinMatching = 80;

    for (i = 0; i < MAX_SFR_INSP_CNT; i++)
    {
        m_nDirection[i] = 0;
        m_MTF_ROI_Pos[i] = 0;
    }
    m_dLinePulse = 0.0;
    for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
    {
        m_nPatternPos[i].x = 0;
        m_nPatternPos[i].y = 0;
        m_nPatternSize[i].x = 0;
        m_nPatternSize[i].y = 0;
    }

    m_dChartHfovMin = 0.0;
    m_dChartHfovMax = 0.0;

    m_dChartVfovMin = 0.0;
    m_dChartVfovMax = 0.0;

    m_dChartDistortionMin = 0.0;
    m_dChartDistortionMax = 0.0;

	m_BlemishSpec = new double[sizeof(STAIN_BLEMISH_SPEC_NAME) / sizeof(STAIN_BLEMISH_SPEC_NAME[0])];
	m_LcbSpec = new double[sizeof(STAIN_LCB_SPEC_NAME) / sizeof(STAIN_LCB_SPEC_NAME[0])];
	m_YmeanSpec = new double[sizeof(STAIN_YMEAN_SPEC_NAME) / sizeof(STAIN_YMEAN_SPEC_NAME[0])];
	m_DefectSpec = new double[sizeof(DEFECT_SPEC_NAME) / sizeof(DEFECT_SPEC_NAME[0])];
	m_ICSpec = new double[sizeof(IC_SPEC_NAME) / sizeof(IC_SPEC_NAME[0])];
	m_RISpec = new double[sizeof(RI_SPEC_NAME) / sizeof(RI_SPEC_NAME[0])];


	for (i = 0; i < sizeof(DEFECT_SPEC_NAME) / sizeof(DEFECT_SPEC_NAME[0]); i++)
	{
		m_DefectSpec[i] = 0.0;
	}
	for (i = 0; i < sizeof(RI_SPEC_NAME) / sizeof(RI_SPEC_NAME[0]); i++)
	{
		m_RISpec[i] = 0.0;
	}
}

//-----------------------------------------------------------------------------
//
//	모델 데이터 소멸자
//
//-----------------------------------------------------------------------------
CModelData::~CModelData()
{

}

//-----------------------------------------------------------------------------
//
//	모델 데이터 유닛번호 설정
//
//-----------------------------------------------------------------------------
void CModelData::SetUnit(int nUnit)
{
	m_nUnit = nUnit;
}

//-----------------------------------------------------------------------------
//
//	모델 데이터 로드
//
//-----------------------------------------------------------------------------
void CModelData::Load(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szIniIndex[SIZE_OF_100BYTE];
	TCHAR szIniBuff[SIZE_OF_1K];
	CString sToken = _T("");
	int i, j;

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\%s_AA%d.ini"), BASE_MODEL_PATH, szModelName, szModelName, m_nUnit + 1);
	
	// 센서 구동 파일
	GetPrivateProfileString(_T("SensorInit"), _T("Path"), _T(""), m_szIniPath, sizeof(m_szIniPath), szPath);
	
	// TEACH DATA
	for (i = 0; i < MAX_POS_COUNT; i++)
	{
		GetPrivateProfileString(_T("TEACH"), POS_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		for (j = 0; j < MAX_MOTOR_COUNT; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
			m_stTeachData[i].dPos[j] = _ttof((TCHAR*)(LPCTSTR)sToken);
		}
	}

	GetPrivateProfileString(_T("CCD_SIZE"), _T("CellSize"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	m_dCcdCellSize = _ttof(szIniBuff);

	// MTF 측정 모드
	m_nMTF_FinalMode = GetPrivateProfileInt(_T("MTF_INSP"), _T("FinalMode"), 0, szPath);
	// CCD 반전
	m_nCcdFlipUse = GetPrivateProfileInt(_T("CCD_FLIP"), _T("Use"), 0, szPath);
	// 구형 차트 사용
	m_nOldChartMTF = GetPrivateProfileInt(_T("MTF_INSP"), _T("OldMTFUse"), 0, szPath);
	// MTF Offset 가중치
	GetPrivateProfileString(_T("MTF_INSP"), _T("Offset"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	m_dMTFOffset = _ttof((szIniBuff));

	for (i = 0; i < 2; i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("AF%d"), i + 1);
		GetPrivateProfileString(_T("ACTIVE_ALIGN"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		for (j = 0; j < 7; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));

			switch (j)
			{
				// 이동 속도
			case 0:		m_stAFInfo[i].dMoveVel = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				// 가감속
			case 1:		m_stAFInfo[i].dMoveAcc = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				// Delay
			case 2:		m_stAFInfo[i].nDelayTime = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
				// 이동거리
			case 3:		m_stAFInfo[i].dMoveDistance = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				// STEP 수
			case 4:
				m_stAFInfo[i].nMaxStepCount = _ttoi((TCHAR*)(LPCTSTR)sToken);
				if (m_stAFInfo[i].nMaxStepCount == 0)
					m_stAFInfo[i].nMaxStepCount = 60;
				break;
				// Limit MTF
			case 5:		m_stAFInfo[i].fLimitMTF = (float)_ttof((TCHAR*)(LPCTSTR)sToken);	break;
				// SFR 평균 카운트
			case 6:		m_stAFInfo[i].nAvgSfrCount = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
			}
		}		
	}

	// CENTER SFR LIMIT
	GetPrivateProfileString(_T("SFR_LIMIT"), _T("Center"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	m_dLimitSFRCent = _ttof(szIniBuff);
	// 2차 AA 시작시 이동
	GetPrivateProfileString(_T("2ND_AA_MOVE"), _T("Distance"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	m_d2ndAAMoveDistance = _ttof(szIniBuff);
	// CORNER SFR LIMIT
	GetPrivateProfileString(_T("SFR_LIMIT"), _T("Corner"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	m_dLimitSFRSide = _ttof(szIniBuff);

    //
    //
    //fov , distortion 제한 spec
    GetPrivateProfileString(_T("CHART_LIMIT"), _T("HfovMin"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dChartHfovMin = _ttof(szIniBuff);
    GetPrivateProfileString(_T("CHART_LIMIT"), _T("HfovMax"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dChartHfovMax = _ttof(szIniBuff);
    GetPrivateProfileString(_T("CHART_LIMIT"), _T("VfovMin"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dChartVfovMin = _ttof(szIniBuff);
    GetPrivateProfileString(_T("CHART_LIMIT"), _T("VfovMax"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dChartVfovMax = _ttof(szIniBuff);
    GetPrivateProfileString(_T("CHART_LIMIT"), _T("DistortionMin"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dChartDistortionMin = _ttof(szIniBuff);
    GetPrivateProfileString(_T("CHART_LIMIT"), _T("DistortionMax"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dChartDistortionMax = _ttof(szIniBuff);

    //
    //
	GetPrivateProfileString(_T("SFR_DECREASE"), _T("Decrease"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for (j = 0; j < 2; j++)
	{
		AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
		switch (j)
		{
			// 체크 데이터 수
		case 0:		m_nCountOfCheckSFR = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
			// 이동거리
		case 1:		m_dSfrMoveDistance = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		}
	}

	m_nSfrMode = GetPrivateProfileInt(_T("SFR_MODE"), _T("Mode"), 1, szPath);
	// SFR POSITION
	m_nSFR_N_POS = GetPrivateProfileInt(_T("SFR_POS"), _T("Type"), 1, szPath);

	// Laser In
	GetPrivateProfileString(_T("LASER"), _T("InPos"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	{
		for (j = 0; j < 2; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
			switch (j)
			{
			case 0:		m_dLaserMoveX[0] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
			case 1:		m_dLaserMoveY[0] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
			}
		}
	}

	// Laser Out
	GetPrivateProfileString(_T("LASER"), _T("OutPos"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for (j = 0; j < 2; j++)
	{
		AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
		switch (j)
		{
		case 0:		m_dLaserMoveX[1] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 1:		m_dLaserMoveY[1] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		}
	}

	// Stain 불량 카운트
	m_nStainCount[0] = GetPrivateProfileInt(_T("STAIN"), _T("White"), 0, szPath);
	m_nStainCount[1] = GetPrivateProfileInt(_T("STAIN"), _T("Black"), 0, szPath);

	// UV
	m_dwUvTime = GetPrivateProfileInt(_T("UV"), _T("Time"), 50, szPath);

	// PCB Z축 회피 위치
	GetPrivateProfileString(_T("ESCAPE_POS"), _T("PcbZ"), _T("0.0"), szIniBuff, sizeof(szIniBuff), szPath);
	m_dEscapePosPcbZ = _ttof(szIniBuff);

	m_nSensorAlignRetryCount = GetPrivateProfileInt(_T("ALIGN_RETRY"), _T("Retry_Count"), 0, szPath);
	m_nLaserRetryCount = GetPrivateProfileInt(_T("LASER_CONTROL"), _T("Retry_Count"), 0, szPath);

	// Delay Time 관련
	GetPrivateProfileString(_T("DelayTime"), _T("Time"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for (j = 0; j < 8; j++)
	{
		AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
		switch (j)
		{
		case 0:		m_dPCBVacuumDelay = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 1:		m_dPCBGripDelay = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 2:		m_dPCBGripUpDelay = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 3:		m_dLaserDelay = _ttof((TCHAR*)(LPCTSTR)sToken);			break;
		case 4:		m_dSensorAlignDelay = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
		case 5:		m_dLaserTimeOut = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 6:		m_dFinalDelay = _ttof((TCHAR*)(LPCTSTR)sToken);			break;
		case 7:		m_dBondingDelay = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		}
	}

	m_nDryRunMode = GetPrivateProfileInt(_T("RUN_MODE"), _T("Mode"), 0, szPath);
	m_nComplMode = GetPrivateProfileInt(_T("COMPL_MODE"), _T("Use"), 0, szPath);
	m_nUvUse = GetPrivateProfileInt(_T("UV"), _T("Use"), 1, szPath);
	m_nLaserInUse = GetPrivateProfileInt(_T("LASER_IN"), _T("Use"), 1, szPath);
	m_nLaserOutUse = GetPrivateProfileInt(_T("LASER_OUT"), _T("Use"), 1, szPath);
	m_nUnloadAfter1stAAUse = GetPrivateProfileInt(_T("UNLOAD_AFTER_1ST_AA"), _T("Use"), 0, szPath);
	m_nStainInspUse = GetPrivateProfileInt(_T("STAIN_INSP"), _T("Use"), 1, szPath);
	m_nDarkInspUse = GetPrivateProfileInt(_T("DARK_INSP"), _T("Use"), 0, szPath);
	m_nCcdDefectInfpUse = GetPrivateProfileInt(_T("CCD_DEFECT_INSP"), _T("Use"), 1, szPath);
	m_nFpsStopUse = GetPrivateProfileInt(_T("FPS_STOP"), _T("Use"), 0, szPath);
	GetPrivateProfileString(_T("FPS_STOP"), _T("Value"), _T("5.0"), szIniBuff, sizeof(szIniBuff), szPath);
	m_fFpsStopVal = (float)_ttof(szIniBuff);
	m_nLaserControlLock = GetPrivateProfileInt(_T("LASER_CONTROL"), _T("Use"), 0, szPath);
	m_nDomeChartUse = GetPrivateProfileInt(_T("DOME_CHART"), _T("Use"), 0, szPath);
	m_nUVLampAlarmUse = GetPrivateProfileInt(_T("UV_LAMP_ALARM"), _T("Use"), 0, szPath);
	m_nAAPass = GetPrivateProfileInt(_T("AA_PASS"), _T("Use"), 0, szPath);
	m_nInspectionPass = GetPrivateProfileInt(_T("INSPECTION_PASS"), _T("Use"), 0, szPath);

	if(m_nDomeChartUse == 1)
	{
		m_nWidth = GetPrivateProfileInt(_T("SENSOR"), _T("SENSOR_SIZE_X"), CCD1_CAM_SIZE_X, m_szIniPath);
		m_nHeight = GetPrivateProfileInt(_T("SENSOR"), _T("SENSOR_SIZE_Y"), CCD1_CAM_SIZE_Y, m_szIniPath);
	}
	else
	{
		m_nWidth = GetPrivateProfileInt(_T("SENSOR"), _T("SENSOR_SIZE_X"), CCD2_CAM_SIZE_X, m_szIniPath);
		m_nHeight = GetPrivateProfileInt(_T("SENSOR"), _T("SENSOR_SIZE_Y"), CCD2_CAM_SIZE_Y, m_szIniPath);
	}

	// PreUV Offset
	GetPrivateProfileString(_T("PRE_UV_OFFSET"), _T("Offset"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for (j = 0; j < 6; j++)
	{
		AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
		switch (j)
		{
		case 0:		m_dOffsetPrevUV_X = _ttof((TCHAR*)(LPCTSTR)sToken);			break;
		case 1:		m_dOffsetPrevUV_Y = _ttof((TCHAR*)(LPCTSTR)sToken);			break;
		case 2:		m_dOffsetPrevUV_Z = _ttof((TCHAR*)(LPCTSTR)sToken);			break;
		case 3:		m_dOffsetPrevUV_Tx = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 4:		m_dOffsetPrevUV_Ty = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 5:		m_dOffsetPrevUV_Th = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		}
	}

	m_nPinStopUse = GetPrivateProfileInt(_T("SENSOR_COUNT"), _T("Use"), 0, szPath);
	m_nSensorCnt = GetPrivateProfileInt(_T("SENSOR_COUNT"), _T("Count"), 0, szPath);

	// 조명 데이터
	for (i = 0; i < MAX_LIGHT_COUNT; i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("%02d"), i + 1);
		m_nLight[i] = GetPrivateProfileInt(_T("Light"), szIniIndex, 0, szPath);
	}

	// DOME 조명 DATA
	GetPrivateProfileString(_T("DOME_LIGHT"), _T("Value"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for (i = 0; i < 14; i++)
	{
		AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
		switch (i)
		{
		case 0:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 1:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 2:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 3:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 4:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 5:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 6:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 7:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 8:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 9:		m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 10:	m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 11:	m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 12:	m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		case 13:	m_nDomeLightVal[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
		}
	}

	// 보정량 LIMIT
	for (i = 0; i < MAX_MOTOR_COUNT; i++)
	{
		GetPrivateProfileString(_T("AlignLimit"), MOTOR_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		for (j = 0; j < 2; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
			switch (j)
			{
			case 0:		m_dOkLimit[i] = _ttof((TCHAR*)(LPCTSTR)sToken);		break;
			case 1:		m_dErrLimit[i] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
			}
		}
	}

	m_clSfrInfo.m_nSizeX = GetPrivateProfileInt(_T("SFR_SIZE"), _T("SIZE_X"), 50, szPath);
	m_clSfrInfo.m_nSizeY = GetPrivateProfileInt(_T("SFR_SIZE"), _T("SIZE_Y"), 57, szPath);

	m_nRoiSizeX = GetPrivateProfileInt(_T("ROI_SIZE"), _T("SIZE_X"), 50, szPath);
	m_nRoiSizeY = GetPrivateProfileInt(_T("ROI_SIZE"), _T("SIZE_Y"), 70, szPath);

	for (i = 0; i < (MAX_LAST_INSP_COUNT); i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("%02d"), i + 1);
		GetPrivateProfileString(_T("SfrOffset"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		for (j = 0; j < 2; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
			switch (j)
			{
			case 0:		m_clSfrInfo.m_clPtOffset[i].x = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
			case 1:		m_clSfrInfo.m_clPtOffset[i].y = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
			}
		}
	}
	
    for (i = 0; i < 4; i++)
    {
        // 원형마크 위치
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
        GetPrivateProfileString(_T("CircleMark"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        /*for (j = 0; j < 2; j++)
        {
            AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
            switch (j)
            {
            case 0:		m_clSfrInfo.m_clPtCircle[i].x = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
            case 1:		m_clSfrInfo.m_clPtCircle[i].y = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
            }
        }*/


        // 원형마크 영역
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
        GetPrivateProfileString(_T("CircleMark"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        for (j = 0; j < 4; j++)
        {
            AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
            switch (j)
            {
            case 0:		m_clSfrInfo.m_clRectCircle[i].left = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 1:		m_clSfrInfo.m_clRectCircle[i].top = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 2:		m_clSfrInfo.m_clRectCircle[i].right = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 3:		m_clSfrInfo.m_clRectCircle[i].bottom = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            }
        }
    }
    //------------------------------------------------------------------------------
    //fov
    //------------------------------------------------------------------------------
    for (i = 0; i < MAX_FOV_COUNT; i++)
    {
        // fov 마크 위치
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
        GetPrivateProfileString(_T("FovMark"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        for (j = 0; j < 2; j++)
        {
            AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
            switch (j)
            {
            case 0:		m_clSfrInfo.m_clPtFov[i].x = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
            case 1:		m_clSfrInfo.m_clPtFov[i].y = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
            }
        }


        // fov 마크 영역
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
        GetPrivateProfileString(_T("FovMark"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        for (j = 0; j < 4; j++)
        {
            AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
            switch (j)
            {
            case 0:		m_clSfrInfo.m_clRectFov[i].left = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 1:		m_clSfrInfo.m_clRectFov[i].top = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 2:		m_clSfrInfo.m_clRectFov[i].right = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 3:		m_clSfrInfo.m_clRectFov[i].bottom = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            }
        }
    }
    //------------------------------------------------------------------------------
    //snr Left
    //------------------------------------------------------------------------------
    for (i = 0; i < MAX_SNR_COUNT; i++)
    {
        // snr 마크 위치
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
        GetPrivateProfileString(_T("SnrMark"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        for (j = 0; j < 2; j++)
        {
            AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
            switch (j)
            {
            case 0:		m_clSfrInfo.m_clPtSnr[i].x = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
            case 1:		m_clSfrInfo.m_clPtSnr[i].y = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
            }
        }


        // snr 마크 영역
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
        GetPrivateProfileString(_T("SnrMark"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        for (j = 0; j < 4; j++)
        {
            AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
            switch (j)
            {
            case 0:		m_clSfrInfo.m_clRectSnr[i].left = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 1:		m_clSfrInfo.m_clRectSnr[i].top = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 2:		m_clSfrInfo.m_clRectSnr[i].right = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            case 3:		m_clSfrInfo.m_clRectSnr[i].bottom = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
            }
        }
    }

	//------------------------------------------------------------------------------
	//snr Right
	//------------------------------------------------------------------------------
	for (i = 0; i < MAX_SNR_COUNT; i++)
	{
		// snr 마크 위치
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
		GetPrivateProfileString(_T("SnrMark2"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		for (j = 0; j < 2; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
			switch (j)
			{
			case 0:		m_clSfrInfo.m_clPtSnr2[i].x = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
			case 1:		m_clSfrInfo.m_clPtSnr2[i].y = _ttoi((TCHAR*)(LPCTSTR)sToken);		break;
			}
		}


		// snr 마크 영역
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
		GetPrivateProfileString(_T("SnrMark2"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		for (j = 0; j < 4; j++)
		{
			AfxExtractSubString(sToken, szIniBuff, j, _T('/'));
			switch (j)
			{
			case 0:		m_clSfrInfo.m_clRectSnr2[i].left = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
			case 1:		m_clSfrInfo.m_clRectSnr2[i].top = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
			case 2:		m_clSfrInfo.m_clRectSnr2[i].right = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
			case 3:		m_clSfrInfo.m_clRectSnr2[i].bottom = _ttoi((TCHAR*)(LPCTSTR)sToken);	break;
			}
		}
	}
    //------------------------------------------------------------------------------
    //
    //------------------------------------------------------------------------------
	m_nMtfOverlayUse = GetPrivateProfileInt(_T("SfrOverlay"), _T("Use"), 0, szPath);

	GetPrivateProfileString(_T("StainLSB"), _T("Threshold"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for(i = 0; i < 3; i++)
	{
		AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
		switch(i)
		{
		case 0:	
			m_dStainLsbCenter = _ttof((TCHAR*)(LPCTSTR)sToken); 
			if(m_dStainLsbCenter == 0.0)
				m_dStainLsbCenter = 29.0;
			break;
		case 1:
			m_dStainLsbCorner = _ttof((TCHAR*)(LPCTSTR)sToken);
			if(m_dStainLsbCorner == 0.0)
				m_dStainLsbCorner = 65.0;
			break;
		case 2:
			m_dStainLsbEdge = _ttof((TCHAR*)(LPCTSTR)sToken);
			if(m_dStainLsbEdge == 0.0)
				m_dStainLsbEdge = 80.0;
			break;
		}

	}

	GetPrivateProfileString(_T("StainYMean"), _T("Threshold"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	for(i = 0; i < 3; i++)
	{
		AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
		switch(i)
		{
		case 0:
			m_dStainYMeanCenter = _ttof((TCHAR*)(LPCTSTR)sToken);
			if(m_dStainYMeanCenter == 0.0)
				m_dStainYMeanCenter = 3.0;
			break;
		case 1:
			m_dStainYMeanCorner = _ttof((TCHAR*)(LPCTSTR)sToken);
			if(m_dStainYMeanCorner == 0.0)
				m_dStainYMeanCorner = 6.0;
			break;
		case 2:
			m_dStainYMeanEdge = _ttof((TCHAR*)(LPCTSTR)sToken);
			if(m_dStainYMeanEdge == 0.0)
				m_dStainYMeanEdge = 6.0;
			break;
		}
	}

	m_nMarkNo = GetPrivateProfileInt(_T("Vision"), _T("MarkNo"), 0, szPath);
	m_nMinMatching = GetPrivateProfileInt(_T("Vision"), _T("Mathcing"), 80, szPath);
    //
    GetPrivateProfileString(_T("ASMI_SFR_SPEC"), _T("Direction"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    for (i = 0; i < MAX_SFR_INSP_CNT; i++)
    {
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_nDirection[i] = _ttof((TCHAR*)(LPCTSTR)sToken);

    }
    
    //m_dLinePulse
    GetPrivateProfileString(_T("LINE_PULSE"), _T("LinePulse"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    m_dLinePulse = _ttof(szIniBuff);
    //sfr 작은 박스
    for (i = 0; i < MAX_SFR_INSP_CNT; i++)
    {
        GetPrivateProfileString(_T("SFR_ROI_OFFSET"), _T("OffsetX"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_MTF_ROI_Pos[i].x = _ttof((TCHAR*)(LPCTSTR)sToken);

        GetPrivateProfileString(_T("SFR_ROI_OFFSET"), _T("OffsetY"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_MTF_ROI_Pos[i].y = _ttof((TCHAR*)(LPCTSTR)sToken);
    }
    //
    //패턴 사이즈,위치
    for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
    {
        GetPrivateProfileString(_T("PATTERN"), _T("PatternPosX"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_nPatternPos[i].x = _ttof((TCHAR*)(LPCTSTR)sToken);
    }
    for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
    {

        GetPrivateProfileString(_T("PATTERN"), _T("PatternPosY"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_nPatternPos[i].y = _ttof((TCHAR*)(LPCTSTR)sToken);
    }
    for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
    {

        GetPrivateProfileString(_T("PATTERN"), _T("PatternSizeX"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_nPatternSize[i].x = _ttof((TCHAR*)(LPCTSTR)sToken);
    }
    for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
    {

        GetPrivateProfileString(_T("PATTERN"), _T("PatternSizeY"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_nPatternSize[i].y = _ttof((TCHAR*)(LPCTSTR)sToken);
    }
    

    

}

//-----------------------------------------------------------------------------
//
//	모델 데이터 저장
//
//-----------------------------------------------------------------------------
void CModelData::Save(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szIniIndex[SIZE_OF_100BYTE];
	TCHAR szData[SIZE_OF_1K];	
	int i;

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\%s_AA%d.ini"), BASE_MODEL_PATH, szModelName, szModelName, m_nUnit+1);
	
	// 센서 구동 파일
	WritePrivateProfileString(_T("SensorInit"), _T("Path"), m_szIniPath, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dCcdCellSize);
	WritePrivateProfileString(_T("CCD_SIZE"), _T("CellSize"), szData, szPath);

	// MTF Final 모드
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nMTF_FinalMode);
	WritePrivateProfileString(_T("MTF_INSP"), _T("FinalMode"), szData, szPath);
	// CCD 반전 사용여부
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nCcdFlipUse);
	WritePrivateProfileString(_T("CCD_FLIP"), _T("Use"), szData, szPath);
	// 구형차트 사용여부
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nOldChartMTF);
	WritePrivateProfileString(_T("MTF_INSP"), _T("OldMTFUse"), szData, szPath);
	// MTF Offset 가중치
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dMTFOffset);
	WritePrivateProfileString(_T("MTF_INSP"), _T("Offset"), szData, szPath);

	for (i = 0; i < 2; i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("AF%d"), i + 1);
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %d / %.03lf / %d / %.03lf / %d"),
			m_stAFInfo[i].dMoveVel, m_stAFInfo[i].dMoveAcc, m_stAFInfo[i].nDelayTime, m_stAFInfo[i].dMoveDistance, m_stAFInfo[i].nMaxStepCount, m_stAFInfo[i].fLimitMTF, m_stAFInfo[i].nAvgSfrCount);
		WritePrivateProfileString(_T("ACTIVE_ALIGN"), szIniIndex, szData, szPath);		
	}

	// CENTER SFR LIMIT
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dLimitSFRCent);
	WritePrivateProfileString(_T("SFR_LIMIT"), _T("Center"), szData, szPath);
	// 2차 AA 시작시 이동
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_d2ndAAMoveDistance);
	WritePrivateProfileString(_T("2ND_AA_MOVE"), _T("Distance"), szData, szPath);
	// CORNER SFR LIMIT
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dLimitSFRSide);
	WritePrivateProfileString(_T("SFR_LIMIT"), _T("Corner"), szData, szPath);
    //
    //
    //fov , distortion 제한 spec
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dChartHfovMin);
    WritePrivateProfileString(_T("CHART_LIMIT"), _T("HfovMin"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dChartHfovMax);
    WritePrivateProfileString(_T("CHART_LIMIT"), _T("HfovMax"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dChartVfovMin);
    WritePrivateProfileString(_T("CHART_LIMIT"), _T("VfovMin"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dChartVfovMax);
    WritePrivateProfileString(_T("CHART_LIMIT"), _T("VfovMax"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dChartDistortionMin);
    WritePrivateProfileString(_T("CHART_LIMIT"), _T("DistortionMin"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dChartDistortionMax);
    WritePrivateProfileString(_T("CHART_LIMIT"), _T("DistortionMax"), szData, szPath);

    //

    //
	_stprintf_s(szData, SIZE_OF_1K, _T("%d / %.03lf"), m_nCountOfCheckSFR, m_dSfrMoveDistance);
	WritePrivateProfileString(_T("SFR_DECREASE"), _T("Decrease"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d / %.03lf"), m_nCountOfCheckSFR, m_dSfrMoveDistance);
	WritePrivateProfileString(_T("SFR_DECREASE"), _T("Decrease"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nSfrMode);
	WritePrivateProfileString(_T("SFR_MODE"), _T("Mode"), szData, szPath);

	// SFR POSITION
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nSFR_N_POS);
	WritePrivateProfileString(_T("SFR_POS"), _T("Type"), szData, szPath);

	// Laser In
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf"), m_dLaserMoveX[0], m_dLaserMoveY[0]);
	WritePrivateProfileString(_T("LASER"), _T("InPos"), szData, szPath);
	// Laser Out
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf"), m_dLaserMoveX[1], m_dLaserMoveY[1]);
	WritePrivateProfileString(_T("LASER"), _T("OutPos"), szData, szPath);

	// Stain 불량 카운트
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nStainCount[0]);
	WritePrivateProfileString(_T("STAIN"), _T("White"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nStainCount[1]);
	WritePrivateProfileString(_T("STAIN"), _T("Black"), szData, szPath);

	// UV
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_dwUvTime);
	WritePrivateProfileString(_T("UV"), _T("Time"), szData, szPath);

	// PCB Z축 회피 위치
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dEscapePosPcbZ);
	WritePrivateProfileString(_T("ESCAPE_POS"), _T("PcbZ"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nSensorAlignRetryCount);
	WritePrivateProfileString(_T("ALIGN_RETRY"), _T("Retry_Count"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nLaserRetryCount);
	WritePrivateProfileString(_T("LASER_CONTROL"), _T("Retry_Count"), szData, szPath);

	// Delay Time 관련
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf / %.03lf / %.03lf / %.03lf / %.03lf / %.03lf"), m_dPCBVacuumDelay, m_dPCBGripDelay,
		m_dPCBGripUpDelay, m_dLaserDelay, m_dSensorAlignDelay, m_dLaserTimeOut, m_dFinalDelay, m_dBondingDelay);
	WritePrivateProfileString(_T("DelayTime"), _T("Time"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nDryRunMode);
	WritePrivateProfileString(_T("RUN_MODE"), _T("Mode"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nComplMode);
	WritePrivateProfileString(_T("COMPL_MODE"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nUvUse);
	WritePrivateProfileString(_T("UV"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nLaserInUse);
	WritePrivateProfileString(_T("LASER_IN"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nLaserOutUse);
	WritePrivateProfileString(_T("LASER_OUT"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nUnloadAfter1stAAUse);
	WritePrivateProfileString(_T("UNLOAD_AFTER_1ST_AA"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nStainInspUse);
	WritePrivateProfileString(_T("STAIN_INSP"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nDarkInspUse);
	WritePrivateProfileString(_T("DARK_INSP"), _T("Use"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nCcdDefectInfpUse);
	WritePrivateProfileString(_T("CCD_DEFECT_INSP"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nFpsStopUse);
	WritePrivateProfileString(_T("FPS_STOP"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%.03f"), m_fFpsStopVal);
	WritePrivateProfileString(_T("FPS_STOP"), _T("Value"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nLaserControlLock);
	WritePrivateProfileString(_T("LASER_CONTROL"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nDomeChartUse);
	WritePrivateProfileString(_T("DOME_CHART"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nUVLampAlarmUse);
	WritePrivateProfileString(_T("UV_LAMP_ALARM"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nAAPass);
	WritePrivateProfileString(_T("AA_PASS"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nInspectionPass);
	WritePrivateProfileString(_T("INSPECTION_PASS"), _T("Use"), szData, szPath);
	
	// Pre UV Offset
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %0.3lf / %.03lf / %.03lf / %.03lf"), m_dOffsetPrevUV_X, m_dOffsetPrevUV_Y, m_dOffsetPrevUV_Z,
		m_dOffsetPrevUV_Tx, m_dOffsetPrevUV_Ty, m_dOffsetPrevUV_Th);
	WritePrivateProfileString(_T("PRE_UV_OFFSET"), _T("Offset"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nPinStopUse);
	WritePrivateProfileString(_T("SENSOR_COUNT"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nSensorCnt);
	WritePrivateProfileString(_T("SENSOR_COUNT"), _T("Count"), szData, szPath);

	// 조명값
	for (i = 0; i < MAX_LIGHT_COUNT; i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("%02d"), i + 1);
		_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nLight[i]);
		WritePrivateProfileString(_T("Light"), szIniIndex, szData, szPath);
	}



	// DOME 조명값
	_stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d"), m_nDomeLightVal[0], m_nDomeLightVal[1], m_nDomeLightVal[2],
		m_nDomeLightVal[3], m_nDomeLightVal[4], m_nDomeLightVal[5], m_nDomeLightVal[6], m_nDomeLightVal[7], m_nDomeLightVal[8], m_nDomeLightVal[9], m_nDomeLightVal[10],
		m_nDomeLightVal[11], m_nDomeLightVal[12], m_nDomeLightVal[13]);
	WritePrivateProfileString(_T("DOME_LIGHT"), _T("Value"), szData, szPath);
	
	// 보정량 LIMIT
	for (i = 0; i < MAX_MOTOR_COUNT; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf"), m_dOkLimit[i], m_dErrLimit[i]);
		WritePrivateProfileString(_T("AlignLimit"), MOTOR_NAME[i], szData, szPath);
	}

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_clSfrInfo.m_nSizeX);
	WritePrivateProfileString(_T("SFR_SIZE"), _T("SIZE_X"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_clSfrInfo.m_nSizeY);
	WritePrivateProfileString(_T("SFR_SIZE"), _T("SIZE_Y"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nRoiSizeX);
	WritePrivateProfileString(_T("ROI_SIZE"), _T("SIZE_X"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nRoiSizeY);
	WritePrivateProfileString(_T("ROI_SIZE"), _T("SIZE_Y"), szData, szPath);

	// 검사영역 OFFSET
	for (i = 0; i < (MAX_LAST_INSP_COUNT); i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("%02d"), i + 1);
		_stprintf_s(szData, SIZE_OF_1K, _T("%d / %d"), m_clSfrInfo.m_clPtOffset[i].x, m_clSfrInfo.m_clPtOffset[i].y);
		WritePrivateProfileString(_T("SfrOffset"), szIniIndex, szData, szPath);
	}

    for (i = 0; i < 4; i++)
    {
        // 원형마크 위치
        //_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
        //_stprintf_s(szData, SIZE_OF_1K, _T("%d / %d"), m_clSfrInfo.m_clPtCircle[i].x, m_clSfrInfo.m_clPtCircle[i].y);
       // WritePrivateProfileString(_T("CircleMark"), szIniIndex, szData, szPath);

        // 원형마크 영역
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
        _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d"), m_clSfrInfo.m_clRectCircle[i].left,
            m_clSfrInfo.m_clRectCircle[i].top, m_clSfrInfo.m_clRectCircle[i].right, m_clSfrInfo.m_clRectCircle[i].bottom);
        WritePrivateProfileString(_T("CircleMark"), szIniIndex, szData, szPath);
    }
    //------------------------------------------------------------------------------
    //fov
    //------------------------------------------------------------------------------
    for (i = 0; i < MAX_FOV_COUNT; i++)
    {
        // FOV 마크 위치
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
        _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d"), m_clSfrInfo.m_clPtFov[i].x, m_clSfrInfo.m_clPtFov[i].y);
        WritePrivateProfileString(_T("FovMark"), szIniIndex, szData, szPath);

        // FOV 마크 영역
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
        _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d"), m_clSfrInfo.m_clRectFov[i].left,
            m_clSfrInfo.m_clRectFov[i].top, m_clSfrInfo.m_clRectFov[i].right, m_clSfrInfo.m_clRectFov[i].bottom);
        WritePrivateProfileString(_T("FovMark"), szIniIndex, szData, szPath);
    }
    //------------------------------------------------------------------------------
    //snr
    //------------------------------------------------------------------------------
    for (i = 0; i < MAX_SNR_COUNT; i++)
    {
        // SNR 마크 위치
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("POS%02d"), i + 1);
        _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d"), m_clSfrInfo.m_clPtSnr[i].x, m_clSfrInfo.m_clPtSnr[i].y);
        WritePrivateProfileString(_T("SnrMark"), szIniIndex, szData, szPath);
    }
    for (i = 0; i < 4; i++)		//LEFT
    {
        // SNR 마크 영역
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
        _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d"), m_clSfrInfo.m_clRectSnr[i].left,
            m_clSfrInfo.m_clRectSnr[i].top, m_clSfrInfo.m_clRectSnr[i].right, m_clSfrInfo.m_clRectSnr[i].bottom);
        WritePrivateProfileString(_T("SnrMark"), szIniIndex, szData, szPath);
    }
	for (i = 0; i < 4; i++)		//RIGHT
	{
		// SNR 마크 영역
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%02d"), i + 1);
		_stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d"), m_clSfrInfo.m_clRectSnr2[i].left,
			m_clSfrInfo.m_clRectSnr2[i].top, m_clSfrInfo.m_clRectSnr2[i].right, m_clSfrInfo.m_clRectSnr2[i].bottom);
		WritePrivateProfileString(_T("SnrMark2"), szIniIndex, szData, szPath);
	}
    //------------------------------------------------------------------------------
    //
    //------------------------------------------------------------------------------
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nMtfOverlayUse);
	WritePrivateProfileString(_T("SfrOverlay"), _T("Use"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf"), m_dStainLsbCenter, m_dStainLsbCorner, m_dStainLsbEdge);
	WritePrivateProfileString(_T("StainLSB"), _T("Threshold"), szData, szPath);
	
	_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf"), m_dStainYMeanCenter, m_dStainYMeanCorner, m_dStainYMeanEdge);
	WritePrivateProfileString(_T("StainYMean"), _T("Threshold"),szData, szPath);
	
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nMarkNo);
	WritePrivateProfileString(_T("Vision"), _T("MarkNo"), szData, szPath);

	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nMinMatching);
	WritePrivateProfileString(_T("Vision"), _T("Mathcing"), szData, szPath);


    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / "), 
        m_nDirection[0], m_nDirection[1], m_nDirection[2], m_nDirection[3], m_nDirection[4], m_nDirection[5], m_nDirection[6], m_nDirection[7], m_nDirection[8], m_nDirection[9], 
        m_nDirection[10], m_nDirection[11], m_nDirection[12], m_nDirection[13], m_nDirection[14], m_nDirection[15], m_nDirection[16], m_nDirection[17], m_nDirection[18], m_nDirection[19]);
    WritePrivateProfileString(_T("ASMI_SFR_SPEC"), _T("Direction"), szData, szPath);
    
    //m_dLinePulse
    _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dLinePulse);
    WritePrivateProfileString(_T("LINE_PULSE"), _T("Linepulse"), szData, szPath);
    //pattern
    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / "),
        m_nPatternPos[0].x, m_nPatternPos[1].x, m_nPatternPos[2].x, m_nPatternPos[3].x, m_nPatternPos[4].x,
        m_nPatternPos[5].x, m_nPatternPos[6].x, m_nPatternPos[7].x, m_nPatternPos[8].x);
    WritePrivateProfileString(_T("PATTERN"), _T("PatternPosX"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / "),
        m_nPatternPos[0].y, m_nPatternPos[1].y, m_nPatternPos[2].y, m_nPatternPos[3].y, m_nPatternPos[4].y,
        m_nPatternPos[5].y, m_nPatternPos[6].y, m_nPatternPos[7].y, m_nPatternPos[8].y);
    WritePrivateProfileString(_T("PATTERN"), _T("PatternPosY"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / "),
        m_nPatternSize[0].x, m_nPatternSize[1].x, m_nPatternSize[2].x, m_nPatternSize[3].x, m_nPatternSize[4].x,
        m_nPatternSize[5].x, m_nPatternSize[6].x, m_nPatternSize[7].x, m_nPatternSize[8].x);
    WritePrivateProfileString(_T("PATTERN"), _T("PatternSizeX"), szData, szPath);
    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / "),
        m_nPatternSize[0].y, m_nPatternSize[1].y, m_nPatternSize[2].y, m_nPatternSize[3].y, m_nPatternSize[4].y,
        m_nPatternSize[5].y, m_nPatternSize[6].y, m_nPatternSize[7].y, m_nPatternSize[8].y);
    WritePrivateProfileString(_T("PATTERN"), _T("PatternSizeY"), szData, szPath);

    //sfr roi save
    //m_MTF_ROI_Pos[i].x
    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / "),
        m_MTF_ROI_Pos[0].x, m_MTF_ROI_Pos[1].x, m_MTF_ROI_Pos[2].x, m_MTF_ROI_Pos[3].x, m_MTF_ROI_Pos[4].x, m_MTF_ROI_Pos[5].x, m_MTF_ROI_Pos[6].x, m_MTF_ROI_Pos[7].x, m_MTF_ROI_Pos[8].x, m_MTF_ROI_Pos[9].x,
        m_MTF_ROI_Pos[10].x, m_MTF_ROI_Pos[11].x, m_MTF_ROI_Pos[12].x, m_MTF_ROI_Pos[13].x, m_MTF_ROI_Pos[14].x, m_MTF_ROI_Pos[15].x, m_MTF_ROI_Pos[16].x, m_MTF_ROI_Pos[17].x, m_MTF_ROI_Pos[18].x, m_MTF_ROI_Pos[19].x);
    WritePrivateProfileString(_T("SFR_ROI_OFFSET"), _T("OffsetX"), szData, szPath);

    _stprintf_s(szData, SIZE_OF_1K, _T("%d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / %d / "),
        m_MTF_ROI_Pos[0].y, m_MTF_ROI_Pos[1].y, m_MTF_ROI_Pos[2].y, m_MTF_ROI_Pos[3].y, m_MTF_ROI_Pos[4].y, m_MTF_ROI_Pos[5].y, m_MTF_ROI_Pos[6].y, m_MTF_ROI_Pos[7].y, m_MTF_ROI_Pos[8].y, m_MTF_ROI_Pos[9].y,
        m_MTF_ROI_Pos[10].y, m_MTF_ROI_Pos[11].y, m_MTF_ROI_Pos[12].y, m_MTF_ROI_Pos[13].y, m_MTF_ROI_Pos[14].y, m_MTF_ROI_Pos[15].y, m_MTF_ROI_Pos[16].y, m_MTF_ROI_Pos[17].y, m_MTF_ROI_Pos[18].y, m_MTF_ROI_Pos[19].y);
    WritePrivateProfileString(_T("SFR_ROI_OFFSET"), _T("OffsetY"), szData, szPath);

    /*GetPrivateProfileString(_T("SFR_ROI_OFFSET"), _T("OffsetX"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    for (i = 0; i < MAX_SFR_INSP_CNT; i++)
    {
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_MTF_ROI_Pos[i].x = _ttof((TCHAR*)(LPCTSTR)sToken);

    }
    GetPrivateProfileString(_T("SFR_ROI_OFFSET"), _T("OffsetY"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    for (i = 0; i < MAX_SFR_INSP_CNT; i++)
    {
        AfxExtractSubString(sToken, szIniBuff, i, _T('/'));
        m_MTF_ROI_Pos[i].y = _ttof((TCHAR*)(LPCTSTR)sToken);

    }*/
	this->CopyBackup(szModelName);
}

//-----------------------------------------------------------------------------
//
//	티칭 데이터 저장
//
//-----------------------------------------------------------------------------
void CModelData::SaveTeachData(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szData[SIZE_OF_1K];	
	int nPosi;
	int i, j;

	this->CopyBackup(szModelName);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\%s_AA%d.ini"), BASE_MODEL_PATH, szModelName, szModelName, m_nUnit+1);

	for (i = 0; i < MAX_POS_COUNT; i++)
	{
		nPosi = 0;
		for (j = 0; j < MAX_MOTOR_COUNT; j++)
		{
			_stprintf_s(&szData[nPosi], (SIZE_OF_1K - nPosi), _T("%.03lf /"), m_stTeachData[i].dPos[j]);
			nPosi = (int)_tcslen(szData);
		}
		// 마지막 /는 뺀다.
		szData[nPosi - 1] = NULL;

		WritePrivateProfileString(_T("TEACH"), POS_NAME[i], szData, szPath);
	}
}

//-----------------------------------------------------------------------------
//
//	모델 설정 파일 백업
//
//-----------------------------------------------------------------------------
void CModelData::CopyBackup(TCHAR* szModelName)
{
	TCHAR szBackupPath[SIZE_OF_1K];
	TCHAR szPath[SIZE_OF_1K];		
	SYSTEMTIME stSysTime;
	CFileFind clFinder;

	GetLocalTime(&stSysTime);

	if (clFinder.FindFile(BASE_DATA_PATH) == FALSE)
		CreateDirectory(BASE_DATA_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup"), BASE_DATA_PATH);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s"), BASE_DATA_PATH, szModelName);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d"), BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d\\%02d"), BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szBackupPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d\\%02d\\%s_%02d_%02d_%02d_%02d_%03d.ini"),
		BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, szModelName, stSysTime.wDay, stSysTime.wHour,
		stSysTime.wMinute, stSysTime.wSecond, stSysTime.wMilliseconds);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\%s_AA%d.ini"), BASE_MODEL_PATH, szModelName, szModelName, m_nUnit);

	CopyFile(szPath, szBackupPath, TRUE);

}
//-----------------------------------------------------------------------------
//
//	패턴 이미지 로드,저장
//
//-----------------------------------------------------------------------------
void CModelData::PatternLoad(TCHAR* szModelName)
{
#ifdef ON_LINE_MIL
    TCHAR szPath[SIZE_OF_1K];
    CString strType = "CHART";
    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\CHART_Mark_0-Mask.pat"), BASE_MODEL_PATH, szModelName, m_nUnit+1);
    MpatRestore(g_clVision.m_MilSystem[0], szPath, &g_clVision.ChartCenterPatternImage[m_nUnit]);
    for (int i = 0; i<MAX_LAST_INSP_COUNT; i++)
    {
        _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\%s_Mark_%d-Mask.pat"), BASE_MODEL_PATH, szModelName, m_nUnit+1, strType, i);
        MpatRestore(g_clVision.m_MilSystem[0], szPath, &g_clVision.FieldPatternImage[m_nUnit][i]);
    }
#endif
}
void CModelData::PatternSave(TCHAR* szModelName)
{
    TCHAR szPath[SIZE_OF_1K];
    int iTemp = 0;
    for (int i = 0; i<MAX_LAST_INSP_COUNT; i++)
    {
        g_clModelData[m_nUnit].m_nPatternPos[i].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clPtOffset[i].x;
        g_clModelData[m_nUnit].m_nPatternPos[i].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clPtOffset[i].y;
        g_clModelData[m_nUnit].m_nPatternSize[i].x = g_clModelData[m_nUnit].m_clSfrInfo.m_nSizeX;
        g_clModelData[m_nUnit].m_nPatternSize[i].y = g_clModelData[m_nUnit].m_clSfrInfo.m_nSizeY;

        //g_clVision.DrawMOverlayBox(m_nCamNo, m_clRectCircle[i], M_COLOR_MAGENTA, 1, FALSE, PS_DOT);
        g_clVision.DrawMOverlayBox(m_nUnit, g_clModelData[m_nUnit].m_nPatternPos[i].x, g_clModelData[m_nUnit].m_nPatternPos[i].y,
            g_clModelData[m_nUnit].m_nPatternPos[i].x + g_clModelData[m_nUnit].m_nPatternSize[i].x,
            g_clModelData[m_nUnit].m_nPatternPos[i].y + g_clModelData[m_nUnit].m_nPatternSize[i].y, PS_SOLID, M_COLOR_BLUE);

       /* MpatFree(g_clVision.ChartCenterPatternImage[m_nUnit]);
        MpatFree(g_clVision.MilTempImage[m_nUnit]);*/
        //MbufClear(g_clVision.ChartCenterPatternImage[m_nUnit], 0);
        //MbufClear(g_clVision.MilTempImage[m_nUnit], 0);
        //g_clVision.ChartCenterPatternImage[m_nUnit] = M_NULL;
        MbufAlloc2d(g_clVision.m_MilSystem[0], 
        g_clModelData[m_nUnit].m_nPatternSize[i].x, g_clModelData[m_nUnit].m_nPatternSize[i].y, M_DEF_IMAGE_TYPE, M_IMAGE + M_DISP, 
            &g_clVision.MilTempImage[m_nUnit]);
        //
        MpatAllocModel(g_clVision.m_MilSystem[0], g_clVision.m_MilCcdProcChild[m_nUnit][2], 
            g_clModelData[m_nUnit].m_nPatternPos[i].x, g_clModelData[m_nUnit].m_nPatternPos[i].y, 
            g_clModelData[m_nUnit].m_nPatternSize[i].x, g_clModelData[m_nUnit].m_nPatternSize[i].y, M_NORMALIZED, 
            &g_clVision.ChartCenterPatternImage[m_nUnit]);
        //
        MpatDraw(M_DEFAULT, g_clVision.ChartCenterPatternImage[m_nUnit], g_clVision.MilTempImage[m_nUnit], M_DRAW_IMAGE, M_DEFAULT, M_DEFAULT);
        MpatSetCenter(g_clVision.ChartCenterPatternImage[m_nUnit], g_clModelData[m_nUnit].m_nPatternSize[i].x / 2, g_clModelData[m_nUnit].m_nPatternSize[i].y / 2);
        //저장
        {
            CString FolderName;
            FolderName.Format("%s", DATA_DIR);

            CString strType = "CHART";

            CString strPatDir;
            _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\%s_Mark_%d-Mask.pat"), BASE_MODEL_PATH, szModelName,  m_nUnit+1, strType, i);
            //strPatDir.Format("%s\\Model\\%s\\%s_Mark_%d-Mask.pat", FolderName, model.name, strType, i);
            MpatSave(szPath, g_clVision.ChartCenterPatternImage[m_nUnit]);

            _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\%s_Mark_%d-Mask.bmp"), BASE_MODEL_PATH, szModelName, m_nUnit+1, strType, i);
            //strPatDir.Format("%s\\Model\\%s\\%s_Mark_%d-Mask.bmp", BASE_MODEL_PATH, szModelName, strType, i);
            MbufSave(szPath, g_clVision.MilTempImage[m_nUnit]);
            //
        }
        MpatFree(g_clVision.ChartCenterPatternImage[m_nUnit]);
        MbufClear(g_clVision.MilTempImage[m_nUnit], 0);
    }

    g_clModelData[m_nUnit].Save(g_clSysData.m_szModelName);
	AddLog(_T("[INFO] pattern save ok!"), 1, m_nUnit);
    //_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\%s_Mark_%d-Mask.pat"), BASE_MODEL_PATH, szModelName, m_nUnit, i);
    //model.Save();
    //vision.drawOverlay(CCD);
}

//-----------------------------------------------------------------------------
//
//	ACMIS Dll Spec 로드,저장
//
//-----------------------------------------------------------------------------
void CModelData::AcmisDataLoad(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szIniIndex[SIZE_OF_100BYTE];
	TCHAR szIniBuff[SIZE_OF_1K];
	CString sToken = _T("");
	int i, j;
	//_ttoi
	//_ttof
	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\ACMIS_AA%d.ini"), BASE_MODEL_PATH, szModelName, m_nUnit + 1);

	//-------------------------------------------------------------------------------------------------------------------------------------
	// DefectSpec, stSpecAllOnsemiRCCBSpec
	int DefectMax = sizeof(DEFECT_SPEC_NAME) / sizeof(DEFECT_SPEC_NAME[0]);
	for (i = 0; i < DefectMax; i++)
	{
		GetPrivateProfileString(_T("ACMIS_DEFECT"), DEFECT_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_DefectSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
	GetPrivateProfileString(_T("ACMIS_DEFECT_LIMIT"), _T("defectCount"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	n_DefectCountLimit = _ttoi((TCHAR*)(LPCTSTR)szIniBuff);

	GetPrivateProfileString(_T("ACMIS_DEFECT_LIMIT"), _T("clusterCount"), _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	n_ClusterCountLimit = _ttoi((TCHAR*)(LPCTSTR)szIniBuff);

	//-------------------------------------------------------------------------------------------------------------------------------------
	//rotate, oc
	//
	int OcMax = 2;
	for (i = 0; i < OcMax; i++)
	{
		GetPrivateProfileString(_T("ACMIS_OC"), OC_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        m_OcSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Color Sensitivity
    int ColorMax = 8;
    for (i = 0; i < ColorMax; i++)
    {
        GetPrivateProfileString(_T("ACMIS_COLOR_SENS"), COLOR_SENS_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        m_ColorSensitivitySpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
    }
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    //SNR
    int SnrMax = 2;
    for (i = 0; i < SnrMax; i++)
    {
        GetPrivateProfileString(_T("ACMIS_SNR"), SNR_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        m_SnrSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
    }
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//Color Uniform
	int UniformMax = 7;
	for (i = 0; i < UniformMax; i++)
	{
		GetPrivateProfileString(_T("ACMIS_UNIFORMITY"), UNIFORMITY_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_UniformSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//Relative Illumination 
	int IlluminationMax = sizeof(RI_SPEC_NAME) / sizeof(RI_SPEC_NAME[0]);
	for (i = 0; i < IlluminationMax; i++)
	{
		GetPrivateProfileString(_T("ACMIS_RI"), RI_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_RISpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//Illumination Center

	for (i = 0; i < sizeof(IC_SPEC_NAME) / sizeof(IC_SPEC_NAME[0]); i++)
	{
		GetPrivateProfileString(_T("ACMIS_IC"), IC_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_ICSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}

	//-------------------------------------------------------------------------------------------------------------------------------------
	//RelativeIllumination
	//[ACMIS_RI]
	//
	//for (i = 0; i < sizeof(IC_SPEC_NAME) / sizeof(IC_SPEC_NAME[0]); i++)
	//{
	//	GetPrivateProfileString(_T("ACMIS_IC"), IC_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
	//	m_RISpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	//}

	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//STAIN

	for (i = 0; i < sizeof(STAIN_BLEMISH_SPEC_NAME) / sizeof(STAIN_BLEMISH_SPEC_NAME[0]); i++)
	{
		GetPrivateProfileString(_T("ACMIS_BLACKSPOT"), STAIN_BLEMISH_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_BlemishSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
	for (i = 0; i < sizeof(STAIN_LCB_SPEC_NAME) / sizeof(STAIN_LCB_SPEC_NAME[0]); i++)
	{
		GetPrivateProfileString(_T("ACMIS_LCB"), STAIN_LCB_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_LcbSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
	for (i = 0; i < sizeof(STAIN_YMEAN_SPEC_NAME) / sizeof(STAIN_YMEAN_SPEC_NAME[0]); i++)
	{
		GetPrivateProfileString(_T("ACMIS_YMEAN"), STAIN_YMEAN_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		m_YmeanSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    //CHART
    for (i = 0; i < 5; i++)
    {
        GetPrivateProfileString(_T("ACMIS_CHART"), CHART_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        m_ChartSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
    }
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    //RelativeIllumination
    //[ACMIS_RI]
    //
    //for (i = 0; i < 8; i++)
    //{
    //    GetPrivateProfileString(_T("ACMIS_RI"), RI_SPEC_NAME[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
    //    m_RISpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
    //}
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    //RelativeIllumination
    //[ACMIS_RI_ROI]  ROI LOAD 1000개  THRESHOLD 400만 UI로 빼면된다.
    //
    int _x = 0;
    int _y = 0;
    //X(Left)	Y(Top)	Width(Right)	Heigh(Bottom)	Threshold_Ch0	Threshold_Ch1	Threshold_Ch2	Threshold_Ch3	Offset	Type
    for (_y = 0; _y < 100; _y++)    //총 100개 항목
    {
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%d"), _y + 1);
        GetPrivateProfileString(_T("ACMIS_RI_ROI"), szIniIndex, _T(""), szIniBuff, sizeof(szIniBuff), szPath);
        for (_x = 0; _x < 10; _x++)
        {
            AfxExtractSubString(sToken, szIniBuff, _x, _T('/'));
            m_RirOI[_y][_x] = _ttof((TCHAR*)(LPCTSTR)sToken);
        }
    }
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
	return;
}
void CModelData::AcmisDataSave(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szData[SIZE_OF_1K];
    TCHAR szIniBuff[SIZE_OF_1K];
    TCHAR szIniIndex[SIZE_OF_100BYTE];
	int nPosi = 0;
	int i=0, j=0;

	this->CopyBackup(szModelName);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\ACMIS_AA%d.ini"), BASE_MODEL_PATH, szModelName, m_nUnit + 1);

	//-------------------------------------------------------------------------------------------------------------------------------------
	// DefectSpec, stSpecAllOnsemiRCCBSpec
	//int DefectMax = 19;
	for (i = 0; i < sizeof(DEFECT_SPEC_NAME) / sizeof(DEFECT_SPEC_NAME[0]); i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_DefectSpec[i]);
		WritePrivateProfileString(_T("ACMIS_DEFECT"), DEFECT_SPEC_NAME[i], szData, szPath);
	}
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), n_DefectCountLimit);
	WritePrivateProfileString(_T("ACMIS_DEFECT_LIMIT"), _T("defectCount"), szData, szPath);
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), n_ClusterCountLimit);
	WritePrivateProfileString(_T("ACMIS_DEFECT_LIMIT"), _T("clusterCount"), szData, szPath);
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//fov, distortion, rotate
	//m_FovSpec
	int OCMax = 2;
	for (i = 0; i < OCMax; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_OcSpec[i]);
		WritePrivateProfileString(_T("ACMIS_OC"), OC_SPEC_NAME[i], szData, szPath);
	}
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	// Color Sensitivity
	int ColorMax = 8;
	for (i = 0; i < ColorMax; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_ColorSensitivitySpec[i]);
		WritePrivateProfileString(_T("ACMIS_COLOR_SENS"), COLOR_SENS_SPEC_NAME[i], szData, szPath);
	}
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    // SNR
    int SnrMax = 2;
    for (i = 0; i < SnrMax; i++)
    {
        _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_SnrSpec[i]);
        WritePrivateProfileString(_T("ACMIS_SNR"), SNR_SPEC_NAME[i], szData, szPath);
    }

    
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//Uniform
	int UniformMax = 7;
	for (i = 0; i < UniformMax; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_UniformSpec[i]);
		WritePrivateProfileString(_T("ACMIS_UNIFORMITY"), UNIFORMITY_SPEC_NAME[i], szData, szPath);
	}
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//Relative Illumination 
	int IlluminationMax = sizeof(RI_SPEC_NAME) / sizeof(RI_SPEC_NAME[0]);
	for (i = 0; i < IlluminationMax; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_RISpec[i]);
		WritePrivateProfileString(_T("ACMIS_RI"), RI_SPEC_NAME[i], szData, szPath);
	}
	
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//stain
	for (i = 0; i < sizeof(STAIN_BLEMISH_SPEC_NAME) / sizeof(STAIN_BLEMISH_SPEC_NAME[0]); i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_BlemishSpec[i]);
		WritePrivateProfileString(_T("ACMIS_BLACKSPOT"), STAIN_BLEMISH_SPEC_NAME[i], szData, szPath);
	}
    //
	for (i = 0; i < sizeof(STAIN_LCB_SPEC_NAME) / sizeof(STAIN_LCB_SPEC_NAME[0]); i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_LcbSpec[i]);
		WritePrivateProfileString(_T("ACMIS_LCB"), STAIN_LCB_SPEC_NAME[i], szData, szPath);
	}
    //
	for (i = 0; i < sizeof(STAIN_YMEAN_SPEC_NAME) / sizeof(STAIN_YMEAN_SPEC_NAME[0]); i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_YmeanSpec[i]);
		WritePrivateProfileString(_T("ACMIS_YMEAN"), STAIN_YMEAN_SPEC_NAME[i], szData, szPath);
	}
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Chart
    for (i = 0; i < 5; i++)
    {
        _stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_ChartSpec[i]);
        WritePrivateProfileString(_T("ACMIS_CHART"), CHART_SPEC_NAME[i], szData, szPath);
    }
	//-------------------------------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------------------------
	//IC
	int ICCount = sizeof(IC_SPEC_NAME) / sizeof(IC_SPEC_NAME[0]);
	for (i = 0; i < ICCount; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_ICSpec[i]);
		WritePrivateProfileString(_T("ACMIS_IC"), IC_SPEC_NAME[i], szData, szPath);
	}

    //RI THRESHOLD SPEC
    int _y = 0;
    int _x = 0;
    for (_y = 0; _y < 100; _y++)    //총 100개 항목
    {
        nPosi = 0;
        for (_x = 0; _x < 10; _x++)
        {
            _stprintf_s(&szIniBuff[nPosi], (SIZE_OF_1K - nPosi), _T("%.03lf / "), m_RirOI[_y][_x]);
            nPosi = (int)(_tcslen(szIniBuff));
        }
        _stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("ROI%d"), _y + 1);
        WritePrivateProfileString(_T("ACMIS_RI_ROI"), szIniIndex, szIniBuff, szPath);
    }
    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------------------------------------------
    
	//---------

}
///////////////////////////////////////////////////////////////////////////////
//
//	Mark Data
//

//-----------------------------------------------------------------------------
//
//	생성자
//
//-----------------------------------------------------------------------------
CMarkData::CMarkData(void)
{
	int i;

	for (i = 0; i < MAX_MARK_COUNT; i++)
	{
		m_nSmooth[i] = 50;
		m_clRectRoi[i].left = m_clRectRoi[i].top = 10;
		m_clRectRoi[i].right = m_clRectRoi[i].bottom = 50;
	}
}

//-----------------------------------------------------------------------------
//
//	소멸자
//
//-----------------------------------------------------------------------------
CMarkData::~CMarkData(void)
{

}

//-----------------------------------------------------------------------------
//
//	마크 데이터 로드
//
//-----------------------------------------------------------------------------
void CMarkData::LoadData(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szIniIndex[SIZE_OF_100BYTE];
	int i;

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\MarkData.ini"), BASE_MODEL_PATH, szModelName, m_nUnit + 1);
	for (i = 0; i < MAX_MARK_COUNT; i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d"), i + 1);
		m_nSmooth[i] = GetPrivateProfileInt(_T("Smooth"), szIniIndex, 50, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Top"), i + 1);
		m_clRectRoi[i].top = GetPrivateProfileInt(_T("ROI"), szIniIndex, 0, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Left"), i + 1);
		m_clRectRoi[i].left = GetPrivateProfileInt(_T("ROI"), szIniIndex, 0, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Right"), i + 1);
		m_clRectRoi[i].right = GetPrivateProfileInt(_T("ROI"), szIniIndex, 0, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Bottom"), i + 1);
		m_clRectRoi[i].bottom = GetPrivateProfileInt(_T("ROI"), szIniIndex, 0, szPath);
	}
}

//-----------------------------------------------------------------------------
//
//	마크 데이터 저장
//
//-----------------------------------------------------------------------------
void CMarkData::SaveData(TCHAR* szModelName)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szIniIndex[SIZE_OF_100BYTE];
	TCHAR szData[SIZE_OF_100BYTE];
	int i;

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\MarkData.ini"), BASE_MODEL_PATH, szModelName, m_nUnit + 1);
	for (i = 0; i < MAX_MARK_COUNT; i++)
	{
		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d"), i + 1);
		_stprintf_s(szData, SIZE_OF_100BYTE, _T("%d"), m_nSmooth[i]);
		WritePrivateProfileString(_T("ROI"), szIniIndex, szData, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Top"), i + 1);
		_stprintf_s(szData, SIZE_OF_100BYTE, _T("%d"), m_clRectRoi[i].top);
		WritePrivateProfileString(_T("ROI"), szIniIndex, szData, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Left"), i + 1);
		_stprintf_s(szData, SIZE_OF_100BYTE, _T("%d"), m_clRectRoi[i].left);
		WritePrivateProfileString(_T("ROI"), szIniIndex, szData, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Right"), i + 1);
		_stprintf_s(szData, SIZE_OF_100BYTE, _T("%d"), m_clRectRoi[i].right);
		WritePrivateProfileString(_T("ROI"), szIniIndex, szData, szPath);

		_stprintf_s(szIniIndex, SIZE_OF_100BYTE, _T("Mark%02d_Bottom"), i + 1);
		_stprintf_s(szData, SIZE_OF_100BYTE, _T("%d"), m_clRectRoi[i].bottom);
		WritePrivateProfileString(_T("ROI"), szIniIndex, szData, szPath);
	}

	this->CopyBackup(szModelName);
}

//-----------------------------------------------------------------------------
//
//	백업 복사
//
//-----------------------------------------------------------------------------
void CMarkData::CopyBackup(TCHAR* szModelName)
{
	TCHAR szBackupPath[SIZE_OF_1K];
	TCHAR szPath[SIZE_OF_1K];
	SYSTEMTIME stSysTime;
	CFileFind clFinder;

	GetLocalTime(&stSysTime);

	if (clFinder.FindFile(BASE_DATA_PATH) == FALSE)
		CreateDirectory(BASE_DATA_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup"), BASE_DATA_PATH);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s"), BASE_DATA_PATH, szModelName);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d"), BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d\\%02d"), BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d\\%02d\\AA%d"), BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, m_nUnit + 1);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szBackupPath, SIZE_OF_1K, _T("%s\\Backup\\%s\\%04d%02d\\%02d\\AA%d\\MarkData_%02d_%02d_%02d_%03d.ini"),
		BASE_DATA_PATH, szModelName, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, m_nUnit + 1, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond, stSysTime.wMilliseconds);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%s\\AA%d\\MarkData.ini"), BASE_MODEL_PATH, szModelName, m_nUnit + 1);

	CopyFile(szPath, szBackupPath, TRUE);
}



//-----------------------------------------------------------------------------
//
//	Task 생성자
//
//-----------------------------------------------------------------------------
CTaskWork::CTaskWork()
{
	int i;

	m_nAutoFlag = MODE_STOP;
	m_nStartStep = 0;
	m_nEndStep = 0;
	m_nStartLensStep = 0;
	m_nEndLensStep = 0;

	m_nCurrentStep = 0;
	m_nCurrentLensStep = 0;

	m_nDrawBarStep = 0;
	m_nCountOfStepAA = 0;
	m_nCountOfTotalStepAA = 0;
	m_nCountOfSecondStepAA = 0;
	m_bFlagDecreaseSFR = false;

//	memset(&m_stOsCheck, 0x00, sizeof(m_stOsCheck));
	memset(&m_stSfrInsp, 0x00, sizeof(m_stSfrInsp));
//	memset(&m_stDefectInsp, 0x00, sizeof(m_stDefectInsp));

	m_clOpticalRoi.left = (LONG)(g_clModelData[m_nUnit].m_nWidth * 0.1 + 0.5);
	m_clOpticalRoi.top = (LONG)((g_clModelData[m_nUnit].m_nHeight/* - 4*/) * 0.1 + 0.5);
	m_clOpticalRoi.right = (LONG)(g_clModelData[m_nUnit].m_nWidth * 0.9 + 0.5);
	m_clOpticalRoi.bottom = (LONG)((g_clModelData[m_nUnit].m_nHeight/* - 4*/) * 0.9 + 0.5);
	
	m_nTotalCount = 0;
	m_nTotalOkCount = 0;
	m_nTotalNgCount = 0;
	m_nUsePinCount = 0;

	m_nMTFNgCount = 0;
	m_nOCNgCount = 0;
	m_nDistortionNgCount = 0;
	m_nCurrentNgCount = 0;
	m_nTestPatternNgCount = 0;
	m_nDefectInspNgCount = 0;
	m_nStainInspNgCount = 0;
	m_nDarkInspNgCount = 0;
	m_nUniformityNgCount = 0;

	m_dDataOffsetX[0] = m_dDataOffsetX[1] = 0.0;
	m_dDataOffsetY[0] = m_dDataOffsetY[1] = 0.0;
	m_dDataOffsetTh[0] = m_dDataOffsetTh[1] = 0.0;

	m_dTotalTactTime = 0.0;
	m_dAlignTackTime = 0.0;
	m_dLaserTactTime = 0.0;
	m_dAATactTime = 0.0;
	m_dInspTactTime = 0.0;

	/*m_bFlagMoveLensBonding = false;
	m_bFlagMoveLensComplete = false;
	m_bFlagMoveLensLoading = false;*/

	m_bWaitLensBonding = false;
	m_bMovingLens = false;		
	m_bMoveLensLoading = false;

	m_bLensMovePickup = false;
	m_bLensStageOn = false;
	m_nComplType = 0;

	m_nEmission = 0;
	grabFailCount = 0;
	_stprintf_s(m_szChipID, SIZE_OF_100BYTE, _T("EMPTY"));
	_stprintf_s(m_szLotID, SIZE_OF_100BYTE, _T("EMPTY"));

	for(i = 0; i < MAX_LENS_IF_COUNT; i++)
		m_bLensSocketIF[i] = false;
	
	for(i = 0 ;i < MAX_PCB_IF_COUNT; i++)
		m_bPcbSocketIF[i] = false;

	for(i = 0; i < MAX_ULD_IF_COUNT; i++)
		m_bUldSocketIF[i] = false;

	m_bDoorInterlock = false;
	m_bLensInterLock = false;
	m_bPcbInterLock = false;
	m_bManualAAMove = false;
	m_bManualLaserPos = false;	//false = 외부

	m_bManualTest = false;
	m_bInputSignal = false;
	m_bOutputSignal = false;

	m_dImgShiftX = 0.0;
	m_dImgShiftY = 0.0;
	m_dImgShiftTh = 0.0;

	m_dOcResultX = 0.0;
	m_dOcResultY = 0.0;

	m_dOutTx = 0.0;
	m_dOutTy = 0.0;

    m_vDirection.resize(MAX_SFR_INSP_CNT);
    m_vFrquency.resize(MAX_SFR_INSP_CNT);
    m_vOffset.resize(MAX_SFR_INSP_CNT);
    m_vSFR.resize(MAX_SFR_INSP_CNT);
    m_vThreshold.resize(MAX_SFR_INSP_CNT);
    m_vROI.resize(MAX_SFR_INSP_CNT);
}

//-----------------------------------------------------------------------------
//
//	Task 소멸자
//
//-----------------------------------------------------------------------------
CTaskWork::~CTaskWork()
{
	m_bSfrResult = false;

	m_nCountOfTotalStepAA = 0;

	m_nCountOfStepAA = m_nCountOfSecondStepAA = 0;

	m_nResultCode = 0;
	m_dFOV[0] = m_dFOV[1] = m_dFOV[2] = m_dFOV[3] = m_dFOV[4] = 0.0;

	//memset(&m_stSfrInsp, 0x00, sizeof(STRUC_SFR_INSP));

	m_bSecondAA = false;

	//m_iRetry_Opt = m_iRetry_Opt_Lens = 0;

	m_bFlagFineMove = false;

	m_bFlagDecreaseSFR = false;

   
}

//-----------------------------------------------------------------------------
//
//	TASK 데이터 유닛번호 설정
//
//-----------------------------------------------------------------------------
void CTaskWork::SetUnit(int nUnit)
{
	m_nUnit = nUnit;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void CTaskWork::LoadData()
{
	TCHAR szPath[SIZE_OF_1K];
	
	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\TaskWork_AA%d.ini"), BASE_DATA_PATH, m_nUnit + 1);

	// 생산량
	m_nTotalCount = GetPrivateProfileInt(_T("COUNT"), _T("Total"), 0, szPath);

	// TOTAL OK 수량
	m_nTotalOkCount = GetPrivateProfileInt(_T("COUNT"), _T("TotalOk"), 0, szPath);

	// TOTAL NG 수량
	m_nTotalNgCount = GetPrivateProfileInt(_T("COUNT"), _T("TotalNg"), 0, szPath);

	// MTF NG 수량
	m_nMTFNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("MtfNg"), 0, szPath);

	// OC NG 수량
	m_nOCNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("OCNg"), 0, szPath);
	
	// DISTORTION NG 수량
	m_nDistortionNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("DistortionNg"), 0, szPath);
	
	// CURRENT NG 수량
	m_nCurrentNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("CurrentNg"), 0, szPath);
	
	// TEST PATTERN NG 수량
	m_nTestPatternNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("TestPatternNg"), 0, szPath);

	// DEFECT NG 수량
	m_nDefectInspNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("DefectNg"), 0, szPath);

	// STAIN NG 수량
	m_nStainInspNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("StainNg"), 0, szPath);

	// DARK NG 수량
	m_nDarkInspNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("DarkNg"), 0, szPath);
		
	// UNIFORMITY NG 수량
	m_nUniformityNgCount = GetPrivateProfileInt(_T("NG_COUNT"), _T("UniformityNg"), 0, szPath);

	// 포거핀 사용량
	m_nUsePinCount = GetPrivateProfileInt(_T("COUNT"), _T("SensorCnt"), 0, szPath);

	// 제품 바코드
	GetPrivateProfileString(_T("LOT"), _T("Barcode"), _T(""), m_szChipID, sizeof(m_szChipID), szPath);

	// UNIFORMITY NG 수량
	m_nEmission = GetPrivateProfileInt(_T("LOT"), _T("Emission"), 0, szPath);
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void CTaskWork::SaveData()
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szData[SIZE_OF_1K];
	CFileFind clFind;

	if (clFind.FindFile(BASE_DATA_PATH) == FALSE)
		CreateDirectory(BASE_DATA_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\TaskWork_AA%d.ini"), BASE_DATA_PATH, m_nUnit+1);
	
	// 생산량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nTotalCount);
	WritePrivateProfileString(_T("COUNT"), _T("Total"), szData, szPath);
	
	// TOTAL OK 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nTotalOkCount);
	WritePrivateProfileString(_T("COUNT"), _T("TotalOk"), szData, szPath);

	// TOTAL NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nTotalNgCount);
	WritePrivateProfileString(_T("COUNT"), _T("TotalNg"), szData, szPath);

	// MTF NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nMTFNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("MtfNg"), szData, szPath);

	// OC NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nOCNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("OCNg"), szData, szPath);

	// DISTORTION NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nDistortionNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("DistortionNg"), szData, szPath);

	// CURRENT NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nCurrentNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("CurrentNg"), szData, szPath);

	// TEST PATTERN NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nTestPatternNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("TestPatternNg"), szData, szPath);

	// DEFECT NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nDefectInspNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("DefectNg"), szData, szPath);

	// STAIN NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nStainInspNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("StainNg"), szData, szPath);

	// DARK NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nDarkInspNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("DarkNg"), szData, szPath);
	
	// UNIFORMITY NG 수량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nUniformityNgCount);
	WritePrivateProfileString(_T("NG_COUNT"), _T("UniformityNg"), szData, szPath);	

	// 포거핀 사용량
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nUsePinCount);
	WritePrivateProfileString(_T("COUNT"), _T("UsePinCnt"), szData, szPath);

	// 제품 바코드
	WritePrivateProfileString(_T("LOT"), _T("Barcode"), m_szChipID, szPath);

	// 제품 상태
	_stprintf_s(szData, SIZE_OF_1K, _T("%d"), m_nEmission);
	WritePrivateProfileString(_T("LOT"), _T("Emission"), szData, szPath);
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------

void CTaskWork::InitSfrInsp()
{
	m_bSfrResult = false;

	m_nCountOfTotalStepAA = 0;

	m_nCountOfStepAA = m_nCountOfSecondStepAA = 0;

	m_nResultCode = 0;
	m_dFOV[0] = m_dFOV[1] = m_dFOV[2] = m_dFOV[3] = m_dFOV[4] = 0.0;

	memset(&m_stSfrInsp, 0x00, sizeof(STRUC_SFR_INSP));

	m_bSecondAA = false;

	//m_iRetry_Opt = m_iRetry_Opt_Lens = 0;

	m_bFlagFineMove = false;

	m_bFlagDecreaseSFR = false;


    //아래 초기화해
    //g_clMesCommunication[nUnit].m_dMesMTF[i]
    //g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i]
}
//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void CTaskWork::InitSfrSpec()
{

}
//-----------------------------------------------------------------------------
//
//	생성자
//
//-----------------------------------------------------------------------------
CMandoInspLog::CMandoInspLog()
{
	m_sBarcodeID = _T("EMPTY");
	this->InitData();
}

//-----------------------------------------------------------------------------
//
//	소멸자
//
//-----------------------------------------------------------------------------
CMandoInspLog::~CMandoInspLog()
{

}

//-----------------------------------------------------------------------------
//
//	데이터 초기화
//
//-----------------------------------------------------------------------------
void CMandoInspLog::InitData()
{
	int i;

	::GetLocalTime(&m_stInspTime);	//작업 시작 시간 

	m_bInspRes = true;
	m_sNGList = _T("");

	m_dTilteOffset[0] = m_dTilteOffset[1] = 0.0;
	m_dPCBOffset[0] = m_dPCBOffset[1] = m_dPCBOffset[2] = 0.0;

	m_dCurrent = 0.0;
	m_sI2C = _T("");

	for (i = 0; i < 24; i++)
	{
		m_dMTF[i] = 0.0;
		m_d60lpmm[i] = m_d67lpmm[i] = 0.0;
	}

	m_dOCResult[0] = m_dOCResult[1] = 0.0;
	m_dDistortion = 0.0;

	m_dFov = 0.0;
	m_dDistortion = 0.0;
	m_dSnr = 0.0;
	m_dRotate = 0.0;
	m_Dark = 0.0;
	m_RI = 0.0;
	m_ColorUniformity = 0.0;		//이미지 두장 필요
	m_ColorSensitivity = 0.0;

	m_dDefect[0] = m_dDefect[1] = 0.0;
	m_dStain[0] = m_dStain[1] = 0.0;
	m_dShading65FC[0] = m_dShading65FC[1] = 0.0;
	m_dShading85FC[0] = m_dShading85FC[1] = 0.0;


	//! Main화면 NG List Overlay 관련 변수
	m_nNGCnt = 0;
	for (i = 0; i < 20; i++)
		m_sDispNG[i] = _T("");

	m_sSendNGName = _T("");

	m_dMinData[0] = m_dMinData[1] = m_dMinData[2] = 0.0;

    for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
    {
        m_LogSfr[i] = 0.0;
    }

    m_LogDefectBright = 0;
    m_LogDefectDark = 0.0;
    m_LogDefectHot = 0.0;
    m_LogDefectBrightCluster = 0.0;
    m_LogDefectDarkCluster = 0.0;
    m_LogDefectHotCluster = 0.0;
    m_LogDefectDarkHorLine = 0.0;
    m_LogDefectDarkVerLine = 0.0;
    m_LogDefectBrightHorLine = 0.0;
    m_LogDefectBrightVerLine = 0.0;
	for (i = 0; i < 4; i++)
	{
		m_LogDefectColumnFPN[i] = 0.0;
	}
   
    //
    m_LogOC_X = 8.0;          //890
    m_LogOC_Y = 0.0;          //930
    m_LogOC_DelatX = 0.0;     //-20
    m_LogOC_DelatY = 0.0;     //20
                        //
    m_LogDistortion = 0.0;
    //
    m_LogBlemishBlackSpot = 0.0;
    m_LogBlemishLcb = 0.0;
    m_LogBlemishRU_Ymean = 0.0;
    //
    m_Log_CS_RG_6500K = 0.0;
    m_Log_CS_BG_6500K = 0.0;
	m_Log_CS_GrGb_6500K = 0.0;
    m_Log_CS_RC_5000k = 0.0;
    m_Log_CS_BC_5000k = 0.0;
    m_Log_CS_CrCb_5000k = 0.0;

    for (i = 0; i < 100; i++)
    {
        m_Log_RI_RED[i] = 0.0;
        m_Log_RI_CLEARR[i] = 0.0;
        m_Log_RI_CLEARB[i] = 0.0;
        m_Log_RI_BLUE[i] = 0.0;
    }


    //
	m_Log_RI_CornerVar_R = 0.0;
	m_Log_RI_CornerVar_Cr = 0.0;
	m_Log_RI_CornerVar_Cb = 0.0;
	m_Log_RI_CornerVar_B = 0.0;

    m_Log_RI_Center_R = 0.0;
    m_Log_RI_Center_Cr = 0.0;
    m_Log_RI_Center_Cb = 0.0;
    m_Log_RI_Center_B = 0.0;
    m_Log_RI_LT_Ratio_R = 0.0;
    m_Log_RI_LT_Ratio_Cr = 0.0;
    m_Log_RI_LT_Ratio_Cb = 0.0;
    m_Log_RI_LT_Ratio_B = 0.0;
    m_Log_RI_RT_Ratio_R = 0.0;
    m_Log_RI_RT_Ratio_Cr = 0.0;
    m_Log_RI_RT_Ratio_Cb = 0.0;
    m_Log_RI_RT_Ratio_B = 0.0;
    m_Log_RI_LB_Ratio_R = 0.0;
    m_Log_RI_LB_Ratio_Cr = 0.0;
    m_Log_RI_LB_Ratio_Cb = 0.0;
    m_Log_RI_LB_Ratio_B = 0.0;
    m_Log_RI_RB_Ratio_R = 0.0;
    m_Log_RI_RB_Ratio_Cr = 0.0;
    m_Log_RI_RB_Ratio_Cb = 0.0;
    m_Log_RI_RB_Ratio_B = 0.0;

    //
    m_Log_SNR_SNR = 0.0;
    m_Log_SNR_DR = 0.0;
    //
    m_Log_CU_LT_Delta_RG = 0.0;
    m_Log_CU_LT_Delta_RB = 0.0;
    m_Log_CU_LT_Delta_BG = 0.0;
    m_Log_CU_RT_Delta_RG = 0.0;
    m_Log_CU_RT_Delta_RB = 0.0;
    m_Log_CU_RT_Delta_BG = 0.0;
    m_Log_CU_LB_Delta_RG = 0.0;
    m_Log_CU_LB_Delta_RB = 0.0;
    m_Log_CU_LB_Delta_BG = 0.0;
    m_Log_CU_RB_Delta_RG = 0.0;
    m_Log_CU_RB_Delta_RB = 0.0;
    m_Log_CU_RB_Delta_BG = 0.0;
    //
    m_Log_FOV_H_FOV = 0.0;
    m_Log_FOV_V_FOV = 0.0;
    m_Log_FOV_D_FOV = 0.0;
    m_Log_Rotate = 0.0;

}

//-----------------------------------------------------------------------------
//
//	AA후(UV전) 로그 저장
//
//-----------------------------------------------------------------------------
void CMandoInspLog::SaveLogAfterAA(int nUnit)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szFilePath[SIZE_OF_1K];
	TCHAR szLog[SIZE_OF_1K];
	TCHAR szTemp[SIZE_OF_100BYTE];
	CString sFileMode = _T("");
	CFileFind clFinder;
	CFile clFile;
	FILE* fp;
	int i;

	// Log폴더 만들기
	if (clFinder.FindFile(BASE_LOG_PATH) == FALSE)
		CreateDirectory(BASE_LOG_PATH, NULL);
	// 검사 폴더 만들기
	if (clFinder.FindFile(BASE_INSP_PATH) == FALSE)
		CreateDirectory(BASE_INSP_PATH, NULL);

	// 검사 폴더 만들기
	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%04d%02d\\%02d"), BASE_INSP_PATH, m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	if (g_clModelData[nUnit].m_nSFR_N_POS == 1)
		_stprintf_s(szTemp, SIZE_OF_100BYTE, _T("N2"));
	else
		_stprintf_s(szTemp, SIZE_OF_100BYTE, _T("N4"));

	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%04d%02d%02d_LOG-%dLineAA%d-AAAfter_%s.csv"),
		szPath, m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay, g_clSysData.m_nSysNo, nUnit+1, szTemp);

	if (clFinder.FindFile(szFilePath) == TRUE)
	{
		if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[ERROR] 파일이 사용 중입니다."));
			AddLog(szLog, 1, nUnit);

			return;
		}
		else
		{
			clFile.Close();
		}
	}

#ifdef _UNICODE
	sFileMode = _T("a,ccs=UTF-8");
#else
	sFileMode = _T("a + t");
#endif

	if (clFinder.FindFile(szFilePath) == FALSE)
	{
		_tfopen_s(&fp, szFilePath, sFileMode);
		if (fp != NULL)
		{
			_ftprintf_s(fp, _T("date, time, "));
			_ftprintf_s(fp, _T("ID, "));
			//_ftprintf_s(fp, _T("00_center, 01_LT_50F, 02_RT_50F, 03_LB_50F, 04_RB_50F, 05_LT_70F, 06_RT_70F,	07_LB_70F, "));
			//_ftprintf_s(fp, _T("08_RB_70F,	09_L_IN, 10_T_IN, 11_R_IN, 12_B_IN, 13_L_OUT, 14_T_OUT, 15_R_OUT, 16_B_OUT, "));
			_ftprintf_s(fp, _T("OC_X, OC_Y, Distortion"));

			if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_17P)
			{
				//! 화상검사기  60lp/mm ,  67lp/mm  위치(만도 AAB 추가)
				//_ftprintf_s(fp, _T(", 00_center_60lp, 01_LT_50F_60lp, 02_RT_50F_60lp, 03_LB_50F_60lp, 04_RB_50F_60lp, 05_LT_70F_60lp, 06_RT_70F_60lp, 07_LB_70F_60lp"));
				//_ftprintf_s(fp, _T(", 08_RB_70F_60lp, 09_L_IN_60lp, 10_T_IN_60lp, 11_R_IN_60lp, 12_B_IN_60lp, 13_L_OUT_60lp, 14_T_OUT_60lp, 15_R_OUT_60lp, 16_B_OUT_60lp"));

				_ftprintf_s(fp, _T(", 00_center_67lp, 01_LT_50F_67lp, 02_RT_50F_67lp, 03_LB_50F_67lp, 04_RB_50F_67lp, 05_LT_70F_67lp, 06_RT_70F_67lp, 07_LB_70F_67lp"));
				_ftprintf_s(fp, _T(", 08_RB_70F_67lp, 09_L_IN_67lp, 10_T_IN_67lp, 11_R_IN_67lp, 12_B_IN_67lp, 13_L_OUT_67lp, 14_T_OUT_67lp, 15_R_OUT_67lp, 16_B_OUT_67lp"));

				//_ftprintf_s(fp, _T(", 00_center, 01_LT_50F, 02_RT_50F, 03_LB_50F, 04_RB_50F, 05_LT_70F, 06_RT_70F, 07_LB_70F"));
				//_ftprintf_s(fp, _T(", 08_RB_70F, 09_L_IN, 10_T_IN, 11_R_IN, 12_B_IN, 13_L_OUT, 14_T_OUT, 15_R_OUT, 16_B_OUT"));
			}
			else if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_24P)
			{//67 LP만 저장
				_ftprintf_s(fp, _T(", CL_00F_V, CR_OOF_V, CT_00F_H, CB_00F_H, LT_04F_V"));
				_ftprintf_s(fp, _T(", LT_04F_H, RT_04F_V, RT_04F_H, RB_04F_V, RB_04F_H"));
				_ftprintf_s(fp, _T(", LB_04F_V, LB_04F_H, L_04F_V, L_04F_H, R_04F_V"));
				_ftprintf_s(fp, _T(", R_04F_H, LT_07F_V, LT_07F_H, RT_07F_V, RT_07F_H"));
				_ftprintf_s(fp, _T(", RB_07F_V, RB_07F_H, LB_07F_V, LB_07F_H"));
			}

			_ftprintf_s(fp, _T("\n"));

			fclose(fp);
		}
	}

	_tfopen_s(&fp, szFilePath, sFileMode);
	if (fp != NULL)
	{
		_ftprintf_s(fp, _T("%04d_%02d_%02d, '%02d:%02d:%02d, "), m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay, m_stInspTime.wHour, m_stInspTime.wMinute, m_stInspTime.wSecond);
		_ftprintf_s(fp, _T("%s, "), (TCHAR*)(LPCTSTR)m_sBarcodeID);

		_ftprintf_s(fp, _T("%.03lf, %.03lf, %.03lf"), m_dOCResult[0], m_dOCResult[1], m_dDistortion);

		if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_17P)
		{
			//! 화상검사기  60lp/mm ,  67lp/mm  위치(만도 AAB 추가)
			//for(i = 0; i < 17; i++)
			//	_ftprintf_s(fp, _T(", %.03lf"), m_d60lpmm[i]);

			for (i = 0; i < 17; i++)
				_ftprintf_s(fp, _T(", %.03lf"), m_d67lpmm[i]);

			//for(i = 0; i < 17; i++)
			//	_ftprintf_s(fp, _T(", %.03lf "), m_dMTF[i]);
		}
		else if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_24P)
		{
			for (i = 0; i < 24; i++)
				_ftprintf_s(fp, _T(", %.03lf"), m_d67lpmm[i]);
		}

		_ftprintf_s(fp, _T("\n"));
		fclose(fp);
	}
}

//-----------------------------------------------------------------------------
//
//	UV 후 로그 저장
//
//-----------------------------------------------------------------------------
void CMandoInspLog::SaveLogAfterUV(int nUnit)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szFilePath[SIZE_OF_1K];
	TCHAR szTemp[SIZE_OF_100BYTE];
	TCHAR szLog[SIZE_OF_1K];
	CFileFind clFinder;
	CFile clFile;
	CString sFileMode = _T("");
	FILE* fp;
	int i;

	// Log 폴더 만들기
	if (clFinder.FindFile(BASE_LOG_PATH) == FALSE)
		CreateDirectory(BASE_LOG_PATH, NULL);
	
	// 검사 로그 폴더 만들기
	if (clFinder.FindFile(BASE_INSP_PATH) == FALSE)
		CreateDirectory(BASE_INSP_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%04d%02d"), BASE_INSP_PATH, m_stInspTime.wYear,
		m_stInspTime.wMonth);
	// 검사 로그 폴더 만들기
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\%04d%02d\\%02d"), BASE_INSP_PATH, m_stInspTime.wYear,
		m_stInspTime.wMonth, m_stInspTime.wDay);
	
	// 검사 로그 폭더 만들기
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	if (g_clModelData[nUnit].m_nSFR_N_POS == 1)
		_stprintf_s(szTemp, SIZE_OF_100BYTE, _T("N2"));
	else
		_stprintf_s(szTemp, SIZE_OF_100BYTE, _T("N4"));

	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%04d%02d%02d_LOG-%dLineAA%d-UVAfter_%s.csv"),
		szPath, m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay, g_clSysData.m_nSysNo, nUnit+1, szTemp);

	if (clFinder.FindFile(szFilePath) == TRUE)
	{
		if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[ERROR] 파일이 사용중입니다."));
			AddLog(szLog, 1, nUnit);

			return;
		}
		else
		{
			clFile.Close();
		}
	}

#ifdef _UNICODE
	sFileMode = _T("a,ccs=UTF-8");
#else
	sFileMode = _T("a");
#endif

	// 파일이 없으면 헤더를 쓴다.
	if (clFinder.FindFile(szFilePath) == FALSE)
	{
		_tfopen_s(&fp, szFilePath, sFileMode);
		if (fp != NULL)
		{
			_ftprintf_s(fp, _T("date, time "));
			_ftprintf_s(fp, _T(", ID"));
			//_ftprintf_s(fp, _T(", PCB편차TX, PCB편차TY"));
			//_ftprintf_s(fp, _T(", PCB편차X, PCB편차Y, PCB편차T"));
			_ftprintf_s(fp, _T(", OK/NG, NGList"));
			_ftprintf_s(fp, _T(", current, 12C"));
			//_ftprintf_s(fp, _T(", 00_center, 01_LT_50F, 02_RT_50F, 03_LB_50F, 04_RB_50F, 05_LT_70F, 06_RT_70F, 07_LB_70F"));	//김영호
			//_ftprintf_s(fp, _T(", 08_RB_70F,	09_L_IN, 10_T_IN, 11_R_IN, 12_B_IN, 13_L_OUT, 14_T_OUT, 15_R_OUT, 16_B_OUT"));
			_ftprintf_s(fp, _T(", OC_X, OC_Y, Distortion, Defect_white, Defect_Black"));
			_ftprintf_s(fp, _T(", StainStep1, StainStep2, Shading_0.65F_C, Shading_0.65F_O, Shading_0.85F_C, Shading_0.85F_O"));

			if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_17P)
			{
				//! 화상검사기  60lp/mm ,  67lp/mm  위치(만도 AAB 추가)
				//_ftprintf_s(fp, _T(", 00_center_60lp, 01_LT_50F_60lp, 02_RT_50F_60lp, 03_LB_50F_60lp, 04_RB_50F_60lp, 05_LT_70F_60lp, 06_RT_70F_60lp, 07_LB_70F_60lp"));
				//_ftprintf_s(fp, _T(", 08_RB_70F_60lp, 09_L_IN_60lp, 10_T_IN_60lp, 11_R_IN_60lp, 12_B_IN_60lp, 13_L_OUT_60lp, 14_T_OUT_60lp, 15_R_OUT_60lp, 16_B_OUT_60lp"));

				_ftprintf_s(fp, _T(", 00_center_67lp, 01_LT_50F_67lp, 02_RT_50F_67lp, 03_LB_50F_67lp, 04_RB_50F_67lp, 05_LT_70F_67lp, 06_RT_70F_67lp, 07_LB_70F_67lp"));
				_ftprintf_s(fp, _T(", 08_RB_70F_67lp, 09_L_IN_67lp, 10_T_IN_67lp, 11_R_IN_67lp, 12_B_IN_67lp, 13_L_OUT_67lp, 14_T_OUT_67lp, 15_R_OUT_67lp, 16_B_OUT_67lp"));

				//_ftprintf_s(fp, _T(", 00_center, 01_LT_50F, 02_RT_50F, 03_LB_50F, 04_RB_50F, 05_LT_70F, 06_RT_70F, 07_LB_70F"));
				//_ftprintf_s(fp, _T(", 08_RB_70F, 09_L_IN, 10_T_IN, 11_R_IN, 12_B_IN, 13_L_OUT, 14_T_OUT, 15_R_OUT, 16_B_OUT"));
			}
			else if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_24P)
			{
				_ftprintf_s(fp, _T(", CL_00F_V, CR_OOF_V, CT_00F_H, CB_00F_H, LT_04F_V"));
				_ftprintf_s(fp, _T(", LT_04F_H, RT_04F_V, RT_04F_H, RB_04F_V, RB_04F_H"));
				_ftprintf_s(fp, _T(", LB_04F_V, LB_04F_H, L_04F_V, L_04F_H, R_04F_V"));
				_ftprintf_s(fp, _T(", R_04F_H, LT_07F_V, LT_07F_H, RT_07F_V, RT_07F_H"));
				_ftprintf_s(fp, _T(", RB_07F_V, RB_07F_H, LB_07F_V, LB_07F_H"));
			}

			_ftprintf_s(fp, _T("\n"));
			fclose(fp);
		}
	}

	_tfopen_s(&fp, szFilePath, sFileMode);
	if (fp != NULL)
	{
		_ftprintf_s(fp, _T("%04d_%02d_%02d, '%02d:%02d:%02d"), m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay, m_stInspTime.wHour, m_stInspTime.wMinute, m_stInspTime.wSecond);
		_ftprintf_s(fp, _T(", %s"), (TCHAR*)(LPCTSTR)m_sBarcodeID);
		//_ftprintf_s(fp, _T(", %.04lf, %.04lf", dTilteOffset[0], dTilteOffset[1]));
		//_ftprintf_s(fp, _T(", %.04lf, %.04lf, %.04lf", dPCBOffset[0], dPCBOffset[1], dPCBOffset[2]));

		if (m_bInspRes == true)		_ftprintf_s(fp, _T(", OK, %s"), (TCHAR*)(LPCTSTR)m_sNGList);
		else						_ftprintf_s(fp, _T(", NG, %s"), (TCHAR*)(LPCTSTR)m_sNGList);

		_ftprintf_s(fp, _T(", %.03lf, %s"), m_dCurrent, (TCHAR*)(LPCTSTR)m_sI2C);

		_ftprintf_s(fp, _T(", %.03lf, %.03lf, %.03lf, %.03lf, %.03lf"), m_dOCResult[0], m_dOCResult[1], m_dDistortion, m_dDefect[0], m_dDefect[1]);
		_ftprintf_s(fp, _T(", %.03lf, %.03lf, %.03lf, %.03lf, %.03lf, %.03lf"), m_dStain[0], m_dStain[1], m_dShading65FC[0], m_dShading65FC[1], m_dShading85FC[0], m_dShading85FC[1]);

		if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_17P)
		{
			//! 화상검사기  60lp/mm ,  67lp/mm  위치(만도 AAB 추가)
			//for(i = 0; i < 17; i++)
			//	_ftprintf_s(fp, _T(", %.03lf"), m_d60lpmm[i]);

			for (i = 0; i < 17; i++)
				_ftprintf_s(fp, _T(", %.03lf"), m_d67lpmm[i]);

			//for(i = 0; i < 17; i++)
			//	_ftprintf_s(fp, _T(", %.03lf"), m_dMTF[i]);
		}
		else if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_24P)
		{
			for (i = 0; i < 24; i++)
				_ftprintf_s(fp, _T(", %.03lf"), m_d67lpmm[i]);
		}

		_ftprintf_s(fp, _T("\n"));

		fclose(fp);
	}
}

//-----------------------------------------------------------------------------
//
//	Final 로그 저장
//
//-----------------------------------------------------------------------------
void CMandoInspLog::SaveLogUVAfterMin(int nUnit)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szFilePath[SIZE_OF_1K];
	TCHAR szLog[SIZE_OF_1K];
	TCHAR szTemp[SIZE_OF_100BYTE];
	CString sFileMode = _T("");
	CFileFind clFinder;
	CFile clFile;
	FILE* fp;
	int i;
	double dMin[11] = { 0, };

	_stprintf_s(szPath, SIZE_OF_1K, _T("D:\\LKAS"));
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("D:\\LKAS\\RESULT"));
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("D:\\LKAS\\RESULT\\FINALDATA"));
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("D:\\LKAS\\RESULT\\FINALDATA\\%04d%02d"), m_stInspTime.wYear, m_stInspTime.wMonth);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("D:\\LKAS\\RESULT\\FINALDATA\\%04d%02d\\%02d"), m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	if (g_clModelData[nUnit].m_nSFR_N_POS == 1)
		_stprintf_s(szTemp, SIZE_OF_100BYTE, _T("N2"));
	else
		_stprintf_s(szTemp, SIZE_OF_100BYTE, _T("N4"));

	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%04d%02d%02d_LOG-%dLineINSP-UVAfter_FINAL_%s.csv"),
		szPath, m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay, g_clSysData.m_nSysNo, szTemp);

	if (clFinder.FindFile(szFilePath) == TRUE)
	{
		if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[ERROR] 파일이 사용 중입니다."));
			AddLog(szLog, 1, nUnit);

			return;
		}
		else
		{
			clFile.Close();
		}
	}

#ifdef _UNICODE
	sFileMode = _T("a,ccs=UTF-8");
#else
	sFileMode = _T("a + t");
#endif

	if (clFinder.FindFile(szFilePath) == FALSE)
	{
		_tfopen_s(&fp, szFilePath, sFileMode);
		if (fp != NULL)
		{
			_ftprintf_s(fp, _T("date, time "));
			_ftprintf_s(fp, _T(", ID"));
			_ftprintf_s(fp, _T(", OK/NG, NGList"));
			_ftprintf_s(fp, _T(", current, 12C"));
			_ftprintf_s(fp, _T(", OC_X, OC_Y, Distortion, Defect_white, Defect_Black"));
			_ftprintf_s(fp, _T(", StainStep1, StainStep2, Shading_0.65F_C, Shading_0.65F_O, Shading_0.85F_C, Shading_0.85F_O"));

			if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_17P)
			{
				//! 화상검사기  60lp/mm ,  67lp/mm  위치(만도 AAB 추가)
				_ftprintf_s(fp, _T(", 00_center_67lp, 01_LT_50F_67lp, 02_RT_50F_67lp, 03_LB_50F_67lp, 04_RB_50F_67lp, 05_LT_70F_67lp, 06_RT_70F_67lp, 07_LB_70F_67lp"));
				_ftprintf_s(fp, _T(", 08_RB_70F_67lp, 09_L_IN_67lp, 10_T_IN_67lp, 11_R_IN_67lp, 12_B_IN_67lp, 13_L_OUT_67lp, 14_T_OUT_67lp, 15_R_OUT_67lp, 16_B_OUT_67lp"));
			}
			else if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_24P)
			{
				_ftprintf_s(fp, _T(", C_00F_MIN, LT_04F_MIN"));
				_ftprintf_s(fp, _T(", RT_04F_MIN, RB_04F_MIN"));
				_ftprintf_s(fp, _T(", LB_04F_MIN, L_04F_MIN, R_04F_MIN"));
				_ftprintf_s(fp, _T(", LT_07F_MIN, RT_07F_MIN"));
				_ftprintf_s(fp, _T(", RB_07F_MIN, LB_07F_MIN"));
			}

			_ftprintf_s(fp, _T("\n"));

			fclose(fp);
		}
	}

	_tfopen_s(&fp, szFilePath, sFileMode);
	if (fp != NULL)
	{
		_ftprintf_s(fp, _T("%04d_%02d_%02d, '%02d:%02d:%02d"), m_stInspTime.wYear, m_stInspTime.wMonth, m_stInspTime.wDay, m_stInspTime.wHour, m_stInspTime.wMinute, m_stInspTime.wSecond);
		_ftprintf_s(fp, _T(", %s"), (TCHAR*)(LPCTSTR)m_sBarcodeID);

		if (m_bInspRes == true)
			_ftprintf_s(fp, _T(", OK, %s"), (TCHAR*)(LPCTSTR)m_sNGList);
		else
			_ftprintf_s(fp, _T(", NG, %s"), (TCHAR*)(LPCTSTR)m_sNGList);

		_ftprintf_s(fp, _T(", %.03lf, %s"), m_dCurrent, (TCHAR*)(LPCTSTR)m_sI2C);

		_ftprintf_s(fp, _T(", %.03lf, %.03lf, %.03lf, %.03lf, %.03lf"), m_dOCResult[0], m_dOCResult[1], m_dDistortion, m_dDefect[0], m_dDefect[1]);
		_ftprintf_s(fp, _T(", %.03lf, %.03lf, %.03lf, %.03lf, %.03lf, %.03lf"), m_dStain[0], m_dStain[1], m_dShading65FC[0], m_dShading65FC[1], m_dShading85FC[0], m_dShading85FC[1]);

		if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_17P)
		{
			//! 화상검사기  60lp/mm ,  67lp/mm  위치(만도 AAB 추가)
			for (i = 0; i < 17; i++)
				_ftprintf_s(fp, _T(", %.03lf"), m_d67lpmm[i]);
		}
		else if (g_clModelData[nUnit].m_nMTF_FinalMode == MTF_24P)
		{
			for (i = 0; i < 4; i++)
			{
				if (i == 3)
					break;

				if (m_d67lpmm[i] < m_d67lpmm[i + 1])
					dMin[0] = m_d67lpmm[i];
				else
					dMin[0] = m_d67lpmm[i + 1];
			}

			if (m_d67lpmm[4] < m_d67lpmm[5])		dMin[1] = m_d67lpmm[4];
			else									dMin[1] = m_d67lpmm[5];

			if (m_d67lpmm[6] < m_d67lpmm[7])		dMin[2] = m_d67lpmm[6];
			else									dMin[2] = m_d67lpmm[7];

			if (m_d67lpmm[8] < m_d67lpmm[9])		dMin[3] = m_d67lpmm[8];
			else									dMin[3] = m_d67lpmm[9];

			if (m_d67lpmm[10] < m_d67lpmm[11])		dMin[4] = m_d67lpmm[10];
			else									dMin[4] = m_d67lpmm[11];

			if (m_d67lpmm[12] < m_d67lpmm[13])		dMin[5] = m_d67lpmm[12];
			else									dMin[5] = m_d67lpmm[13];

			if (m_d67lpmm[14] < m_d67lpmm[15])		dMin[6] = m_d67lpmm[14];
			else									dMin[6] = m_d67lpmm[15]; // 0.4f

			if (m_d67lpmm[16] < m_d67lpmm[17])		dMin[7] = m_d67lpmm[16];
			else									dMin[7] = m_d67lpmm[17];

			if (m_d67lpmm[18] < m_d67lpmm[19])		dMin[8] = m_d67lpmm[18];
			else									dMin[8] = m_d67lpmm[19];

			if (m_d67lpmm[20] < m_d67lpmm[21])		dMin[9] = m_d67lpmm[20];
			else									dMin[9] = m_d67lpmm[21];

			if (m_d67lpmm[22] < m_d67lpmm[23])		dMin[10] = m_d67lpmm[22];
			else									dMin[10] = m_d67lpmm[23]; // 0.7f

			for (i = 0; i < 11; i++)
				_ftprintf_s(fp, _T(", %.03lf"), dMin[i]);
		}

		fprintf_s(fp, "\n");

		fclose(fp);
	}

	m_dMinData[0] = dMin[0];

	if (m_d67lpmm[4] < m_d67lpmm[5])		m_dMinData[1] = m_d67lpmm[4];
	else									m_dMinData[1] = m_d67lpmm[5];
	if (m_d67lpmm[6] < m_d67lpmm[7])		m_dMinData[1] = m_d67lpmm[6];
	else									m_dMinData[1] = m_d67lpmm[7];
	if (m_d67lpmm[8] < m_d67lpmm[9])		m_dMinData[1] = m_d67lpmm[8];
	else									m_dMinData[1] = m_d67lpmm[9];
	if (m_d67lpmm[10] < m_d67lpmm[11])		m_dMinData[1] = m_d67lpmm[10];
	else									m_dMinData[1] = m_d67lpmm[11];
	if (m_d67lpmm[12] < m_d67lpmm[13])		m_dMinData[1] = m_d67lpmm[12];
	else									m_dMinData[1] = m_d67lpmm[13];
	if (m_d67lpmm[14] < m_d67lpmm[15])		m_dMinData[1] = m_d67lpmm[14];
	else									m_dMinData[1] = m_d67lpmm[15]; // 0.4f
	if (m_d67lpmm[16] < m_d67lpmm[17])		m_dMinData[2] = m_d67lpmm[16];
	else									m_dMinData[2] = m_d67lpmm[17];
	if (m_d67lpmm[18] < m_d67lpmm[19])		m_dMinData[2] = m_d67lpmm[18];
	else									m_dMinData[2] = m_d67lpmm[19];
	if (m_d67lpmm[20] < m_d67lpmm[21])		m_dMinData[2] = m_d67lpmm[20];
	else									m_dMinData[2] = m_d67lpmm[21];
	if (m_d67lpmm[22] < m_d67lpmm[23])		m_dMinData[2] = m_d67lpmm[22];
	else									m_dMinData[2] = m_d67lpmm[23]; // 0.7f
}



//-----------------------------------------------------------------------------
//
//	NG 오버레이 그리기
//
//-----------------------------------------------------------------------------
void CMandoInspLog::DrawNGOverlay(int nCh)
{
	int nGapY = 65;
	int nSX = 10;
	int nSY = 400;

	int nCurX, nCurY;
	nCurX = nSX;
	int nListNo = 0;
	int i;

	m_sSendNGName = _T("");

	if (m_nNGCnt > 19)
	{
		m_nNGCnt = 19;
	}

	if (nCh == 1)
	{
		g_clVision.DrawMOverlayText(nCh, nCurX, nCurY, (TCHAR*)(LPCTSTR)"Calibration Error" , M_COLOR_RED, _T("Arial"), 40, 10, FALSE);
		m_sSendNGName = _T(",ETC");
		return;
	}

	if (m_sBarcodeID == _T("BCR_READ_ERROR"))
	{
		nCurY = nSY + (nGapY * nListNo);
		g_clVision.DrawMOverlayText(nCh, nCurX, nCurY, (TCHAR*)(LPCTSTR)m_sBarcodeID, M_COLOR_RED, _T("Arial"), 40, 10, FALSE);
		m_sSendNGName = _T(",BCR");
		return;
	}

	for (i = 0; i < m_nNGCnt; i++)
	{
		nCurY = nSY + (nGapY * nListNo);

		if (nCurY >((CCD2_CAM_SIZE_Y/* - 4*/) - 80))
		{
			nListNo = 0;
			nCurY = nSY + (nGapY * nListNo);
			nCurX += CCD2_CAM_SIZE_X / 2-50;	//내용이 많을 경우 2줄로 표시 하기 위해
		}
		if(m_sSendNGName == _T("")) NGCheck(m_sDispNG[i]);
		g_clVision.DrawMOverlayText(nCh, nCurX, nCurY, (TCHAR*)(LPCTSTR)m_sDispNG[i], M_COLOR_RED, _T("Arial"), 40, 10, FALSE);
		nListNo++;
	}
}

void CMandoInspLog::NGCheck(CString strNg)
{
	if (strNg.Find(_T("[Defect")) > 0)
		m_sSendNGName = _T(",DEFECT");
	else if (strNg.Find(_T("OC")) > 0)
		m_sSendNGName = _T(",SFR");
	else if (strNg.Find(_T("[Defect")) > 0)
		m_sSendNGName = _T(",STAIN");
	//else if (strNg.Find(_T("[RI")) > 0)
	//	m_sSendNGName = _T("RI");
	else 
		m_sSendNGName = _T(",ETC");
}


//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
CMandoSfrSpec::CMandoSfrSpec()
{
	int i, j, k;

	for (i = 0; i < MAX_SFR_INSP_CNT; i++)
	{
		for (j = 0; j < 2; j++)
		{
			for (k = 0; k < 3; k++)
			{
				m_dAASFR_Spec[i][j][k] = 0.227;
			}
		}
	}

	for (i = 0; i< MAX_SFR_INSP_CNT; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			m_dINSPSFR_Spec[i][j] = 0.11;
		}
	}

	m_bInsp60Lp = false;
	m_bInsp67Lp = true;
	m_bInspCp = false;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
CMandoSfrSpec::~CMandoSfrSpec()
{

}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void CMandoSfrSpec::Load()
{
	TCHAR szIniBuff[SIZE_OF_1K];
	TCHAR szPath[SIZE_OF_1K];

	TCHAR* szIniIndex[] = { 
		_T("AA_CL_00F_V"), _T("AA_CR_00F_V"), _T("AA_CT_00F_H"), _T("AA_CB_00F_H"),
		_T("AA_LT_04F_V"),_T("AA_LT_04F_H"), _T("AA_RT_04F_V"), _T("AA_RT_04F_H"),
		_T("AA_LB_04F_V"), _T("AA_LB_04F_H"),_T("AA_RB_04F_V"),	_T("AA_RB_04F_H"),
		_T("AA_LT_08F_V"), _T("AA_LT_08F_H"), _T("AA_RT_08F_V"), _T("AA_RT_08F_H"),
		_T("AA_LB_08F_V"), _T("AA_LB_08F_H"),_T("AA_RB_08F_V"), _T("AA_RB_08F_H") };

	TCHAR* szIniAveIndex[] = {
		_T("AA_CENTER"),
		_T("AA_MID1"), _T("AA_MID2"), _T("AA_MID3"), _T("AA_MID4"),
		_T("AA_SIDE1"), _T("AA_SIDE2"), _T("AA_SIDE3"), _T("AA_SIDE4") };

	CString sToken = _T("");
	int i, j;

	if (m_nUnit == UNIT_AA1)	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\MandoSfrSpec_AA%d.ini"), BASE_DATA_PATH, m_nUnit + 1);
	else						_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\MandoSfrSpec_AA%d.ini"), BASE_DATA_PATH, m_nUnit + 1);

	for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
	{
		GetPrivateProfileString(_T("SFR_SPEC"), szIniIndex[i], _T(""), szIniBuff, sizeof(szIniBuff), szPath);
		if (_tcslen(szIniBuff) > 0)
		{
			for (j = 0; j < 6; j++)
			{
				AfxExtractSubString(sToken, szIniBuff, j, _T('/'));

				switch (j)
				{
				case 0:		m_dAASFR_Spec[i][0][0] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				case 1:		m_dAASFR_Spec[i][0][1] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				case 2:		m_dAASFR_Spec[i][0][2] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				case 3:		m_dAASFR_Spec[i][1][0] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				case 4:		m_dAASFR_Spec[i][1][1] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				case 5:		m_dAASFR_Spec[i][1][2] = _ttof((TCHAR*)(LPCTSTR)sToken);	break;
				}
			}
		}
	}
	for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
	{
		GetPrivateProfileString(_T("SFR_AVE_SPEC"), szIniAveIndex[i], _T("1.000"), szIniBuff, sizeof(szIniBuff), szPath);
		m_dAASFR_SumAveSpec[i] = _ttof((TCHAR*)(LPCTSTR)szIniBuff);
	}
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void CMandoSfrSpec::Save()
{
	TCHAR szData[SIZE_OF_1K];
	TCHAR szPath[SIZE_OF_1K];

	TCHAR* szIniIndex[] = { 
		_T("AA_CL_00F_V"), _T("AA_CR_00F_V"), _T("AA_CT_00F_H"), _T("AA_CB_00F_H"),
		_T("AA_LT_04F_V"),_T("AA_LT_04F_H"), _T("AA_RT_04F_V"), _T("AA_RT_04F_H"),
		_T("AA_LB_04F_V"), _T("AA_LB_04F_H"),_T("AA_RB_04F_V"),	_T("AA_RB_04F_H"),
		_T("AA_LT_08F_V"), _T("AA_LT_08F_H"), _T("AA_RT_08F_V"), _T("AA_RT_08F_H"),
		_T("AA_LB_08F_V"), _T("AA_LB_08F_H"),_T("AA_RB_08F_V"), _T("AA_RB_08F_H") };

	TCHAR* szIniAveIndex[] = {
		_T("AA_CENTER"), 
		_T("AA_MID1"), _T("AA_MID2"), _T("AA_MID3"), _T("AA_MID4"),
		_T("AA_SIDE1"), _T("AA_SIDE2"), _T("AA_SIDE3"), _T("AA_SIDE4") };

	int i;

	if (m_nUnit == UNIT_AA1)	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\MandoSfrSpec_AA%d.ini"), BASE_DATA_PATH, m_nUnit + 1);
	else						_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\MandoSfrSpec_AA%d.ini"), BASE_DATA_PATH, m_nUnit + 1);

	for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf / %.03lf / %.03lf / %.03lf / %.03lf / %.03lf"),
			m_dAASFR_Spec[i][0][0], m_dAASFR_Spec[i][0][1], m_dAASFR_Spec[i][0][2], m_dAASFR_Spec[i][1][0], m_dAASFR_Spec[i][1][1], m_dAASFR_Spec[i][1][2]);
		WritePrivateProfileString(_T("SFR_SPEC"), szIniIndex[i], szData, szPath);
	}

	for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
	{
		_stprintf_s(szData, SIZE_OF_1K, _T("%.03lf"), m_dAASFR_SumAveSpec[i]);
		WritePrivateProfileString(_T("SFR_AVE_SPEC"), szIniAveIndex[i], szData, szPath);
	}
}


//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
CMesCommunication::CMesCommunication()
{
	int i;

	m_sMesI2C.Format(_T("PASS"));
	m_nMesI2CResult = 1;


	m_dMesUVBeforeOC[0] = m_dMesUVBeforeOC[1] = 0.0;	//OC 결과.[X/Y]  UV 전
	m_dMesUVAfterOC[0] = m_dMesUVAfterOC[1] = 0.0;		//OC 결과.[X/Y]  UV 후



	m_dMesShading65FC[0] = m_dMesShading65FC[1] = m_dMesShading85FC[0] = m_dMesShading85FC[1] = 0.0;



	m_nMesUVBeforeOCResult = m_nMesUVAfterOCResult[0] = m_nMesUVAfterOCResult[1] = 0;

	m_nMesStainResult = 0;
	m_nMesDarkResult = 0;

	m_nMesShading65FCResult[0] = m_nMesShading65FCResult[1] = m_nMesShading85FCResult[0] = m_nMesShading85FCResult[1] = 0;


	m_nMesDark = 0;
	for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
	{
		m_dMesMTFUVAfter[i] = 0.0;
		m_dMesMTF67lp[i] = 0.0;			//MTF 검사 항목
		m_dMesMTF67lpUVAfter[i] = 0.0;
	}

	for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
	{
		m_nMesMTFResultUVAfter[i] = 0;
		m_nMesMTF67lpResult[i] = 0;
		m_nMesMTF67lpResultUVAfter[i] = 0;
	}

	//======================================================================================
	//======================================================================================
	//======================================================================================
	//new Mes 190921

	m_sMesLotID = _T("EMPTY");	// 바코드 아이디
	m_nMesCnt = 0;			// 차수
	m_nMesFinalResult = 0;	// 합부
	m_dMesCurrent = 0.0;
	//
	for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
	{
		m_dMesMTF[i] = 0.0;			//MTF 검사 항목
	}
	for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
	{
		m_nMesMTFResult[i] = 0;
	}

	m_dMesDistortion = 0.0;
	m_dMesSnr = 0.0;
	m_dMesDr = 0.0;
	m_dMesRotate = 0.0;


	m_nMesCurrentResult = 0;
	m_dMesRotateResult = 1;
	m_dMesSnrResult = 1;
	m_dMesDrResult = 1;
	m_nMesDistortionResult = 1;

	for (i = 0; i < 2; i++)
	{
		m_dMesOC[i] = 0.0;
		m_dMesDeltaOC[i] = 0.0;
		m_dMesOCResult[i] = 0;
		m_dMesDeltaOCResult[i] = 0;
	}

	for (i = 0; i < 3; i++)
	{
		m_dMesFov[i] = 0.0;
		m_dMesFovResult[i] = 1;
	}
	for (i = 0; i < 14; i++)//for (i = 0; i < 11; i++)
	{
		m_nMesDefect[i] = 0.0;
		m_nMesDefectResult[i] = 0;
	}
	for (i = 0; i < 6; i++)
	{
		m_nMesColorSensitivity[i] = 0.0;
		m_nMesColorSensitivityResult[i] = 1;
	}

	for (i = 0; i < 20; i++)
	{
		m_nMesRI[i] = 0.0;
		m_nMesRIResult[i] = 1;
	}
	for (i = 0; i < 4; i++)
	{
		m_nMesRICorner[i] = 0.0;
		m_nMesRIRICornerResult[i] = 1;
	}
	// m_nMesRICorner[i], m_nMesRIRICornerResult[i])

	for (i = 0; i < 12; i++)
	{
		m_nMesColorUniformity[i] = 0.0;
		m_nMesColorUniformityResult[i] = 1;
	}
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
CMesCommunication::~CMesCommunication()
{
	
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void CMesCommunication::Insp()
{
	
}


//------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------






void CMesCommunication::Save(int nUnit)
{
	SYSTEMTIME stSysTime;
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szLog[SIZE_OF_1K];
	CFileFind clFilder;
	CFile clFile;
	CString sFileMode = _T("");
	FILE* fp;
	int i;
	CString Title = _T("");
	GetLocalTime(&stSysTime);

	//_stprintf_s(szPath, SIZE_OF_1K, _T("C:\\BMS_MES"));


#if (____MODEL_NAME == TESLA_WIDE)
	if (m_sMesLotID.GetLength() == 0)
	{
		m_sMesLotID = "EMPTY";
	}
	_stprintf_s(szPath, SIZE_OF_1K, _T("W:\\%s.txt") , m_sMesLotID);
#elif (____MODEL_NAME == TESLA_MAIN_NARROW)
	if (nUnit == 1)		//1 = narrow
	{
		//_stprintf_s(szPath, SIZE_OF_1K, _T("Z:\\"));
		_stprintf_s(szPath, _T("Z:\\%s_%d_%04d%02d%02d%02d%02d%02d.txt"), g_clSysData.m_szFactoryCd, m_nMesCnt, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);
		//g_clSysData.m_szMesPath
	}
	else
	{
		_stprintf_s(szPath, SIZE_OF_1K, _T("MesTempMain.txt"));
	}
#endif



#ifdef _UNICODE
	sFileMode = _T("w,ccs=UTF-8");
#else
	sFileMode = _T("w");
#endif

	_tfopen_s(&fp, szPath, sFileMode);
	
	if (fp != NULL)
	{
#if  (____MODEL_NAME == TESLA_WIDE)
		_ftprintf_s(fp, _T("%s,"), m_sMesLotID);   // 바코드명
		_ftprintf_s(fp, _T("%d,"), m_nMesCnt);						// 차수
		_ftprintf_s(fp, _T("%d,"), m_nMesFinalResult);				// 최종합부
#elif (____MODEL_NAME == TESLA_MAIN_NARROW)

#endif
		
		
		_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesCurrent, m_nMesCurrentResult);  // 전류측정
		_ftprintf_s(fp, _T("%s:%d,"), (TCHAR*)(LPCTSTR)m_sMesI2C, m_nMesI2CResult); //

		for (i = 0; i < 14; i++)
			_ftprintf_s(fp, _T("%d:%d,"), m_nMesDefect[i], m_nMesDefectResult[i]);  // Defect 검사

		for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesMTF[i], m_nMesMTFResult[i]);  // MTF 검사

		for (i = 0; i < 2; i++)
		{
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesOC[i], m_dMesOCResult[i]);  // OC 검사
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesDeltaOC[i], m_dMesDeltaOCResult[i]);  // OC 검사
		}

		_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesDistortion, m_nMesDistortionResult); // Distortion 검사

		for (i = 0; i < 3; i++)
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_nMesBlemish[i], m_nMesBlemishResult[i]);  // Blemish 검사

		for (i = 0; i < 6; i++)
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_nMesColorSensitivity[i], m_nMesColorSensitivityResult[i]);  // ColorSensitivity 검사

		for (i = 0; i < 20; i++)
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_nMesRI[i], m_nMesRIResult[i]);  // RI 검사

		for (i = 0; i < 4; i++)
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_nMesRICorner[i], m_nMesRIRICornerResult[i]);  // RI Corner검사

		_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesSnr, m_dMesSnrResult);			// SNR 검사
		_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesDr, m_dMesDrResult);			// DR 검사

		for (i = 0; i < 12; i++)
			_ftprintf_s(fp, _T("%.03lf:%d,"), m_nMesColorUniformity[i], m_nMesColorUniformityResult[i]);  // ColorUniformity 검사
		
		for (i = 0; i < 3; i++)
		{
			if (i == (3 - 1))
			{
				_ftprintf_s(fp, _T("%.03lf:%d"), m_dMesFov[i], m_dMesFovResult[i]);  // FOV 검사
			}
			else
			{

				_ftprintf_s(fp, _T("%.03lf:%d,"), m_dMesFov[i], m_dMesFovResult[i]);  // FOV 검사
			}
		}
		if (nUnit == 1)
		{
			_ftprintf_s(fp, _T("\r\n"));  // FOV 검사
		}
		fclose(fp);
		Sleep(10);
	}

//
//	if (nUnit == 1)
//	{
//		return; 
//	}
//	int size = 0;
//	char *buffer;
//	FILE *fpr;// = fopen(szPath, "r");
//	CString tempData;
//	sFileMode = _T("r");
//	
//	tempData.Empty();
//	m_sendData.Empty();
//#if  (____MODEL_NAME == TESLA_MAIN_NARROW)
//	m_sendData += m_getData;//Main 일때만 wide data 앞에 붙여서 narrow한테 보내면된다.
//#endif
//	
//	m_getData.Empty();
//	//
//	_tfopen_s(&fpr, szPath, sFileMode);
//	if (clFilder.FindFile(szPath) == FALSE)
//	{
//		_stprintf_s(szLog, SIZE_OF_1K, _T("[mes] file open fail!"));
//		AddLog(szLog, 1, nUnit);
//		return;
//	}
//	if (fpr != NULL)
//	{
//		fseek(fp, 0, SEEK_END);					// 파일 포인터를 파일의 끝으로 이동시킴
//		size = ftell(fp);						// 파일 포인터의 현재 위치를 얻음
//		buffer = (char*)malloc(size + 1);		// 파일 크기 + 1바이트(문자열 마지막의 NULL)만큼 동적 메모리 할당
//		memset(buffer, 0, size + 1);			// 파일 크기 + 1바이트만큼 메모리를 0으로 초기화
//		fseek(fp, 0, SEEK_SET);                 // 파일 포인터를 파일의 처음으로 이동시킴
//		fread(buffer, size, 1, fp);				// hello.txt에서 파일 크기만큼 값을 읽음
//		m_sendData.Format("%s", buffer);
//		//m_sendData += tempData;
//	}
//	fclose(fpr);
}


//3+ ;//
//2+11+5+2+1+3+6+20+4+2+12+3 = 75-4  
//2+11+9+2+1+3+6+20+4+2+12+3 = 89-11
//2+11+9+2+1+3+6+20+4+2+12+3 = 89-11
bool CMesCommunication::newSave(int nUnit)
{
	SYSTEMTIME stSysTime;
	CString strLine = _T("");
	CString loadData = _T("");
	strLine.Format("ddd %d", 0);
	CStdioFile StdFile;
	CFileException e;
	TCHAR tempPath[SIZE_OF_1K];
	TCHAR mesPath[SIZE_OF_1K];
	TCHAR loadPath[SIZE_OF_1K];
	TCHAR szLog[SIZE_OF_1K];
	GetLocalTime(&stSysTime);
	if (m_sMesLotID.GetLength() == 0)
	{
		m_sMesLotID = "EMPTY";
	}

	TCHAR szPath[SIZE_OF_1K];
	SYSTEMTIME time;
	::GetLocalTime(&time);

	FILE *out;

	CFileFind finder;
	BOOL IsFind;
	CString FolderName;

	FolderName.Format("%s\\%04d%02d\\%02d", MES_TEMP_BASE_DIR, time.wYear, time.wMonth, time.wDay);
	IsFind = finder.FindFile(FolderName);
	if (!IsFind)
	{
		FolderName.Format("%s\\%04d%02d", MES_TEMP_BASE_DIR, time.wYear, time.wMonth);
		IsFind = finder.FindFile(FolderName);
		if (!IsFind)
		{
			CreateDirectory(FolderName, NULL);
		}

		FolderName.Format("%s\\%04d%02d\\%02d", MES_TEMP_BASE_DIR, time.wYear, time.wMonth, time.wDay);
		CreateDirectory(FolderName, NULL);
	}

	finder.Close();
	
	int i = 0;
	//_stprintf_s(szPath, SIZE_OF_1K, _T("C:\\BMS_MES"));
#if (____MODEL_NAME == TESLA_WIDE)
	_stprintf_s(tempPath, SIZE_OF_1K, _T("%s\\%s_wide.txt"), FolderName, m_sMesLotID);
	if (StdFile.Open(tempPath, CStdioFile::modeCreate | CFile::modeReadWrite))
	{
#elif (____MODEL_NAME == TESLA_MAIN_NARROW)
	//------------------------------------------------------------------------------------------------------------------------------------------
	//
	//
	//이전 모델 data Load
	//
	//------------------------------------------------------------------------------------------------------------------------------------------
	if (nUnit == 0)
	{
		_stprintf_s(loadPath, SIZE_OF_1K, _T("%s\\%s_wide.txt"), FolderName, m_sMesLotID);//main 은 wide load
		_stprintf_s(tempPath, SIZE_OF_1K, _T("%s\\%s_main.txt"), FolderName, m_sMesLotID);//main 저장 파일
	}
	else
	{
		_stprintf_s(loadPath, SIZE_OF_1K, _T("%s\\%s_main.txt"), FolderName, m_sMesLotID);//narrow 는 main load
		_stprintf_s(tempPath, SIZE_OF_1K, _T("%s\\%s_narrow.txt"), FolderName, m_sMesLotID);//main 저장 파일
	}
	loadData.Empty();
	if (!StdFile.Open(loadPath, CStdioFile::modeRead))
	{
		return false;
	}
	else
	{
		StdFile.ReadString(loadData);
		StdFile.Close();
	}
	_stprintf_s(szLog, SIZE_OF_1K, _T("[MES] data load Complete!"));
	AddLog(szLog, 1, nUnit);
	//------------------------------------------------------------------------------------------------------------------------------------------
	//
	//if (StdFile.Open(tempPath, CStdioFile::modeCreate | CStdioFile::modeNoTruncate | CFile::modeReadWrite))
	if (StdFile.Open(tempPath, CStdioFile::modeCreate | CFile::modeReadWrite))
	{
		if (nUnit == 0)
		{
			StdFile.WriteString(loadData);//wide data 저장
		}
		else if(nUnit == 1)
		{
			strLine.Format("%s,", m_sMesLotID);				// 바코드명
			StdFile.WriteString(strLine);
			strLine.Format("%d,", m_nMesCnt);					// 차수
			StdFile.WriteString(strLine);
			strLine.Format("%d", m_nMesFinalResult);			// 최종합부
			StdFile.WriteString(strLine);
			//
			StdFile.WriteString(loadData);			//wide , main data 저장
		}
#endif
							 
		strLine.Format(_T(",%.03lf:%d,"), m_dMesCurrent, m_nMesCurrentResult);  // 전류측정
		StdFile.WriteString(strLine);
		strLine.Format(_T("%s:%d,"), (TCHAR*)(LPCTSTR)m_sMesI2C, m_nMesI2CResult); //
		StdFile.WriteString(strLine);

		//
		for (i = 0; i < 14; i++)
		{
			strLine.Format(_T("%d:%d,"), m_nMesDefect[i], m_nMesDefectResult[i]);// Defect 검사
			StdFile.WriteString(strLine);
		}
		for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
		{
			strLine.Format(_T("%.03lf:%d,"), m_dMesMTF[i], m_nMesMTFResult[i]);// MTF 검사
			StdFile.WriteString(strLine);

		}
		for (i = 0; i < 2; i++)
		{
			strLine.Format(_T("%.03lf:%d,"), m_dMesOC[i], m_dMesOCResult[i]);// OC 검사
			StdFile.WriteString(strLine);
			strLine.Format(_T("%.03lf:%d,"), m_dMesDeltaOC[i], m_dMesDeltaOCResult[i]);
			StdFile.WriteString(strLine);
		}
		strLine.Format(_T("%.03lf:%d,"), m_dMesDistortion, m_nMesDistortionResult); // Distortion 검사
		StdFile.WriteString(strLine);
		for (i = 0; i < 3; i++) {
			strLine.Format(_T("%.03lf:%d,"), m_nMesBlemish[i], m_nMesBlemishResult[i]);// Blemish 검사
			StdFile.WriteString(strLine);
		}
		for (i = 0; i < 6; i++) {
			strLine.Format(_T("%.03lf:%d,"), m_nMesColorSensitivity[i], m_nMesColorSensitivityResult[i]);// ColorSensitivity 검사
			StdFile.WriteString(strLine);
		}

		for (i = 0; i < 20; i++) {
			strLine.Format(_T("%.03lf:%d,"), m_nMesRI[i], m_nMesRIResult[i]); // RI 검사
			StdFile.WriteString(strLine);
		}

		for (i = 0; i < 4; i++) {
			strLine.Format(_T("%.03lf:%d,"), m_nMesRICorner[i], m_nMesRIRICornerResult[i]); // RI Corner검사
			StdFile.WriteString(strLine);
		}

		strLine.Format(_T("%.03lf:%d,"), m_dMesSnr, m_dMesSnrResult); // SNR 검사
		StdFile.WriteString(strLine);
		strLine.Format(_T("%.03lf:%d,"), m_dMesDr, m_dMesDrResult); // DR 검사
		StdFile.WriteString(strLine);
		for (i = 0; i < 12; i++) {
			strLine.Format(_T("%.03lf:%d,"), m_nMesColorUniformity[i], m_nMesColorUniformityResult[i]); // ColorUniformity 검사
			StdFile.WriteString(strLine);
		}

		for (i = 0; i < 3; i++)
		{
			if (i == 3 - 1)
			{
				strLine.Format(_T("%.03lf:%d"), m_dMesFov[i], m_dMesFovResult[i]);  // FOV 검사
			}
			else
			{

				strLine.Format(_T("%.03lf:%d,"), m_dMesFov[i], m_dMesFovResult[i]);  // FOV 검사
			}
			StdFile.WriteString(strLine);
		}
		if (nUnit == 1)
		{
			strLine.Format(_T("\r\n"));
			StdFile.WriteString(strLine);
		}
		Sleep(10);
		StdFile.Close();
		if (nUnit == 1)
		{
			_stprintf_s(mesPath, _T("Z:\\%s_%d_%04d%02d%02d%02d%02d%02d.txt"), g_clSysData.m_szFactoryCd, m_nMesCnt, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);
			CopyFile(tempPath, mesPath, FALSE);
		}

	}
	else
	{
		
		_stprintf_s(szLog, SIZE_OF_1K, _T("[MES] %s, 파일이 없습니다 확인바랍니다."), tempPath);
		AddLog(szLog, 1, nUnit);
		return false;
	}
	return true;

}


