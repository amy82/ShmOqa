#include "StdAfx.h"
#include "PRIFunc_Insp.h"
#include "../../GlobalDeclare.h"



#define R_RESULT_PASS							0	//양품 
#define R_RESULT_FAIL							1	//불량
#define R_FAIL_NOISE							2
#define R_FAIL_BLACK_SPOT						3
#define R_FAIL_STAIN							4

using namespace ACMISSoftISP;

typedef struct __TShadingSpec
{
	TRelativeUniformitySpec  m_stRelativeUniformitySpec;
	TColorSensitivitySpecN m_stColorSensitivitySpec;
	TRelativeIlluminationSpecX m_stRelativeIlluminationXSpec;
	TRelativeIlluminationSpecN m_stRelativeIlluminationNSpec;
} TShadingSpec;


CPRIFunc_Insp::CPRIFunc_Insp(void)
{
	cTestPat_Ref_buf = NULL;
	imagePattern = cvCreateImage(cvSize(g_clModelData[m_nUnit].m_nWidth, g_clModelData[m_nUnit].m_nHeight), IPL_DEPTH_8U, 3);
}


CPRIFunc_Insp::~CPRIFunc_Insp(void)
{
	cvReleaseImage(&imagePattern);
}
///-------------------------------------------------------------------------------------
///-------------------------------------------------------------------------------------
//
///-------------------------------------------------------------------------------------
bool CPRIFunc_Insp::func_EEprom_Write(bool bAutoMode)
{
	CString sLog = _T("");
	CString strData = _T("");
	CString _addr = _T("");
	CString wData = _T("");
	unsigned char szTemp[MAX_PATH];
	char szData[MAX_PATH];
	unsigned int nAddress;
	double dData = 0.0;
	unsigned int checkSumTemp = 0;
	int startCheckSum = 0;
	int endCheckSum = 0;
	int totlaCount = 0;
	int errorCode = 0;
	int wLength = 0;
	int leng = 0;
	int i = 0;
	int j = 0;
	int k = 0;

	byte APIData[MAX_PATH];
	byte rtnHexData[MAX_PATH];
	byte *totalData = new byte[2000];
	memset(rtnHexData, 0x00, sizeof(rtnHexData));
	memset(APIData, 0x00, sizeof(APIData));

	memset(totalData, 0x00, sizeof(byte) * 2000);
	CTime cTime = CTime::GetCurrentTime();
	//-------------------------------------------------------
	//
	//CAMERA_HEADER 0 ~ 7
	//8
	//-------------------------------------------------------
	_addr = _T("0x0000");
	APIData[0] = 0x0B;
	APIData[1] = 0x10;
	APIData[2] = 0xF4;
	APIData[3] = 0xEF;
	APIData[4] = 0xE5;
	APIData[5] = 0x62;
	APIData[6] = 0x39;
	APIData[7] = 0x16;

	wLength = 8;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_MAP 0 ~ 1
	//2
	//-------------------------------------------------------
	_addr = _T("0x0000");
	APIData[0] = 0x00;
	APIData[1] = 0x07;
	wLength = 2;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;

	//-------------------------------------------------------
	//
	//FLAG 0 ~ 1
	//2
	//-------------------------------------------------------
	_addr = _T("0x0000");
	APIData[0] = 0x00;
	APIData[1] = 0x00;
	wLength = 2;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//CAM_LOCATION 0 ~ 1
	//2
	//-------------------------------------------------------
	_addr = _T("0x0000");
	APIData[0] = 0x00;
	if (g_clModelData[0].m_nModelType == 0)	//모델별 설정해줘라
	{
		APIData[1] = 0x38;//Repeater Left
	}
	else
	{
		APIData[1] = 0x39;//Repeater Right
	}

	wLength = 2;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//MANUFACTURER_NAME 0 ~ 7
	//8
	//-------------------------------------------------------
	APIData[0] = 0x20;
	APIData[1] = 0x20;
	APIData[2] = 0x20;
	APIData[3] = 0x20;
	APIData[4] = 0x4C;
	APIData[5] = 0x47;
	APIData[6] = 0x49;
	APIData[7] = 0x54;
	wLength = 8;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//고정값 Part Number
	//MANUFACTURER_PN 0 ~ 15
	//16
	//-------------------------------------------------------
	//ACS01S002R - Model S/X RH
	//ACS01S001R - Model S/X LH
	_addr = _T("0x0016");
	if (g_clModelData[0].m_nModelType == 0)	//모델별 설정해줘라
	{
		wData.Format("%s", "ACS01S001L");// S/X LH
	}
	else
	{
		wData.Format("%s", "ACS01S002R");// S/X RH

	}

	wLength = 16;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, ASCII_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//바코드 찍은 값 Serial Number
	//MANUFACTURER_SN 0 ~ 15
	//16
	//-------------------------------------------------------
	_addr = _T("0x0026");
	wData.Format("%s", g_clTaskWork[m_nUnit].m_szChipID);
	wLength = 16;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, ASCII_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_YEAR 0 ~ 1
	//2
	//-------------------------------------------------------
	//upper
	_addr = _T("0x0036");
	wData.Format("%d", cTime.GetYear());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, ASCII_MODE_2, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//
	//lower
	_addr = _T("0x0037");
	memcpy(totalData + totlaCount, rtnHexData + wLength, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_MONTH 
	//1
	//-------------------------------------------------------
	_addr = _T("0x0038");
	wData.Format("%d", cTime.GetMonth());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_DAY 
	//1
	//-------------------------------------------------------
	_addr = _T("0x0039");
	wData.Format("%d", cTime.GetDay());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_HOUR 
	//1
	//-------------------------------------------------------
	_addr = _T("0x003A");
	wData.Format("%d", cTime.GetHour());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_MINUTE 
	//1
	//-------------------------------------------------------
	_addr = _T("0x003B");
	wData.Format("%d", cTime.GetMinute());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_SECOND 
	//1
	//-------------------------------------------------------
	_addr = _T("0x003C");
	wData.Format("%d", cTime.GetSecond());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//UTC_CENTISECONDS 
	//1
	//-------------------------------------------------------
	_addr = _T("0x003D");
	wData.Format("%d", cTime.GetSecond() / 10);
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;





	//-------------------------------------------------------
	//
	//ORIGIN_NAME 0 ~  11
	//12
	//-------------------------------------------------------
	_addr = _T("0x003E");
	APIData[0] = 0x20;
	APIData[1] = 0x20;
	APIData[2] = 0x20;
	APIData[3] = 0x20;
	APIData[4] = 0x20;
	APIData[5] = 0x47; //( G )
	APIData[6] = 0x57; //( W )
	APIData[7] = 0x41; //( A )
	APIData[8] = 0x4E; //( N )
	APIData[9] = 0x47; //( G )
	APIData[10] = 0x4A; //( J )
	APIData[11] = 0x55; //( U )

	wLength = 12;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//ASSEMBLY_LINE 0 ~  7
	//8
	//-------------------------------------------------------
	_addr = _T("0x004A");
	APIData[0] = 0x20;
	APIData[1] = 0x20;
	APIData[2] = 0x20;
	APIData[3] = 0x20;
	APIData[4] = 0x20;
	APIData[5] = 0x20;
	APIData[6] = 0x47; //( G )
	APIData[7] = 0x32; //( 2 )
	wLength = 8;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_0
	//1
	//-------------------------------------------------------
	_addr = _T("0x0052");
	startCheckSum = 0;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i <= endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;	//0 ~ 51더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//ASSEMBLY_ID 0 ~ 31
	//32
	//-------------------------------------------------------
	_addr = _T("0x0053");		//현재는 사용 안함 Ox00기록
	wLength = 32;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_1
	//1
	//-------------------------------------------------------
	_addr = _T("0x0073");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//53 ~ 72더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//OPTICAL_CENTER_X 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0074");
	wData.Format("%0.3lf", g_clMandoInspLog[m_nUnit].m_LogOC_DelatX);
	wLength = 4;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, FLOAT_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//OPTICAL_CENTER_Y 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0078");
	wData.Format("%0.3lf", g_clMandoInspLog[m_nUnit].m_LogOC_DelatY);
	wLength = 4;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, FLOAT_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//LENS_ROLL 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x007C");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//LENS_PITCH 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0080");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//LENS_YAW 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0084");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//LENS_DX 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0088");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//LENS_DY 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x008C");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//LENS_DZ 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0090");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//SENSOR_DX 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0094");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//SENSOR_DY 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0098");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//SENSOR_DZ 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x009C");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_K1 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00A0");
	APIData[0] = 0xBD;
	APIData[1] = 0x73;
	APIData[2] = 0x57;
	APIData[3] = 0xE6;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_K2 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00A4");
	APIData[0] = 0xBC;
	APIData[1] = 0x8F;
	APIData[2] = 0x71;
	APIData[3] = 0x22;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_K3 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00A8");
	APIData[0] = 0xBB;
	APIData[1] = 0x64;
	APIData[2] = 0xFB;
	APIData[3] = 0x98;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_K4 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00AC");
	APIData[0] = 0x3A;
	APIData[1] = 0xCB;
	APIData[2] = 0xD1;
	APIData[3] = 0x24;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_K5 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00B0");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_P1 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00B4");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DIST_P2 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00B8");		//현재는 사용 안함 Ox00기록
	wLength = 4;
	memset(APIData, 0x00, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//CFA 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x00BC");
	APIData[0] = 0x43;
	APIData[1] = 0x52;
	APIData[2] = 0x42;
	APIData[3] = 0x43;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_2 
	//1
	//-------------------------------------------------------
	_addr = _T("0x00C0");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//74 ~ BF더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//LENS_NAME 0 ~ 15
	//16
	//-------------------------------------------------------
	_addr = _T("0x00C1");
	APIData[0] = 0x20;
	APIData[1] = 0x20;
	APIData[2] = 0x20;
	APIData[3] = 0x4C;// (L)
	APIData[4] = 0x41;// (A)
	APIData[5] = 0x52;// (R)
	APIData[6] = 0x47;// (G)
	APIData[7] = 0x41;// (A)
	APIData[8] = 0x4E;// (N)
	APIData[9] = 0x20;
	APIData[10] = 0x39;// (9)
	APIData[11] = 0x38;// (8)
	APIData[12] = 0x30;// (0)
	APIData[13] = 0x32;// (2)
	APIData[14] = 0x41;// (A)
	APIData[15] = 0x38;// (8)
	wLength = 16;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//SERIALIZER_NAME 0 ~ 15
	//16
	//-------------------------------------------------------
	_addr = _T("0x00D1");
	APIData[0] = 0x20;
	APIData[1] = 0x41;// (A)
	APIData[2] = 0x50;// (P)
	APIData[3] = 0x54;// (T)
	APIData[4] = 0x49;// (I)
	APIData[5] = 0x4E;// (N)
	APIData[6] = 0x41;// (A)
	APIData[7] = 0x20;//
	APIData[8] = 0x41;// (A)
	APIData[9] = 0x52;// (R)
	APIData[10] = 0x30;// (0)
	APIData[11] = 0x31;// (1)
	APIData[12] = 0x33;// (3)
	APIData[13] = 0x36;// (6)
	APIData[14] = 0x41;// (A)
	APIData[15] = 0x54;// (T)
	wLength = 16;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//SENSOR_NAME 0 ~ 15
	//16
	//-------------------------------------------------------
	_addr = _T("0x00E1");
	APIData[0] = 0x20;
	APIData[1] = 0x20;
	APIData[2] = 0x20;
	APIData[3] = 0x54; // (T)
	APIData[4] = 0x49; // (I)
	APIData[5] = 0x20; //
	APIData[6] = 0x44; // (D)
	APIData[7] = 0x53; // (S)
	APIData[8] = 0x39; // (9)
	APIData[9] = 0x30; // (0)
	APIData[10] = 0x55;// (U)
	APIData[11] = 0x42;// (B)
	APIData[12] = 0x39;// (9)
	APIData[13] = 0x31;// (1)
	APIData[14] = 0x33;// (3)
	APIData[15] = 0x41;// (A)
	wLength = 16;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_3 
	//1
	//-------------------------------------------------------
	_addr = _T("0x00F1");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//C1 ~ F0더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//TESLA_PART_NUMBER 0 ~ 12
	//13
	//-------------------------------------------------------
	_addr = _T("0x00F2");
	if (g_clModelData[0].m_nModelType == 0)	//모델별 설정해줘라
	{
		wData.Format("%s", "1495864-00-A");// S/X LH- Model S/X
	}
	else
	{
		wData.Format("%s", "1495865-00-A");// S/X RH - Model S/X

	}
	//모델 추가예정
	//1495866-00-A* (LH-Model3)
	//1495867-00-A* (RH-Model3)
	//
	wLength = 13;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, ASCII_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_4 
	//1
	//-------------------------------------------------------
	_addr = _T("0x00FF");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//F2 ~ FE 더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//DISTORTION_MODEL 
	//1
	//-------------------------------------------------------
	_addr = _T("0x0100");
	APIData[0] = 0x01;
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DISTORTION_FOCAL_LENGTH 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0101");
	APIData[0] = 0x40;
	APIData[1] = 0x71;
	APIData[2] = 0x68;
	APIData[3] = 0x73;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//IMGR_INPUT_CLK_FREQ 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0105");
	APIData[0] = 0x4B;
	APIData[1] = 0xBC;
	APIData[2] = 0xD3;
	APIData[3] = 0xD8;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATED_BY 0 ~ 15  (엑셀에서 15두개적혀있음 ? )
	//16
	//-------------------------------------------------------
	_addr = _T("0x0109");
	APIData[0] = 0x20;
	APIData[1] = 0x20;
	APIData[2] = 0x20;
	APIData[3] = 0x20;
	APIData[4] = 0x20;
	APIData[5] = 0x20;
	APIData[6] = 0x20;
	APIData[7] = 0x20;
	APIData[8] = 0x20;
	APIData[9] = 0x20;
	APIData[10] = 0x20;
	APIData[11] = 0x20;
	APIData[12] = 0x4C;//(L)
	APIData[13] = 0x47;//(G)
	APIData[14] = 0x49;//(I)
	APIData[15] = 0x54;//(T)
	wLength = 16;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATE_UTC_YEAR 0 ~ 1
	//2
	//-------------------------------------------------------
	_addr = _T("0x0119");
	wData.Format("%d", cTime.GetYear());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, ASCII_MODE_2, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//
	//lower
	_addr = _T("0x011A");
	memcpy(totalData + totlaCount, rtnHexData + wLength, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATE_UTC_MONTH
	//1
	//-------------------------------------------------------
	_addr = _T("0x011B");
	wData.Format("%d", cTime.GetMonth());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATE_UTC_DAY
	//1
	//-------------------------------------------------------
	_addr = _T("0x011C");
	wData.Format("%d", cTime.GetDay());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATE_UTC_HOUR
	//1
	//-------------------------------------------------------
	_addr = _T("0x011D");
	wData.Format("%d", cTime.GetHour());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATE_UTC_MINUTE
	//1
	//-------------------------------------------------------
	_addr = _T("0x011E");
	wData.Format("%d", cTime.GetMinute());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//EEPROM_LAST_UPDATE_UTC_SECOND
	//1
	//-------------------------------------------------------
	_addr = _T("0x011F");
	wData.Format("%d", cTime.GetSecond());
	wLength = 1;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, DEC_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_5
	//1
	//-------------------------------------------------------
	_addr = _T("0x0120");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//100 ~ 11F 더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//DISTORTION_CENTER_X 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0121");
	APIData[0] = 0xFF;
	APIData[1] = 0xFF;
	APIData[2] = 0xFF;
	APIData[3] = 0xFF;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//DISTORTION_CENTER_Y 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0125");
	APIData[0] = 0xFF;
	APIData[1] = 0xFF;
	APIData[2] = 0xFF;
	APIData[3] = 0xFF;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//CHART_CENTER_X 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0129");
	APIData[0] = 0x00;
	APIData[1] = 0x00;
	APIData[2] = 0x00;
	APIData[3] = 0x00;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//CHART_CENTER_Y 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x012D");
	APIData[0] = 0x00;
	APIData[1] = 0x00;
	APIData[2] = 0x00;
	APIData[3] = 0x00;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_6
	//1
	//-------------------------------------------------------
	_addr = _T("0x0131");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//121 ~ 130 더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//R/G_2800K 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0132");
	APIData[0] = 0x00;
	APIData[1] = 0x00;
	APIData[2] = 0x00;
	APIData[3] = 0x00;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//B/G_2800K 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0136");
	APIData[0] = 0x00;
	APIData[1] = 0x00;
	APIData[2] = 0x00;
	APIData[3] = 0x00;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//GR/GB_2800K 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x013A");
	APIData[0] = 0x00;
	APIData[1] = 0x00;
	APIData[2] = 0x00;
	APIData[3] = 0x00;
	wLength = 4;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//R/G_6500K 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x013E");
	/*
	"CACMISShadingColorSensitivity 알고리즘 결과(GetInspectionResult()) 중
	tAdjustColorRatio.RG"
	*/
	wData.Format("%0.3lf", g_clMandoInspLog[m_nUnit].m_Log_CS_RG_6500K);
	wLength = 4;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, FLOAT_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//B/G_6500K 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0142");
	/*
	"CACMISShadingColorSensitivity 알고리즘 결과(GetInspectionResult()) 중
	tAdjustColorRatio.BG"
	*/
	wData.Format("%0.3lf", g_clMandoInspLog[m_nUnit].m_Log_CS_BG_6500K);
	wLength = 4;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, FLOAT_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//GR/GB_6500K 0 ~ 3
	//4
	//-------------------------------------------------------
	_addr = _T("0x0146");
	/*
	"CACMISShadingColorSensitivity 알고리즘 결과(GetInspectionResult()) 중
	tAdjustColorRatio.GrGb"
	*/
	wData.Format("%0.3lf", g_clMandoInspLog[m_nUnit].m_Log_CS_GrGb_6500K);
	wLength = 4;
	eeprom_Data_Sum(wData.GetBuffer(0), wLength, FLOAT_MODE, rtnHexData, true);
	memcpy(totalData + totlaCount, rtnHexData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM_7
	//1
	//-------------------------------------------------------
	_addr = _T("0x014A");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//132 ~ 049 더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//--------------------------------------------------------------------------------200개
	//
	//LSC_RED_0_0_6500_0
	//LSC_RED_0_0_6500_1
	//0_0 ~ 9_9
	//200
	//-------------------------------------------------------
	_addr = _T("0x014B");
	wLength = 200;
	memset(APIData, 0xFF, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//--------------------------------------------------------------------------------200개
	//
	//LSC_GREENR_0_0_6500_0				 = R
	//LSC_GREENR_0_0_6500_1
	//0_0 ~ 9_9
	//200
	//-------------------------------------------------------
	_addr = _T("0x0213");
	wLength = 200;
	memset(APIData, 0xFF, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//--------------------------------------------------------------------------------200개
	//
	//LSC_GREENB_0_0_6500_0				 = B
	//LSC_GREENB_0_0_6500_1
	//0_0 ~ 9_9
	//200
	//-------------------------------------------------------
	_addr = _T("0x02DB");
	wLength = 200;
	memset(APIData, 0xFF, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//--------------------------------------------------------------------------------200개
	//
	//LSC_BLUE_0_0_6500_0
	//LSC_BLUE_0_0_6500_1
	//0_0 ~ 9_9
	//200
	//-------------------------------------------------------
	_addr = _T("0x03A3");
	wLength = 200;
	memset(APIData, 0xFF, wLength);
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM _8
	//1
	//-------------------------------------------------------
	_addr = _T("0x046B");
	startCheckSum = endCheckSum + 1;
	endCheckSum = totlaCount;
	for (i = startCheckSum; i < endCheckSum; i++)
	{
		checkSumTemp += totalData[i];
	}
	APIData[0] = checkSumTemp % 255;//148 ~ 46A 더해서 % 255
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	checkSumTemp = 0;
	//-------------------------------------------------------
	//
	//SMT ICT CHECK FLAG
	//1
	//SMT ICT check flag   "0x1" ICT Pass, "0x0" ICT Fail, "0xF" NOT checked
	//-------------------------------------------------------
	_addr = _T("0x046C");
	APIData[0] = 0x01;//양품으로 기록
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//---------------------------------------------------------------★
	//
	//CHECKSUM _9
	//1
	//-------------------------------------------------------
	_addr = _T("0x046D");
	APIData[0] = 0x01;
	wLength = 1;
	memcpy(totalData + totlaCount, APIData, wLength);
	totlaCount += wLength;
	//-------------------------------------------------------
	//
	//END
	//
	//-------------------------------------------------------

	Sleep(100);
	int writingByteNum = 32;
	for (i = 0; i < totlaCount; i += writingByteNum)//totlaCount = 1134
	{
		Sleep(1);
		if ((totlaCount - i) < 32)
		{
			writingByteNum = (totlaCount - i);
		}
		errorCode = g_clLaonGrabberWrapper[m_nUnit].m_pBoard->WriteI2CBurst((unsigned short)0x50, (unsigned short)0x0000 + i, 2, totalData + i, (unsigned short)writingByteNum);
		if (errorCode)return false;
		Sleep(10);
	}
	//수동검사시에만 가능하게 
	if (bAutoMode == false)//eeprom dump 남기기 excel
	{

		CFileFind clFinder;
		CString sFileMode = _T("");
		CFile clFile;
		FILE* fp;
		TCHAR szPath[SIZE_OF_1K];
		TCHAR szFilePath[SIZE_OF_1K];
		SYSTEMTIME stSysTime;
		::GetLocalTime(&stSysTime);
		_stprintf_s(szFilePath, SIZE_OF_1K, _T("eepromDump_%04d%02d%02d.csv"), stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);

		if (clFinder.FindFile(szFilePath) == TRUE)
		{
			if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
			{
				AddLog(_T("파일이 사용 중 입니다."), 1, 0);
				return false;
			}
			else
			{
				clFile.Close();
			}
		}


		sFileMode = _T("w");

		// 파일이 없으면 헤더를 만든다.
		if (clFinder.FindFile(szFilePath) == FALSE)
		{
			_tfopen_s(&fp, szFilePath, sFileMode);
			if (fp != NULL)
			{
				_ftprintf_s(fp, _T("Address(Dec),	Address(Hex),	Data(Dec),	Data(Hex),"));
				_ftprintf_s(fp, _T("\n"));
				fclose(fp);
			}
		}

		sFileMode = _T("a");
		_tfopen_s(&fp, szFilePath, sFileMode);
		if (fp != NULL)
		{
			for (i = 0; i < totlaCount; i++)
			{
				_ftprintf_s(fp, _T("%d, %02X, %d, %02X,"), i, i, totalData[i], totalData[i]);
				_ftprintf_s(fp, _T("\n"));
			}


			fclose(fp);
		}


	}
	return true;
}

///-------------------------------------------------------------------------------------
//
///-------------------------------------------------------------------------------------
bool CPRIFunc_Insp::func_EEprom_FuseID(bool bAutoMode)
{
	/*CString sLog = _T("");
	CString strData = _T("");
	CString _addr = _T("");
	CString wData = _T("");
	unsigned char szTemp[MAX_PATH];
	char szData[MAX_PATH];
	unsigned int nAddress;
	double dData = 0.0;
	int totlaCount = 0;
	int errorCode = 0;
	int wLength = 0;
	int leng = 0;
	int i = 0;
	int j = 0;
	int k = 0;

	byte rtnHexData[MAX_PATH];
	byte *totalData = new byte[2000];
	memset(rtnHexData, 0x00, sizeof(rtnHexData));

	memset(totalData, 0x00, sizeof(byte) * 2000);
	CTime cTime = CTime::GetCurrentTime();*/

	int writingByteNum;

	if (!g_clLaonGrabberWrapper[m_nUnit].m_pBoard->SetWPDisable())
	{
		AddLog(_T("[eeprom] Write Disable fail!!!!!"), 1, m_nUnit);
		return false;
	}
	else {
		AddLog(_T("[eeprom] Write Disable Success"), 1, m_nUnit);
	}

	CString m_strSlaveAddr, m_strAddr;
	CString m_strRegData;
	unsigned int nSlaveAddress;
	unsigned int nAddress;
	unsigned char pData[1025];
	int errorCode = 0;
	byte m_cAddrLength;
	DWORD m_cRegDataLength;

	nSlaveAddress = 0X10;
	nAddress = 0X301A;
	m_cAddrLength = 2;
	m_cRegDataLength = 2;

	sscanf_s(m_strSlaveAddr.GetBuffer(0), "%x", &nSlaveAddress);
	sscanf_s(m_strAddr.GetBuffer(0), "%x", &nAddress);

	errorCode = g_clLaonGrabberWrapper[m_nUnit].m_pBoard->ReadI2CBurst((unsigned short)nSlaveAddress, (unsigned short)nAddress, m_cAddrLength, pData, (unsigned short)m_cRegDataLength);

	if (errorCode)
	{
		m_strRegData.Format("READ Error : %d", errorCode);
		m_strRegData.AppendFormat(" %s", g_clLaonGrabberWrapper[m_nUnit].GetErrorStr(errorCode));
		return false;
	}
	else
	{
		m_strRegData = "";
		for (int i = 0; i < (int)m_cRegDataLength; i++)
		{
			m_strRegData.AppendFormat("%02X ", pData[i]);
		}
	}

	if (m_strRegData == "0x10DC")
	{
		errorCode = g_clLaonGrabberWrapper[m_nUnit].m_pBoard->ReadI2CBurst((unsigned short)nSlaveAddress, (unsigned short)nAddress, m_cAddrLength, pData, (unsigned short)m_cRegDataLength);

		if (errorCode)
		{
			m_strRegData.Format("0x10FC WRITE Error : %d", errorCode);
			m_strRegData.AppendFormat(" %s", g_clLaonGrabberWrapper[m_nUnit].GetErrorStr(errorCode));
			return false;
		}
		else
		{
		}

	}


	return true;

}

///-------------------------------------------------------------------------------------
///-------------------------------------------------------------------------------------
//
///-------------------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_Fov_Distortion_Rotate(BYTE* img, int _TYPE, bool bAutoMode)
{
	TCHAR szPos[SIZE_OF_100BYTE];

	int nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[m_nUnit][1], M_PITCH, M_NULL);
	int nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[m_nUnit][1], M_SIZE_X, M_NULL);
	int nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[m_nUnit][1], M_SIZE_Y, M_NULL);

	if (g_FindCirclePos(m_nUnit, g_clVision.m_pImgBuff[m_nUnit][1], nPitch, nSizeX, nSizeY, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectCircle) == false)
		return false;

	g_CalcImageAlign(m_nUnit);
	//
	CRect FovRectTemp[MAX_FOV_COUNT];
	//CRect m_clRectFov[MAX_FOV_COUNT];
	//FovRectTemp = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectFov;
	memcpy(FovRectTemp, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectFov, sizeof(FovRectTemp));

	if (_TYPE == DOT_TYPE)
	{
		//광각일때는 원형마크
		//원형마크 찾기
	}
	else 
	{
		if (g_FindFovPos(m_nUnit, g_clVision.m_pImgBuff[m_nUnit][1], nPitch, nSizeX, nSizeY, FovRectTemp) == false)
		{
			AddLog(_T("[수동검사] Fov Find 실패"), 1, m_nUnit);
			g_clVision.DrawOverlayAll(m_nUnit);
			return false;
		}
	}
	g_clVision.DrawOverlayAll(m_nUnit);

    bool bRes = true;
    int nBlackLevel = 0;
    TCHAR szLog[SIZE_OF_1K];
    CString sLog;
	
    int nWidth = g_clModelData[m_nUnit].m_nWidth;
    int nHeight = g_clModelData[m_nUnit].m_nHeight;
    TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;

    std::vector<BYTE> vBmpBuffer(nWidth * nHeight * 3, 0);
    IplImage *cvImg = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
    cvImg->imageData = (char*)vBmpBuffer.data();

	ACMISSoftISP::xMakeBMP(img, vBmpBuffer.data(), nWidth, nHeight, tDataSpec);

    //ACMISSoftISP::xMakeBMP((BYTE*)pBuffer, vBmpBuffer.data(), nWidth, nHeight, tDataSpec);

    //RECT rtFiducial[4] = { { 477, 50, 527, 100 },{ 1114, 50, 1164, 100 },{ 475, 1152, 525, 1202 },{ 1111, 1154, 1161, 1204 } };

    //g_clModelData[nUnit].m_clSfrInfo.m_clRectCircle
    int specCount = 0;
    TFiducialMarkInfoN tFiducialMarkInfo;
	//TFiducialMarkInfoN tFiducialMarkInfo;
    //
    //-----ui로 빼야할 항목

    //DOT_TYPE = 0, GRID_TYPE

    //tFiducialMarkInfo.dDistanceXFromCenter = 220;//Default 고정 // 장비에서 추출한 Fiducial Mark 와 Center 와의 차이 입력
    //tFiducialMarkInfo.dDistanceYFromCenter = 160;//Default 고정 // 장비에서 추출한 Fiducial Mark 와 Center 와의 차이 입력
    ////
    //
    //
    //광각만 distortion 검사때 fov마크
    //협각은 fov , distortion 둘다 fov마크
    //FIDUCIALMARKTYPE_DOT = 0
    //FIDUCIALMARKTYPE_GRID = 2
    //specCount++;//지우면 안됨
	tFiducialMarkInfo.pszChartType = NULL;

	tFiducialMarkInfo.dDistanceXFromCenter = 0.0;
	tFiducialMarkInfo.dDistanceYFromCenter = 0.0;
	//
	tFiducialMarkInfo.nROIBoxSize = 10;// 50;				//장비에서 추출한 Fiducial Mark 의ROI 사이즈 입력
	tFiducialMarkInfo.nMaxROIBoxSize = 100;			//장비에서 추출한 Fiducial Mark 의ROI 사이즈 입력
	tFiducialMarkInfo.dRadius = 0.7;

	tFiducialMarkInfo.dRealSubGapX = 1.0;
	tFiducialMarkInfo.dRealSubGapY = 1.0;
	
	tFiducialMarkInfo.nDistortionAlrotithmType = 2;//(int)g_clModelData[m_nUnit].m_ChartSpec[specCount++];//2;	//EDistortionAlgorithmType 참조

	tFiducialMarkInfo.dBinaryThreshold = 70.0;
	tFiducialMarkInfo.dMaxDeviation = 50.0;
	tFiducialMarkInfo.dPixelSize = 3.75;
	tFiducialMarkInfo.dEFL = 0.0;

	tFiducialMarkInfo.nFiducialMarkType = _TYPE;

    // if (tFiducialMarkInfo.nFiducialMarkType == FIDUCIALMARKTYPE_GRID)   //FIDUCIALMARKTYPE_DOT , FIDUCIALMARKTYPE_GRID
    bool bFindAlign = false;
	bool bFindAlign2 = false;
    std::shared_ptr<CACMISFiducialMark> m_pChartProc = std::make_shared<CACMISFiducialMark>();
	std::shared_ptr<CACMISFiducialMark> m_pChartProc2 = std::make_shared<CACMISFiducialMark>();

	//bFindAlign = m_pChartProc->SetFiducialMarkSpec(&tFiducialMarkInfo, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectCircle, nWidth, nHeight);
    if (_TYPE == GRID_TYPE)
    {
		
        tFiducialMarkInfo.nFiducialMarkNum = 9;
		tFiducialMarkInfo.dRealGapX = g_clModelData[m_nUnit].m_ChartSpec[specCount++];//23.514;			// chart 입수 후 Fiducial Mark 간거리(cm) 측정 후 입력
		tFiducialMarkInfo.dRealGapY = g_clModelData[m_nUnit].m_ChartSpec[specCount++];//20.47;			// chart 입수 후 Fiducial Mark 간거리(cm) 측정 후 입력
		tFiducialMarkInfo.dModuleChartDistance = g_clModelData[m_nUnit].m_ChartSpec[specCount++];//2.0;	// 장비와 모듈 간의 거리 값 입력
		bFindAlign = m_pChartProc->SetFiducialMarkSpec(&tFiducialMarkInfo, g_clTaskWork[m_nUnit].m_FindFovRect, nWidth, nHeight);

		tFiducialMarkInfo.dRealGapX = 1.0;// g_clModelData[m_nUnit].m_ChartSpec[specCount++];//23.514;			// chart 입수 후 Fiducial Mark 간거리(cm) 측정 후 입력
		tFiducialMarkInfo.dRealGapY = 1.0;// g_clModelData[m_nUnit].m_ChartSpec[specCount++];//20.47;			// chart 입수 후 Fiducial Mark 간거리(cm) 측정 후 입력
		tFiducialMarkInfo.dModuleChartDistance = 1;
		bFindAlign2 = m_pChartProc2->SetFiducialMarkSpec(&tFiducialMarkInfo, g_clTaskWork[m_nUnit].m_FindFovRect, nWidth, nHeight);
    }
    else
    {
        tFiducialMarkInfo.nFiducialMarkNum = 4;
		//tFiducialMarkInfo.nFiducialMarkType = 0;// (int)g_clModelData[m_nUnit].m_ChartSpec[specCount++];//0;		//원형마크수 4 or 9
		tFiducialMarkInfo.dModuleChartDistance = 1;// g_clModelData[m_nUnit].m_ChartSpec[specCount++];//2.0;	// 장비와 모듈 간의 거리 값 입력
        tFiducialMarkInfo.pszChartType = NULL; //원형마크 = "DOT" , fov마크 = "GRID"
        //bFindAlign = m_pChartProc->SetFiducialMarkSpec(&tFiducialMarkInfo, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectCircle, nWidth, nHeight);

		tFiducialMarkInfo.dRealGapX = 1.0;// g_clModelData[m_nUnit].m_ChartSpec[specCount++];//23.514;			// chart 입수 후 Fiducial Mark 간거리(cm) 측정 후 입력
		tFiducialMarkInfo.dRealGapY = 1.0;// g_clModelData[m_nUnit].m_ChartSpec[specCount++];//20.47;			// chart 입수 후 Fiducial Mark 간거리(cm) 측정 후 입력

		bFindAlign = m_pChartProc->SetFiducialMarkSpec(&tFiducialMarkInfo, g_clTaskWork[m_nUnit].m_FindCircleRect, nWidth, nHeight);
		//bFindAlign = m_pChartProc->SetFiducialMarkSpec(&tFiducialMarkInfo, g_clTaskWork[m_nUnit].m_clPtCircle, nWidth, nHeight);
    }


    //


    //3,4,5 좌표는 0으로
    double dfov = 0.0;
    double hfov = 0.0;
    double vfov = 0.0;

    double rotation = 0.0;
    double distortion = 0.0;


	if (_TYPE == GRID_TYPE)
	{
		if (bFindAlign)
		{
			m_pChartProc->CalcDFOV(nWidth, nHeight);

			dfov = m_pChartProc->GetDFOV();
			hfov = m_pChartProc->GetHFOV();
			vfov = m_pChartProc->GetVFOV();

			g_clMandoInspLog[m_nUnit].m_Log_FOV_H_FOV = hfov;
			g_clMandoInspLog[m_nUnit].m_Log_FOV_V_FOV = vfov;
			g_clMandoInspLog[m_nUnit].m_Log_FOV_D_FOV = dfov;

			g_clMesCommunication[m_nUnit].m_dMesFov[0] = g_clMandoInspLog[m_nUnit].m_Log_FOV_H_FOV;
			g_clMesCommunication[m_nUnit].m_dMesFov[1] = g_clMandoInspLog[m_nUnit].m_Log_FOV_V_FOV;
			g_clMesCommunication[m_nUnit].m_dMesFov[2] = g_clMandoInspLog[m_nUnit].m_Log_FOV_D_FOV;
		}
		else
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("Can't find FOV fiducial mark!"));

			AddLog(szLog, 0, m_nUnit);
		}

		if (bFindAlign2)
		{
			m_pChartProc2->CalcDistortion();
			distortion = m_pChartProc2->GetDistortion();
		}
		else
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("Can't find Distortion fiducial mark!"));

			AddLog(szLog, 0, m_nUnit);
		}
	}
	else
	{
		if (bFindAlign)
		{
			m_pChartProc->CalcTiltAndRotation(nWidth, nHeight);
			CxDPoint ptTilt = m_pChartProc->GetTilt();
			rotation = m_pChartProc->GetRotation();
			g_clMandoInspLog[m_nUnit].m_Log_Rotate = rotation;
			g_clMesCommunication[m_nUnit].m_dMesRotate = g_clMandoInspLog[m_nUnit].m_Log_Rotate;

			for (int j = 0; j < m_pChartProc->GetMaxFiducialMarkCount(); j++)
			{
				const CxDRect& pt = m_pChartProc->GetFiducialMarkROI(j);
				cvRectangle(cvImg, cvPoint((int)pt.left, (int)pt.top), cvPoint((int)pt.right, (int)pt.bottom), CV_BLUE, 1);

				//printf("(%d) : [Fiducial Mark] Left(%d), Top(%d), Right(%d), Bototom(%d)\n", j, (int)pt.left, (int)pt.top, (int)pt.right, (int)pt.bottom);
				//_stprintf_s(szLog, SIZE_OF_1K, _T("(%d) : [Fiducial Mark] Left(%d), Top(%d), Right(%d), Bototom(%d)\n", j, (int)pt.left, (int)pt.top, (int)pt.right, (int)pt.bottom));
				//AddLog(szLog, 0, m_nUnit);
			}

		}
		else
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("Can't find Rotation fiducial mark!"));

			AddLog(szLog, 0, m_nUnit);
		}

	}

  //  if (bFindAlign)
  //  {
  //      m_pChartProc->CalcTiltAndRotation(nWidth, nHeight);
  //      m_pChartProc->CalcDistortion();
  //      m_pChartProc->CalcDFOV(nWidth, nHeight);

  //      dfov = m_pChartProc->GetDFOV();
  //      hfov = m_pChartProc->GetHFOV();
  //      vfov = m_pChartProc->GetVFOV();

  //      CxDPoint ptTilt = m_pChartProc->GetTilt();
  //      rotation = m_pChartProc->GetRotation();
  //      distortion = m_pChartProc->GetDistortion();

  //      g_clMandoInspLog[m_nUnit].m_Log_FOV_H_FOV = hfov;
  //      g_clMandoInspLog[m_nUnit].m_Log_FOV_V_FOV = vfov;
  //      g_clMandoInspLog[m_nUnit].m_Log_FOV_D_FOV = dfov;
  //      g_clMandoInspLog[m_nUnit].m_Log_Rotate = rotation;

		//g_clMesCommunication[m_nUnit].m_dMesFov[0] = g_clMandoInspLog[m_nUnit].m_Log_FOV_H_FOV;
		//g_clMesCommunication[m_nUnit].m_dMesFov[1] = g_clMandoInspLog[m_nUnit].m_Log_FOV_V_FOV;
		//g_clMesCommunication[m_nUnit].m_dMesFov[2] = g_clMandoInspLog[m_nUnit].m_Log_FOV_D_FOV;
		//g_clMesCommunication[m_nUnit].m_dMesRotate = g_clMandoInspLog[m_nUnit].m_Log_Rotate;

  //      for (int j = 0; j < m_pChartProc->GetMaxFiducialMarkCount(); j++)
  //      {
  //          const CxDRect& pt = m_pChartProc->GetFiducialMarkROI(j);
  //          cvRectangle(cvImg, cvPoint((int)pt.left, (int)pt.top), cvPoint((int)pt.right, (int)pt.bottom), CV_BLUE, 1);

  //          //printf("(%d) : [Fiducial Mark] Left(%d), Top(%d), Right(%d), Bototom(%d)\n", j, (int)pt.left, (int)pt.top, (int)pt.right, (int)pt.bottom);
  //          //_stprintf_s(szLog, SIZE_OF_1K, _T("(%d) : [Fiducial Mark] Left(%d), Top(%d), Right(%d), Bototom(%d)\n", j, (int)pt.left, (int)pt.top, (int)pt.right, (int)pt.bottom));
  //           //AddLog(szLog, 0, m_nUnit);
  //      }
  //  }
  //  else
  //  {
  //      //printf("Can't find fiducial mark!\n");
  //      _stprintf_s(szLog, SIZE_OF_1K, _T("Can't find FOV fiducial mark!"));

  //      AddLog(szLog, 0, m_nUnit);
  //  }

    cvLine(cvImg, cvPoint(0, nHeight / 2 - 1), cvPoint(nWidth - 1, nHeight / 2 - 1), CV_GREEN, 1);
    cvLine(cvImg, cvPoint(nWidth / 2 - 1, 0), cvPoint(nWidth / 2 - 1, nHeight - 1), CV_GREEN, 1);

    const CxDPoint& ptCenter = m_pChartProc->GetRealCenter();
    cvLine(cvImg, cvPoint(0, (int)(ptCenter.y)), cvPoint(nWidth - 1, (int)(ptCenter.y)), CV_LAVENDER, 1);
    cvLine(cvImg, cvPoint((int)(ptCenter.x), 0), cvPoint((int)(ptCenter.x), nHeight - 1), CV_LAVENDER, 1);

	if (_TYPE == GRID_TYPE)
	{
		const CxDPoint& ptCenter2 = m_pChartProc2->GetRealCenter();
		cvLine(cvImg, cvPoint(0, (int)(ptCenter2.y)), cvPoint(nWidth - 1, (int)(ptCenter2.y)), CV_YELLOW, 1);
		cvLine(cvImg, cvPoint((int)(ptCenter2.x), 0), cvPoint((int)(ptCenter2.x), nHeight - 1), CV_YELLOW, 1);
	}

    CvFont cvfont;
    CvPoint pt;
    int scale = (nWidth > 640 ? 1 : 2);
    double nFontSize = 0.5 / scale;
    char strTmp[1024];
	CString sChatName;
    cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);


    // Display Result Tilt	
    //const CxDPoint& ptTilt = m_pChartProc->GetTilt();

    //sprintf_s(strTmp, "TILT %.3f,%.3f", ptTilt.x, ptTilt.y);
 //   sLog.Format(_T("[CCD] TILT %.3f,%.3f"), ptTilt.x, ptTilt.y);
 //   AddLog(sLog, 0, m_nUnit);
    pt.x = 60;
    pt.y = 20;

    //if (m_pChartProc->InSpecTiltX() && m_pChartProc->InSpecTiltY())
    //	cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
    //else
    //	cvPutText(cvImg, strTmp, pt, &cvfont, CV_RED);

    //// Display Rotation
    //pt.y += 20;
    //sprintf_s(strTmp, "ROTATION %.3f", rotation);
    ////_stprintf_s(szLog, SIZE_OF_1K, _T("[CCD] ROTATION %.3f"), rotation);
    //sLog.Format(_T("[CCD] ROTATION %.3f"), rotation);
    //AddLog(sLog, 0, m_nUnit);
    //if (m_pChartProc->InSpecRotation())
    //	cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
    //else
    //	cvPutText(cvImg, strTmp, pt, &cvfont, CV_RED); 

#if  (____MODEL_NAME == TESLA_WIDE)
    if (_TYPE == DOT_TYPE)
    {
        pt.y += 20;
        sprintf_s(strTmp, "DFOV %.3f(%.3f, %.3f)", dfov, hfov, vfov);
        sLog.Format(_T("[CCD] DFOV %.3f(%.3f, %.3f)"), dfov, hfov, vfov);
        AddLog(sLog, 0, m_nUnit);
        if (m_pChartProc->InSpecDFOV())
            cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
        else
            cvPutText(cvImg, strTmp, pt, &cvfont, CV_RED);
    }
#elif  (____MODEL_NAME == TESLA_MAIN_NARROW)
    // Display DFOV
#endif
   
	
	if (_TYPE == GRID_TYPE)
	{
		sChatName = _T("FOV_DISTORTION");
		pt.y += 20;
		sprintf_s(strTmp, "DFOV %.3f(%.3f, %.3f)", dfov, hfov, vfov);
		sLog.Format(_T("[CCD] DFOV %.3f(%.3f, %.3f)"), dfov, hfov, vfov);
		AddLog(sLog, 0, m_nUnit);
		if (m_pChartProc->InSpecDFOV())
			cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
		else
			cvPutText(cvImg, strTmp, pt, &cvfont, CV_RED);

		// Display Distortion
		pt.y += 20;
		sprintf_s(strTmp, "Distortion %.3f", distortion);
		sLog.Format(_T("[CCD] Distortion %.3f"), distortion);
		g_clMandoInspLog[m_nUnit].m_LogDistortion = distortion;

		g_clMesCommunication[m_nUnit].m_dMesDistortion = g_clMandoInspLog[m_nUnit].m_LogDistortion;

		AddLog(sLog, 0, m_nUnit);
		if (m_pChartProc->InSpecDistortion())
			cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
		else
			cvPutText(cvImg, strTmp, pt, &cvfont, CV_RED);
	}
	else
	{
		sChatName = _T("ROTATE");
		pt.y += 20;
		sprintf_s(strTmp, "ROTATE : %.3f", rotation);
		sLog.Format(_T("[CCD] ROTATE : %.3f"), rotation);
		AddLog(sLog, 0, m_nUnit);
		if (m_pChartProc->InSpecRotation())
			cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
		else
			cvPutText(cvImg, strTmp, pt, &cvfont, CV_RED);
	}
	g_SaveLGITLog(m_nUnit, sChatName, m_pChartProc->GetLogHeader(), m_pChartProc->GetLogData());
	//cvShowImage(sChatName, cvImg);
	//cvWaitKey(0);
	cvReleaseImage(&cvImg);

    
	return bRes; 
}


//-----------------------------------------------------------------------------
//
//	R/C,B/C,Cr/Cb 검사(ColorSensitivity)
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_ColorSensitivity(BYTE* _____img, int index, bool bAutoMode)	//R/C,B/C,Cr/Cb
{
	bool bRes = true;
	int i = 0;
    TCHAR	szLog[SIZE_OF_1K];
	int nBlackLevel = 0;
    int nWidth = g_clModelData[m_nUnit].m_nWidth;
    int nHeight = g_clModelData[m_nUnit].m_nHeight;
    TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;
    IplImage *cvImgRI = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
    cvImgRI = g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.imageItp;

    int specCount = 0;
	TColorSensitivitySpecN m_stColorSensitivitySpec;
	RECT rtRoi;
	double dOffset[3] = { 0.0, 0.0, 0.0 }; // RGOffset, BGOffset, GrGbOffset
	SetRect(&rtRoi, 856, 432, 965, 507);
	SetRect(&rtRoi, 512, 384, 768, 579);

	g_clVision.DrawMOverlayBox(0, rtRoi, M_COLOR_BLUE, 1, FALSE, PS_DOT);
	g_clVision.DrawOverlayAll(0);
	//cvRectangle(cvImgRI, cvPoint(rtRoi.left, rtRoi.top), cvPoint(rtRoi.right, rtRoi.bottom), CV_RGB(0, 0, 255));

	m_stColorSensitivitySpec.tROI.eROIType = ROIType_RECT;
	m_stColorSensitivitySpec.tROI.ROICount = 1;
	m_stColorSensitivitySpec.tROI.dOffset = dOffset;
	m_stColorSensitivitySpec.tROI.pROIData = &rtRoi;
	m_stColorSensitivitySpec.dSpecDevMaxRG = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];//1.000000;
    m_stColorSensitivitySpec.dSpecDevMinRG = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];//1.000000;
    m_stColorSensitivitySpec.dSpecDevMaxBG = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];//1.000000;
    m_stColorSensitivitySpec.dSpecDevMinBG = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];//1.000000;
    m_stColorSensitivitySpec.dSpecDevMaxGrGb = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];//1.000000;
    m_stColorSensitivitySpec.dSpecDevMinGrGb = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];//1.000000;
    m_stColorSensitivitySpec.nAdjustType = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];// 0;
    m_stColorSensitivitySpec.nTypicalValueType = g_clModelData[m_nUnit].m_ColorSensitivitySpec[specCount++];// 0;
    std::shared_ptr<CACMISShadingColorSensitivity> m_pColorSensitivity = std::make_shared<CACMISShadingColorSensitivity>();

    if (index == MID_6500K_RAW)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] 6500K Image Insp"));
        
    }
    else if (index == MID_5000k_RAW)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] 5000k Image Insp"));
    }
    else
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] Manusl Insp"));
        //Manual Insp
    }
    AddLog(szLog, 0, m_nUnit);
    //std::cout << "[Color Sensitivity] Version = " << m_pColorSensitivity->GetVersion() << std::endl;
    _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] Version = %s"), m_pColorSensitivity->GetVersion());
    AddLog(szLog, 0, m_nUnit);

	bool result = m_pColorSensitivity->Inspect(_____img,
        nWidth, nHeight,
        m_stColorSensitivitySpec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType,
		nBlackLevel);
	//
    //Result
    int nResult = R_RESULT_PASS;
    std::vector<TColorSensitivityResult> m_stColorSensitivityResult;
    for (i = 0; i < m_stColorSensitivitySpec.tROI.ROICount; i++)
    {
        m_stColorSensitivityResult.push_back(*m_pColorSensitivity->GetInspectionResult(i));

        // Check Color Sensitivity RG
        if ((m_stColorSensitivitySpec.dSpecDevMinRG > m_stColorSensitivityResult[i].tAdjustColorRatio.RG) || (m_stColorSensitivitySpec.dSpecDevMaxRG < m_stColorSensitivityResult[i].tAdjustColorRatio.RG))
            nResult = R_RESULT_FAIL;
        // Check Color Sensitivity BG
        if ((m_stColorSensitivitySpec.dSpecDevMinBG > m_stColorSensitivityResult[i].tAdjustColorRatio.BG) || (m_stColorSensitivitySpec.dSpecDevMaxBG < m_stColorSensitivityResult[i].tAdjustColorRatio.BG))
            nResult = R_RESULT_FAIL;
        // Check Color Sensitivity GrGb
        if ((m_stColorSensitivitySpec.dSpecDevMinGrGb > m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb) || (m_stColorSensitivitySpec.dSpecDevMaxGrGb < m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb))
            nResult = R_RESULT_FAIL;
        if (index == MID_6500K_RAW)
        {
            g_clMandoInspLog[m_nUnit].m_Log_CS_RG_6500K = m_stColorSensitivityResult[i].tAdjustColorRatio.RG;
            g_clMandoInspLog[m_nUnit].m_Log_CS_BG_6500K = m_stColorSensitivityResult[i].tAdjustColorRatio.BG;
            g_clMandoInspLog[m_nUnit].m_Log_CS_GrGb_6500K = m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb;

			g_clMesCommunication[m_nUnit].m_nMesColorSensitivity[0] = g_clMandoInspLog[m_nUnit].m_Log_CS_RG_6500K;
			g_clMesCommunication[m_nUnit].m_nMesColorSensitivity[1] = g_clMandoInspLog[m_nUnit].m_Log_CS_BG_6500K;
			g_clMesCommunication[m_nUnit].m_nMesColorSensitivity[2] = g_clMandoInspLog[m_nUnit].m_Log_CS_GrGb_6500K;
        }
        else
        {
            g_clMandoInspLog[m_nUnit].m_Log_CS_RC_5000k = m_stColorSensitivityResult[i].tAdjustColorRatio.RG;
            g_clMandoInspLog[m_nUnit].m_Log_CS_BC_5000k = m_stColorSensitivityResult[i].tAdjustColorRatio.BG;
            g_clMandoInspLog[m_nUnit].m_Log_CS_CrCb_5000k = m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb;

			g_clMesCommunication[m_nUnit].m_nMesColorSensitivity[3] = g_clMandoInspLog[m_nUnit].m_Log_CS_RC_5000k;
			g_clMesCommunication[m_nUnit].m_nMesColorSensitivity[4] = g_clMandoInspLog[m_nUnit].m_Log_CS_BC_5000k;
			g_clMesCommunication[m_nUnit].m_nMesColorSensitivity[5] = g_clMandoInspLog[m_nUnit].m_Log_CS_CrCb_5000k;
        }
       

        
        //Logging
        TColorSensitivityResult* pResult = &m_stColorSensitivityResult[i];
        //printf("[Color Sensitivity] RG=%.4f, BG=%.4f, GrGb=%.4f \n", pResult->tColorRatio.RG, pResult->tColorRatio.BG, pResult->tColorRatio.GrGb);
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] RG=%.4f, BG=%.4f, GrGb=%.4f"), pResult->tColorRatio.RG, pResult->tColorRatio.BG, pResult->tColorRatio.GrGb);
        AddLog(szLog, 0, m_nUnit);
        //printf("[Color Sensitivity] R=%.4f, B=%.4f, B=%.4f \n", pResult->tColorRatio.R, pResult->tColorRatio.G, pResult->tColorRatio.B);
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] R=%.4f, B=%.4f, B=%.4f"), pResult->tColorRatio.R, pResult->tColorRatio.G, pResult->tColorRatio.B);
        AddLog(szLog, 0, m_nUnit);
        //printf("[Color Sensitivity] Gr=%.4f, Gb=%.4f \n", pResult->tColorRatio.Gr, pResult->tColorRatio.Gb);
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Color Sensitivity] Gr=%.4f, Gb=%.4f"), pResult->tColorRatio.Gr, pResult->tColorRatio.Gb);
        AddLog(szLog, 0, m_nUnit);
        //Graphic
        const RECT* rt = m_pColorSensitivity->GetInspectionROI((EPos)i);
        cvRectangle(cvImgRI, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(0, 0, 255));
    }
    g_SaveLGITLog(m_nUnit, "ColorSensitivity", m_pColorSensitivity->GetLogHeader(), m_pColorSensitivity->GetLogData());
	return bRes;
}

//-----------------------------------------------------------------------------
//
//	SNR 검사
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_Snr(BYTE* img,  bool bAutoMode)
{

    //원형마크 찾기

    int nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[m_nUnit][1], M_PITCH, M_NULL);
    int nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[m_nUnit][1], M_SIZE_X, M_NULL);
    int nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[m_nUnit][1], M_SIZE_Y, M_NULL);

    if (g_FindCirclePos(m_nUnit, g_clVision.m_pImgBuff[m_nUnit][1], nPitch, nSizeX, nSizeY, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectCircle) == false)
        return false;

    g_CalcImageAlign(m_nUnit);

	bool bRes = false;
	int i = 0;
	TCHAR szLog[SIZE_OF_1K];

    int nBlackLevel = 0;
    int nWidth = g_clModelData[m_nUnit].m_nWidth;
    int nHeight = g_clModelData[m_nUnit].m_nHeight;
    TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;
	// Image information
	//RawImgInfo stImgInfo;
//	TDATASPEC tDataSpec;
    //cvImgDefect
	// Spec information
	TSNRBWSpecN tSNRSpec;

	// Patch Center Point
	POINT ptCenter[3];
	std::vector<double> vdOffset(3, 0.0);
	std::vector<TROIPoint> vROI(56);

	//std::cout << std::endl;
	//std::cout << __FUNCTION__ << std::endl;

	//GetImageData(MODEL_IKC, tDataSpec, stImgInfo);

	// Image buffers
	std::vector<BYTE> vFrameBuffer(nHeight * nWidth * 2);

	memset(&tSNRSpec, 0x00, sizeof(tSNRSpec));

    int offsetX = g_clTaskWork[m_nUnit].m_dOcResultX;
    int offsetY = g_clTaskWork[m_nUnit].m_dOcResultY*-1;

	int snrSizeX, snrSizeY;

	if (g_clModelData[0].m_nModelType == 0)	//LEFT
	{
		snrSizeX = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].right - g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].left;
		snrSizeY = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].bottom - g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].top;

		/* White */
		ptCenter[0].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].left + (snrSizeX / 2) + offsetX;
		ptCenter[0].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].top + (snrSizeY / 2) + offsetY;
		/* Gray */
		ptCenter[1].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[1].left + (snrSizeX / 2) + offsetX;
		ptCenter[1].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[1].top + (snrSizeY / 2) + offsetY;
		/* Black */
		ptCenter[2].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[2].left + (snrSizeX / 2) + offsetX;
		ptCenter[2].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[2].top + (snrSizeY / 2) + offsetY;
	}
	else
	{
		snrSizeX = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[0].right - g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[0].left;
		snrSizeY = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[0].bottom - g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[0].top;

		/* White */
		ptCenter[0].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[0].left + (snrSizeX / 2) + offsetX;
		ptCenter[0].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[0].top + (snrSizeY / 2) + offsetY;
		/* Gray */
		ptCenter[1].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[1].left + (snrSizeX / 2) + offsetX;
		ptCenter[1].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[1].top + (snrSizeY / 2) + offsetY;
		/* Black */
		ptCenter[2].x = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[2].left + (snrSizeX / 2) + offsetX;
		ptCenter[2].y = g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr2[2].top + (snrSizeY / 2) + offsetY;
	}


    /*g_clVision.DrawMOverlayBox(m_nUnit, 
        g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].left+ offsetX, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].top+ offsetY,
        g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].right + offsetX, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[0].bottom+offsetY,
        M_COLOR_DARK_CYAN, 1, FALSE, PS_SOLID);
    g_clVision.DrawMOverlayBox(m_nUnit, 
        g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[1].left + offsetX, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[1].top + offsetY,
        g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[1].right + offsetX, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[1].bottom + offsetY,
        M_COLOR_DARK_CYAN, 1, FALSE, PS_SOLID);
    g_clVision.DrawMOverlayBox(m_nUnit, 
        g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[2].left + offsetX, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[2].top + offsetY,
        g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[2].right + offsetX, g_clModelData[m_nUnit].m_clSfrInfo.m_clRectSnr[2].bottom + offsetY,
        M_COLOR_DARK_CYAN, 1, FALSE, PS_SOLID);*/
    
    for (int i = 0; i < 3; i++) 
    {
		g_clVision.DrawMOverlayBox(m_nUnit,
			ptCenter[i].x - (snrSizeX / 2) + offsetX,
			ptCenter[i].y - (snrSizeY / 2) + offsetY,
			ptCenter[i].x + (snrSizeX / 2) + offsetX,
			ptCenter[i].y + (snrSizeY / 2) + offsetY,
			M_COLOR_DARK_CYAN, 1, FALSE, PS_SOLID);
        vROI[i].ptCenter.x = ptCenter[i].x + offsetX;
        vROI[i].ptCenter.y = ptCenter[i].y + offsetY;
        vROI[i].nROIWidth = snrSizeX;
        vROI[i].nROIHeight = snrSizeY;
    }
	g_clVision.DrawOverlayAll(m_nUnit);
    // Spec
    tSNRSpec.dSNRThreshold = g_clModelData[m_nUnit].m_SnrSpec[0];// 20;		//1.0~100.0 양불판정 SPEC
    tSNRSpec.dDRThreshold = g_clModelData[m_nUnit].m_SnrSpec[1]; //100;
    tSNRSpec.tROI.eROIType = ROIType_POINT;
    tSNRSpec.tROI.ROICount = 3;
    tSNRSpec.tROI.dOffset = vdOffset.data();
    tSNRSpec.tROI.pROIData = vROI.data();
	// Load image
	//LoadImageData(vFrameBuffer.data(), _IMG_IK_Dynamic_Range_raw);

	// Inspect
	//return InspectSNRBW2(tDataSpec, tSNRSpec, vFrameBuffer.data(), stImgInfo.nDisplaySizeX, stImgInfo.nDisplaySizeY, true, _IMG_IK_Dynamic_Range_raw, false, true);

	char title[100];

	// Image buffers
	std::vector<BYTE> vBmpBuffer(nWidth * nHeight * 3, 0);

	// output image
	IplImage *cvImgSNR = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
	cvImgSNR->imageData = (char*)vBmpBuffer.data();

	// for display
	/*if (bRaw)
	{
		ACMISSoftISP::xMakeBMP(img, vBmpBuffer.data(), nWidth, nHeight, tDataSpec);
	}
	else
	{
		std::copy(img, img + sizeof(BYTE) * nWidth * nHeight * 3, vBmpBuffer.data());
	}*/

	std::shared_ptr<CACMISSignalNoiseRatioBW> pSNRBW = std::make_shared<CACMISSignalNoiseRatioBW>();
	const TSNRResult* pSNRResult = nullptr;

	//std::cout << "[SNRBW2] Version: " << pSNRBW->GetVersion() << std::endl;
    _stprintf_s(szLog, SIZE_OF_1K, _T("[SNRBW2]Version:%s"), pSNRBW->GetVersion());
    AddLog(szLog, 0, m_nUnit);
	if (!pSNRBW->InspectM((const BYTE**)&img, nWidth, nHeight, tSNRSpec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, false, 1))
	{
		cvReleaseImage(&cvImgSNR);

		//std::cout << "[SNRBW2] Inspection Fail! " << std::endl;
        _stprintf_s(szLog, SIZE_OF_1K, _T("[SNRBW2] Inspection Fail!"));
		g_SaveLGITLog(m_nUnit, "SNR", pSNRBW->GetLogHeader(), pSNRBW->GetLogData());
        AddLog(szLog, 0, m_nUnit);
		return FALSE;
	}
	//std::cout << "[SNRBW2] Region Count : " << pSNRBW->GetSNRRegionCount() << std::endl;
	_stprintf_s(szLog, SIZE_OF_1K, _T("[SNRBW2]Region Count Hot: %d"), pSNRBW->GetSNRRegionCount());
	AddLog(szLog, 1, m_nUnit, true);
	for (int i = 0; i < pSNRBW->GetSNRRegionCount(); i++)
	{
		pSNRResult = pSNRBW->GetSNRResult(i);
		if (pSNRResult)
		{
			//std::cout << "[SNRBW2] Index : " << pSNRResult->nIndex << std::endl;
			//std::cout << "[SNRBW2] Variance Value : " << pSNRResult->dVariance << std::endl;
			//std::cout << "[SNRBW2] Average Value : " << pSNRResult->dAverage << std::endl;
			//std::cout << "[SNRBW2] Region : " << pSNRResult->rtROI.left << ", " << pSNRResult->rtROI.top << ", " << pSNRResult->rtROI.right << ", " << pSNRResult->rtROI.bottom << std::endl;

			DisplaySNRGraphics(cvImgSNR, pSNRResult, nWidth, CV_GREEN);
		}
	}

	pSNRResult = pSNRBW->GetMinSNRResult();
	if (pSNRResult)
	{
		//std::cout << "[SNRBW2] SNRValue : " << pSNRResult->dSNRResult << std::endl;
		//std::cout << "[SNRBW2] DRValue : " << pSNRResult->dDRResult << std::endl;
        _stprintf_s(szLog, SIZE_OF_1K, _T("[SNRBW2] SNRValue: %lf"), pSNRResult->dSNRResult);
        AddLog(szLog, 1, m_nUnit, true);
        _stprintf_s(szLog, SIZE_OF_1K, _T("[SNRBW2] DRValue: %lf"), pSNRResult->dDRResult);
        AddLog(szLog, 1, m_nUnit, true);

        g_clMandoInspLog[m_nUnit].m_Log_SNR_SNR = pSNRResult->dSNRResult;
        g_clMandoInspLog[m_nUnit].m_Log_SNR_DR = pSNRResult->dDRResult;

		g_clMesCommunication[m_nUnit].m_dMesSnr = g_clMandoInspLog[m_nUnit].m_Log_SNR_SNR;
		g_clMesCommunication[m_nUnit].m_dMesDr = g_clMandoInspLog[m_nUnit].m_Log_SNR_DR;

		DisplaySNRGraphics(cvImgSNR, pSNRResult, nWidth, CV_RED);
	}

	/*if (ImagePath != nullptr && bSaveResultImage == true)
	{
		char filename[100];
		char *tmp = (char *)strrchr(ImagePath, '.');

		if (tmp != nullptr)
		{
			strncpy_s(filename, ImagePath, (int)(tmp - ImagePath));
		}
		else
		{
			strcpy_s(filename, ImagePath);
		}
		strcat_s(filename, "_SNRBW2_result.bmp");
		printf("Saving Result image: %s\n", filename);
		cvSaveImage(filename, cvImgSNR);
	}*/

	//sprintf(title, "SNRBW2%s%s", ImagePath != nullptr ? " - " : "", ImagePath != nullptr ? ImagePath : "");
	//cvShowImage(title, cvImgSNR);
	cvReleaseImage(&cvImgSNR);
    g_SaveLGITLog(m_nUnit, "SNR", pSNRBW->GetLogHeader(), pSNRBW->GetLogData());
	//cvWaitKey(0);
	bRes = true;
	return bRes;
}
void CPRIFunc_Insp::DisplaySNRGraphics(IplImage* _cvImgBuf, const TSNRResult* _SNRResult, int _nImageWidth, CvScalar color)
{
	IplImage* cvImgBuf = _cvImgBuf;

	if (cvImgBuf == nullptr || _SNRResult == nullptr)
		return;

	CvFont cvfont;
	CvPoint pt, pt2;
	char strTmp[256], strTmp2[256];
	int scale = (_nImageWidth > 640 ? 1 : 2);
	double nFontSize = 0.5 / scale;
#define FONTSIZE	9

	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);
	if (_SNRResult->rtROI.right != 0 && _SNRResult->rtROI.bottom != 0)
	{
		if (_SNRResult->dSNRResult == 0.0 && _SNRResult->dDRResult == 0.0)
		{
			sprintf_s(strTmp, "[%d]Avg : %.3f", _SNRResult->nIndex, _SNRResult->dAverage);
			sprintf_s(strTmp2, "[%d]Var : %.3f", _SNRResult->nIndex, _SNRResult->dVariance);
		}
		else if (_SNRResult->dDRResult != 0.0)
		{
			sprintf_s(strTmp, "[%d]SNR : %2.3f", _SNRResult->nIndex, _SNRResult->dSNRResult);
			sprintf_s(strTmp2, "[%d]DR : %2.3f", _SNRResult->nIndex, _SNRResult->dDRResult);
		}
		else
		{
			sprintf_s(strTmp, "[%d]SNR : %2.3f", _SNRResult->nIndex, _SNRResult->dSNRResult);
			memset(strTmp2, 0, sizeof(strTmp2));
		}

		cvRectangle(cvImgBuf, cvPoint((int)_SNRResult->rtROI.left, (int)_SNRResult->rtROI.top), cvPoint((int)_SNRResult->rtROI.right, (int)_SNRResult->rtROI.bottom), color);

		pt.x = (_SNRResult->rtROI.left + _SNRResult->rtROI.right - 1) / 2 - (int)(strlen(strTmp) * FONTSIZE / 2 / scale);
		pt.y = (_SNRResult->rtROI.top + _SNRResult->rtROI.bottom - 1) / 2 + FONTSIZE / 2 / scale;
		pt2.x = (_SNRResult->rtROI.left + _SNRResult->rtROI.right - 1) / 2 - (int)(strlen(strTmp2) * FONTSIZE / 2 / scale);
		pt2.y = (_SNRResult->rtROI.top + _SNRResult->rtROI.bottom - 1) / 2 + FONTSIZE / 2 / scale + FONTSIZE * 2;
	}
	else
	{
		if (_SNRResult->dSNRResult == 0.0 && _SNRResult->dDRResult == 0.0)
		{
			sprintf_s(strTmp, "Avg : %.3f", _SNRResult->dAverage);
			sprintf_s(strTmp2, "VAR : %.3f", _SNRResult->dVariance);
		}
		else if (_SNRResult->dDRResult != 0.0)
		{
			sprintf_s(strTmp, "SNR : %2.3f", _SNRResult->dSNRResult);
			sprintf_s(strTmp2, "DR : %2.3f", _SNRResult->dDRResult);
		}
		else
		{
			sprintf_s(strTmp, "SNR : %2.3f", _SNRResult->dSNRResult);
			memset(strTmp2, 0, sizeof(strTmp2));
		}

		pt.x = _nImageWidth / 2 - (int)(strlen(strTmp) * FONTSIZE / 2 / scale);
		pt.y = FONTSIZE * 2;
		pt2.x = _nImageWidth / 2 - (int)(strlen(strTmp2) * FONTSIZE / 2 / scale);
		pt2.y = FONTSIZE * 2 + FONTSIZE * 2;
	}
	cvPutText(cvImgBuf, strTmp, pt, &cvfont, color);
	cvPutText(cvImgBuf, strTmp2, pt2, &cvfont, color);
}

//-----------------------------------------------------------------------------
//
//	Relative Illumination (RI) 검사
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_Illumination(BYTE* img, bool bAutoMode, bool bUse8BitOnly)
{
	//TRelativeIlluminationSpecX& _Spec,
	bool bRes = false;
	int i = 0;
	int nResult = R_RESULT_PASS;
	char strTmp[1024];
	TCHAR szLog[SIZE_OF_1K];
	int nWidth = g_clModelData[m_nUnit].m_nWidth;
	int nHeight = g_clModelData[m_nUnit].m_nHeight;
	TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;

	// Image information
	//RawImgInfo stImgInfo;
	// Spec information
	TShadingSpec tShadingSpec;

	//std::cout << std::endl;
	//std::cout << __FUNCTION__ << std::endl;

	//GetImageData(MODEL_NIO, tDataSpec, stImgInfo);

	// Image buffers
	std::vector<BYTE> vFrameBuffer(nWidth * nHeight * 2);

	memset(&tShadingSpec, 0x00, sizeof(TShadingSpec));

	//----------------------------------------------------------------------
	// Spec - Relative Illumination
	//----------------------------------------------------------------------

	// Initialize ROI regions and offset values
	std::vector<TROISPoint> vROI_field(5);//기존 모두 5
	std::vector<double> vOffset(100);
	std::vector<double> vCH0_thd(100);
	std::vector<double> vCH1_thd(100);
	std::vector<double> vCH2_thd(100);
	std::vector<double> vCH3_thd(100);
    
    //vector <CBlobRect> *m_vecBlob;	
    //g_clModelData[m_nUnit].m_RISpec[_x][_y] 11,9
	// Center
    int specCount = 0;
    int _xIndex = 0;
    int _x = 0;
    int _y = 0;

    //for (_y = 0; _y < 100; _y++)
    //{
    //    vROI_field[_y].ptStart.x = g_clModelData[m_nUnit].m_RirOI[_y][0];// 0
    //    vROI_field[_y].ptStart.y = g_clModelData[m_nUnit].m_RirOI[_y][1];//1
    //    vROI_field[_y].nROIWidth = g_clModelData[m_nUnit].m_RirOI[_y][2];//2
    //    vROI_field[_y].nROIHeight = g_clModelData[m_nUnit].m_RirOI[_y][3];//3
    //    //
    //    vCH0_thd[_y] = g_clModelData[m_nUnit].m_RirOI[_y][4];//4
    //    vCH1_thd[_y] = g_clModelData[m_nUnit].m_RirOI[_y][5];//5
    //    vCH2_thd[_y] = g_clModelData[m_nUnit].m_RirOI[_y][6];//6
    //    vCH3_thd[_y] = g_clModelData[m_nUnit].m_RirOI[_y][7];//7
    //    //
    //    vOffset[_y] = g_clModelData[m_nUnit].m_RirOI[_y][8];//8
    //}

	vROI_field[0].ptStart.x = 624;
	vROI_field[0].ptStart.y = 464;
	vROI_field[0].nROIWidth = 655;
	vROI_field[0].nROIHeight = 495;

	vROI_field[1].ptStart.x = 624;
	vROI_field[1].ptStart.y = 0;
	vROI_field[1].nROIWidth = 655;
	vROI_field[1].nROIHeight = 31;

	vROI_field[2].ptStart.x = 0;
	vROI_field[2].ptStart.y = 464;
	vROI_field[2].nROIWidth = 31;
	vROI_field[2].nROIHeight = 495;

	vROI_field[3].ptStart.x = 1248;
	vROI_field[3].ptStart.y = 464;
	vROI_field[3].nROIWidth = 1279;
	vROI_field[3].nROIHeight = 495;

	vROI_field[4].ptStart.x = 624;
	vROI_field[4].ptStart.y = 928;
	vROI_field[4].nROIWidth = 655;
	vROI_field[4].nROIHeight = 959;

    //----------------------------------------------------------------------
    // Spec - Relative Illumination X
    //----------------------------------------------------------------------
 //   tShadingSpec.m_stRelativeIlluminationXSpec.nSpecPixelCntInBlock = g_clModelData[m_nUnit].m_RISpec[0];// 8;
 //   tShadingSpec.m_stRelativeIlluminationXSpec.nEnableChannel = g_clModelData[m_nUnit].m_RISpec[1];// 8;
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCenterIntensity[0] = g_clModelData[m_nUnit].m_RISpec[2];//200;
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCenterIntensity[1] = g_clModelData[m_nUnit].m_RISpec[3];//200;
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCenterIntensity[2] = g_clModelData[m_nUnit].m_RISpec[4];//200;
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCenterIntensity[3] = g_clModelData[m_nUnit].m_RISpec[5];//200;

 //   tShadingSpec.m_stRelativeIlluminationXSpec.tROI.eROIType = ROIType_RECT;// ROIType_FIELD;
	//tShadingSpec.m_stRelativeIlluminationXSpec.tROI.ROICount =  5; // 100;
 //   tShadingSpec.m_stRelativeIlluminationXSpec.tROI.dOffset = vOffset.data();
 //   tShadingSpec.m_stRelativeIlluminationXSpec.tROI.pROIData = vROI_field.data();
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCH0Threshold = vCH0_thd.data();
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCH1Threshold = vCH1_thd.data();
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCH2Threshold = vCH2_thd.data();
 //   tShadingSpec.m_stRelativeIlluminationXSpec.dSpecCH3Threshold = vCH3_thd.data();

	//tShadingSpec.m_stRelativeIlluminationXSpec.dSpecRIcornerMin

	//----------------------------------------------------------------------
	// Spec - Relative Illumination N
	//----------------------------------------------------------------------
	tShadingSpec.m_stRelativeIlluminationNSpec.tROI.eROIType = ROIType_RECT;// RO
	tShadingSpec.m_stRelativeIlluminationNSpec.tROI.ROICount = 5; // 100;
	//tShadingSpec.m_stRelativeIlluminationNSpec.tROI.dOffset = vOffset.data();
	tShadingSpec.m_stRelativeIlluminationNSpec.tROI.pROIData = vROI_field.data();

	tShadingSpec.m_stRelativeIlluminationNSpec.dSpecRIcornerMin = (int)g_clModelData[m_nUnit].m_RISpec[specCount++];//60.0;
	tShadingSpec.m_stRelativeIlluminationNSpec.dSpecRIcornerMax = (int)g_clModelData[m_nUnit].m_RISpec[specCount++];//100.0;
	tShadingSpec.m_stRelativeIlluminationNSpec.dSpecRIminMin = (int)g_clModelData[m_nUnit].m_RISpec[specCount++];//5;
	tShadingSpec.m_stRelativeIlluminationNSpec.dSpecRIminMax = (int)g_clModelData[m_nUnit].m_RISpec[specCount++];//100;
	tShadingSpec.m_stRelativeIlluminationNSpec.dCenterIntensity = (int)g_clModelData[m_nUnit].m_RISpec[specCount++];//2000;
	tShadingSpec.m_stRelativeIlluminationNSpec.nSpecRINormalizeIndex = (int)g_clModelData[m_nUnit].m_RISpec[specCount++];//0;

	
	bool bRaw = true;
	bool bEnableRelativeIllumination = true;
	bool bEnableRelativeIlluminationX = true;
	bool bEnableRelativeUniformity = true;
	bool bEnableColorSensitivity = true;
	bool bSaveResultImage = false;
	//----------------------------------------------------------------------
	// Inspect Main Camera
	//----------------------------------------------------------------------

	int nResultRI = -1, nResultRU = -1, nResultCS = -1, nResultRI_X = -1;
	char title[100];

	// Image buffers
	std::vector<BYTE> vBmpBuffer(nWidth * nHeight * 3, 0);

	// output image
	IplImage *cvImgShading = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
	cvImgShading->imageData = (char*)vBmpBuffer.data();

	// for display
	if (bRaw)
	{
		ACMISSoftISP::xMakeBMP(img, vBmpBuffer.data(), nWidth, nHeight, tDataSpec);
	}
	else
	{
		//std::copy(img, img + sizeof(BYTE) * nWidth * nHeight * 3, vBmpBuffer.data());
	}


	if (bEnableRelativeIlluminationX)
	{

		//nResultRI_X = Inspect_RelativeIlluminationX(img, nWidth, nHeight, tShadingSpec.m_stRelativeIlluminationXSpec, tDataSpec, cvImgShading, bUse8BitOnly);
		nResultRI_X = Inspect_RelativeIllumination(img, nWidth, nHeight, tShadingSpec.m_stRelativeIlluminationNSpec, tDataSpec, cvImgShading, bUse8BitOnly);
        //
		//std::cout << "nResult Relative Illumination X =" << nResultRI_X << std::endl;
        _stprintf_s(szLog, SIZE_OF_1K, _T("	nResult Relative Illumination X = %d"), nResultRI_X);
        AddLog(szLog, 0, m_nUnit);
	}


	
    sprintf(title, "Relative Illumination");// , ImagePath != nullptr ? " - " : "", ImagePath != nullptr ? ImagePath : "");
	if (bAutoMode == false)
	{
		cvShowImage(title, cvImgShading);
		cvWaitKey(0);
	}
	
	cvReleaseImage(&cvImgShading);
    
	return bRes;
}
int CPRIFunc_Insp::Inspect_RelativeIllumination(const BYTE* pBuffer, int nImageWidth, int nImageHeight, TRelativeIlluminationSpecN& _Spec, TDATASPEC& tDataSpec, IplImage *cvImgRI, bool bUse8BitOnly)
{
	int nResult = R_RESULT_PASS;
	char strTmp[1024];
	CvFont cvfont;
	int scale = (nImageWidth > 640 ? 1 : 2);
	double nFontSize = 0.5 / scale;
	CvPoint pt;

	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);

	std::shared_ptr<CACMISShadingRelativeIllumination> m_pRelativeIllumination = std::make_shared<CACMISShadingRelativeIllumination>();

	std::cout << "[Relative Illumination] Version = " << m_pRelativeIllumination->GetVersion() << std::endl;

	//Inspection
	if (!m_pRelativeIllumination->Inspect(pBuffer, nImageWidth, nImageHeight, _Spec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, bUse8BitOnly))
	{
		std::cout << "[Relative Illumination] Inspection Fail! " << std::endl;
		return FALSE;
	}

	//Result
	TRelativeIlluminationResultN m_stRelativeIlluminationResult;
	m_stRelativeIlluminationResult = *m_pRelativeIllumination->GetInspectionResult(0);
	// Check RI corner
	if ((_Spec.dSpecRIcornerMin > m_stRelativeIlluminationResult.dRIcorner) || (_Spec.dSpecRIcornerMax < m_stRelativeIlluminationResult.dRIcorner))
		nResult = R_RESULT_FAIL;
	// Check min RI corner
	if ((_Spec.dSpecRIminMin > m_stRelativeIlluminationResult.dRImin) || (_Spec.dSpecRIminMax < m_stRelativeIlluminationResult.dRImin))
		nResult = R_RESULT_FAIL;

	//m_stRelativeIlluminationResult.dRIcornerRatio[0]
	//	m_stRelativeIlluminationResult.dRIcornerRatio[1]
	//	m_stRelativeIlluminationResult.dRIcornerRatio[2]
	//	m_stRelativeIlluminationResult.dRIcornerRatio[3]

	//Logging
	std::cout << "[Relative Illumination] Center= " << m_stRelativeIlluminationResult.dRIcenterRAW << std::endl;
	std::cout << "[Relative Illumination] UL=" << m_stRelativeIlluminationResult.dRIcornerRAW[0] << std::endl;
	std::cout << "[Relative Illumination] UR=" << m_stRelativeIlluminationResult.dRIcornerRAW[1] << std::endl;
	std::cout << "[Relative Illumination] LL=" << m_stRelativeIlluminationResult.dRIcornerRAW[2] << std::endl;
	std::cout << "[Relative Illumination] LR=" << m_stRelativeIlluminationResult.dRIcornerRAW[3] << std::endl;
	std::cout << "[Relative Illumination] RIcorner=" << m_stRelativeIlluminationResult.dRIcorner << std::endl;
	std::cout << "[Relative Illumination] RImin=" << m_stRelativeIlluminationResult.dRImin << std::endl;


	//Graphic
	for (int i = 0; i<5; i++)
	{
		const RECT* rt = m_pRelativeIllumination->GetInspectionROI((EPos)i);

		if ((_Spec.dSpecRIminMin > m_stRelativeIlluminationResult.dRIcornerRatio[i]) || (_Spec.dSpecRIminMax < m_stRelativeIlluminationResult.dRIcornerRatio[i]))
		{
			cvRectangle(cvImgRI, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RED, 3);//CV_RGB(0, 255, 0));
		}
		else
		{
			cvRectangle(cvImgRI, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_GREEN, 3);//CV_RGB(0, 255, 0));
		}
		
		
		pt.x = rt->left + 4;
		pt.y = rt->top + (int)((rt->bottom - rt->top) / 2) + 4;
		if (pt.x + 100 > nImageWidth)	pt.x = pt.x - 100;

		sprintf_s(strTmp, "[%d]%.0f(%.1f)", i,m_stRelativeIlluminationResult.dRIcornerRAW[i], m_stRelativeIlluminationResult.dRIcornerRatio[i]);
		cvPutText(cvImgRI, strTmp, pt, &cvfont, CV_BLUE);
	}
	g_SaveLGITLog(m_nUnit, "RI", m_pRelativeIllumination->GetLogHeader(), m_pRelativeIllumination->GetLogData());
	return nResult;
}

int CPRIFunc_Insp::Inspect_RelativeIlluminationX(const BYTE* pBuffer, int nImageWidth, int nImageHeight, TRelativeIlluminationSpecX& _Spec, TDATASPEC& tDataSpec, IplImage *cvImgRI, bool bUse8BitOnly)
{
	int nResult = R_RESULT_PASS;
    TCHAR	szLog[SIZE_OF_1K];
	std::shared_ptr<CACMISShadingRelativeIllumination_X> m_pRelativeIlluminationX = std::make_shared<CACMISShadingRelativeIllumination_X>();

	std::cout << "[Relative Illumination X] Version = " << m_pRelativeIlluminationX->GetVersion() << std::endl;

	//Inspection
	if (!m_pRelativeIlluminationX->Inspect(pBuffer, nImageWidth, nImageHeight, _Spec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, bUse8BitOnly))
	{
		//std::cout << "[Relative Illumination X] Inspection Fail! " << std::endl;
        _stprintf_s(szLog, SIZE_OF_1K, _T("	[Relative Illumination X] Inspection Fail!"));
        AddLog(szLog, 0, m_nUnit);
		return FALSE;
	}
     
	//Result
	TRelativeIlluminationResultX stCenterResult = *m_pRelativeIlluminationX->GetInspectionCenterResult();
	RECT rt;

	rt.left = stCenterResult.rtROI.left * 2;
	rt.top = stCenterResult.rtROI.top * 2;
	rt.right = stCenterResult.rtROI.right * 2;
	rt.bottom = stCenterResult.rtROI.bottom * 2;
	cvRectangle(cvImgRI, cvPoint(rt.left, rt.top), cvPoint(rt.right, rt.bottom), CV_RGB(0, 255, 0));

	//Logging
	std::cout << "[Relative Illumination X] Center= " << stCenterResult.dRIRawResult[0] << "," << stCenterResult.dRIRawResult[1] << "," << stCenterResult.dRIRawResult[2] << "," << stCenterResult.dRIRawResult[3] << "," << std::endl;

    _stprintf_s(szLog, SIZE_OF_1K, _T("	[Relative Illumination X] Center=%lf,%lf,%lf,%lf"),stCenterResult.dRIRawResult[0], stCenterResult.dRIRawResult[1], stCenterResult.dRIRawResult[2], stCenterResult.dRIRawResult[3]);
    AddLog(szLog, 0, m_nUnit);

    g_clMandoInspLog[m_nUnit].m_Log_RI_Center_R = stCenterResult.dRIRawResult[1];
    g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cr = stCenterResult.dRIRawResult[0];
    g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cb = stCenterResult.dRIRawResult[3];
    g_clMandoInspLog[m_nUnit].m_Log_RI_Center_B = stCenterResult.dRIRawResult[2];
	
	if (g_clMandoInspLog[m_nUnit].m_Log_RI_Center_R < _Spec.dSpecCenterIntensity[1])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] RED Spec Out %lf [%.1lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_R, _Spec.dSpecCenterIntensity[1]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI RED NG]");

		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI RED:%lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_R);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}
	if (g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cr < _Spec.dSpecCenterIntensity[0])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] CLEARR Spec Out %lf [%.1lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cr, _Spec.dSpecCenterIntensity[0]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI CLEARR NG]");

		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI CLEARR:%lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cr);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}

	if (g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cb < _Spec.dSpecCenterIntensity[3])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] CLEARB Spec Out %lf [%.1lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cb, _Spec.dSpecCenterIntensity[3]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI CLEARB NG]");

		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI CLEARB:%lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cb);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}
	if (g_clMandoInspLog[m_nUnit].m_Log_RI_Center_B < _Spec.dSpecCenterIntensity[2])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] BLUE Spec Out %lf [%.1lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_B, _Spec.dSpecCenterIntensity[2]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI BLUE NG]");

		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI BLUE:%lf]"), g_clMandoInspLog[m_nUnit].m_Log_RI_Center_B);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}


    int getir = m_pRelativeIlluminationX->GetInspectionRegionCount();// = 100
	double CornerTemp = 0.0;
	CornerTemp = m_pRelativeIlluminationX->GetCornerVariation(1);
	if (_finite(CornerTemp))
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_R = CornerTemp;
	}
	else
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_R = 0.0;
	}
	CornerTemp = m_pRelativeIlluminationX->GetCornerVariation(0);
	if (_finite(CornerTemp))
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cr = CornerTemp;
	}
	else
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cr = 0.0;
	}
	CornerTemp = m_pRelativeIlluminationX->GetCornerVariation(3);
	if (_finite(CornerTemp))
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cb = CornerTemp;
	}
	else
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cb = 0.0;
	}
	CornerTemp = m_pRelativeIlluminationX->GetCornerVariation(2);
	if (_finite(CornerTemp))
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_B = CornerTemp;
	}
	else
	{
		g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_B = 0.0;
	}
	

	double CornerVarTemp =0.0;
	CornerVarTemp = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_R;
	if (CornerVarTemp < g_clModelData[m_nUnit].m_RISpec[6] || CornerVarTemp >= g_clModelData[m_nUnit].m_RISpec[7])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] CornerVar_R Spec Out %lf [%.1lf~%.1lf]"), CornerVarTemp, g_clModelData[m_nUnit].m_RISpec[6], g_clModelData[m_nUnit].m_RISpec[7]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI CornerVar_R NG]");

		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI BLUE:%lf]"), CornerVarTemp);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}
	//
	//
	//
	CornerVarTemp = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cr;
	if (CornerVarTemp < g_clModelData[m_nUnit].m_RISpec[6] || CornerVarTemp >= g_clModelData[m_nUnit].m_RISpec[7])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] CornerVar_Cr Spec Out %lf [%.1lf~%.1lf]"), CornerVarTemp, g_clModelData[m_nUnit].m_RISpec[6], g_clModelData[m_nUnit].m_RISpec[7]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI CornerVar_Cr NG]");
		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI CornerVar_Cr:%lf]"), CornerVarTemp);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}
	//
	CornerVarTemp = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cb;
	if (CornerVarTemp < g_clModelData[m_nUnit].m_RISpec[6] || CornerVarTemp >= g_clModelData[m_nUnit].m_RISpec[7])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] CornerVar_Cb Spec Out %lf [%.1lf~%.1lf]"), CornerVarTemp, g_clModelData[m_nUnit].m_RISpec[6], g_clModelData[m_nUnit].m_RISpec[7]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI CornerVar_Cb NG]");
		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI CornerVar_Cb:%lf]"), CornerVarTemp);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}
	//
	CornerVarTemp = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_B;
	if (CornerVarTemp < g_clModelData[m_nUnit].m_RISpec[6] || CornerVarTemp >= g_clModelData[m_nUnit].m_RISpec[7])
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[RI] CornerVar_B Spec Out %lf [%.1lf~%.1lf]"), CornerVarTemp, g_clModelData[m_nUnit].m_RISpec[6], g_clModelData[m_nUnit].m_RISpec[7]);
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [RI CornerVar_B NG]");
		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [RI CornerVar_B:%lf]"), CornerVarTemp);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, m_nUnit);
	}
	//
	//
	//
	//
	for (int i = 0; i < (int)70;i++)// m_pRelativeIlluminationX->GetInspectionRegionCount(); i++)
	{
		bool bSpecIn = m_pRelativeIlluminationX->InSpec(i);
		TRelativeIlluminationResultX result = *m_pRelativeIlluminationX->GetInspectionResult(i);
		rt.left = result.rtROI.left * 2;
		rt.top = result.rtROI.top * 2;
		rt.right = result.rtROI.right * 2;
		rt.bottom = result.rtROI.bottom * 2;

		if (result.bPass)
			cvRectangle(cvImgRI, cvPoint(rt.left, rt.top), cvPoint(rt.right, rt.bottom), CV_RGB(0, 255, 0));
		else
			cvRectangle(cvImgRI, cvPoint(rt.left, rt.top), cvPoint(rt.right, rt.bottom), CV_RGB(255, 0, 0));

		/*printf("[%d] %d(%.1f),%d(%.1f),%d(%.1f),%d(%.1f)\n", i, (int)result.dRIRawResult[0], result.dRINormalResult[0],
			(int)result.dRIRawResult[1], result.dRINormalResult[1], (int)result.dRIRawResult[2], result.dRINormalResult[2],
			(int)result.dRIRawResult[3], result.dRINormalResult[3]);*/
        //
        g_clMandoInspLog[m_nUnit].m_Log_RI_RED[i] = result.dRINormalResult[1];
        g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARR[i] = result.dRINormalResult[0];
        g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARB[i] = result.dRINormalResult[3];
        g_clMandoInspLog[m_nUnit].m_Log_RI_BLUE[i] = result.dRINormalResult[2];

	}

	g_clMesCommunication[m_nUnit].m_nMesRICorner[0] = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_R;
	g_clMesCommunication[m_nUnit].m_nMesRICorner[1] = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cr;
	g_clMesCommunication[m_nUnit].m_nMesRICorner[2] = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_Cb;
	g_clMesCommunication[m_nUnit].m_nMesRICorner[3] = g_clMandoInspLog[m_nUnit].m_Log_RI_CornerVar_B;
	

	g_clMesCommunication[m_nUnit].m_nMesRI[0] = g_clMandoInspLog[m_nUnit].m_Log_RI_Center_R;
	g_clMesCommunication[m_nUnit].m_nMesRI[1] = g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cr;
	g_clMesCommunication[m_nUnit].m_nMesRI[2] = g_clMandoInspLog[m_nUnit].m_Log_RI_Center_Cb;
	g_clMesCommunication[m_nUnit].m_nMesRI[3] = g_clMandoInspLog[m_nUnit].m_Log_RI_Center_B;

	g_clMesCommunication[m_nUnit].m_nMesRI[4] = g_clMandoInspLog[m_nUnit].m_Log_RI_RED[0];
	g_clMesCommunication[m_nUnit].m_nMesRI[5] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARR[0];
	g_clMesCommunication[m_nUnit].m_nMesRI[6] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARB[0];
	g_clMesCommunication[m_nUnit].m_nMesRI[7] = g_clMandoInspLog[m_nUnit].m_Log_RI_BLUE[0];
	//
	g_clMesCommunication[m_nUnit].m_nMesRI[8] = g_clMandoInspLog[m_nUnit].m_Log_RI_RED[9];
	g_clMesCommunication[m_nUnit].m_nMesRI[9] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARR[9];
	g_clMesCommunication[m_nUnit].m_nMesRI[10] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARB[9];
	g_clMesCommunication[m_nUnit].m_nMesRI[11] = g_clMandoInspLog[m_nUnit].m_Log_RI_BLUE[9];
	//
	g_clMesCommunication[m_nUnit].m_nMesRI[12] = g_clMandoInspLog[m_nUnit].m_Log_RI_RED[90];
	g_clMesCommunication[m_nUnit].m_nMesRI[13] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARR[90];
	g_clMesCommunication[m_nUnit].m_nMesRI[14] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARB[90];
	g_clMesCommunication[m_nUnit].m_nMesRI[15] = g_clMandoInspLog[m_nUnit].m_Log_RI_BLUE[90];
	//
	g_clMesCommunication[m_nUnit].m_nMesRI[16] = g_clMandoInspLog[m_nUnit].m_Log_RI_RED[99];
	g_clMesCommunication[m_nUnit].m_nMesRI[17] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARR[99];
	g_clMesCommunication[m_nUnit].m_nMesRI[18] = g_clMandoInspLog[m_nUnit].m_Log_RI_CLEARB[99];
	g_clMesCommunication[m_nUnit].m_nMesRI[19] = g_clMandoInspLog[m_nUnit].m_Log_RI_BLUE[99];


    g_SaveLGITLog(m_nUnit, "RI", m_pRelativeIlluminationX->GetLogHeader(), m_pRelativeIlluminationX->GetLogData());
	return nResult;
}
//-----------------------------------------------------------------------------
//
//	SNR 검사
//
//-----------------------------------------------------------------------------
int CPRIFunc_Insp::func_Insp_Ic(const BYTE* img)
{
	int nResult = R_RESULT_PASS;
	const DPOINT* dResultPos;
	int nWidth = g_clModelData[m_nUnit].m_nWidth;
	int nHeight = g_clModelData[m_nUnit].m_nHeight;
	TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;
	std::shared_ptr<CACMISOpticalCenterCentroid> m_pOpticalCenter = std::make_shared<CACMISOpticalCenterCentroid>();
	int specCount = 0;
	TOpticalCenter tOpticalCenter;

	tOpticalCenter.dOpticalCenterSpecX = g_clModelData[m_nUnit].m_ICSpec[specCount++];// 20;
	tOpticalCenter.dOpticalCenterSpecY = g_clModelData[m_nUnit].m_ICSpec[specCount++];//20;
	tOpticalCenter.dPixelPitch = g_clModelData[m_nUnit].m_ICSpec[specCount++];//3.75;
	tOpticalCenter.dThresholdRatio = g_clModelData[m_nUnit].m_ICSpec[specCount++];//0.5;
	tOpticalCenter.nOCBlockSize = (int)g_clModelData[m_nUnit].m_ICSpec[specCount++];//5;
	tOpticalCenter.nEdgeTopMargin = (int)g_clModelData[m_nUnit].m_ICSpec[specCount++];//100;
	

	if (!m_pOpticalCenter->Inspect(img, nWidth, nHeight, tOpticalCenter, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, false))
	{
		std::cout << "[Illumination Center] Inspection Fail! " << std::endl;
		return R_RESULT_FAIL;
	}

	dResultPos = m_pOpticalCenter->GetOpticalCenterResult();
	
	std::cout << "[Illumination Center] x= %.3f" << dResultPos->x << std::endl;
	std::cout << "[Illumination Center] y= %.3f" << dResultPos->y << std::endl;

	int scale = (nWidth > 640 ? 1 : 2);
	double nFontSize = 0.5 / scale;
	char strTmp[1024];
	CvFont cvfont;
	CvPoint pt;
	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);

	
	pt.x = dResultPos->x -(nWidth/2);
	pt.y = dResultPos->y- (nHeight /2);
	sprintf_s(strTmp, "X (%d,%d) => (%d,%d)", (int)dResultPos->x, (int)dResultPos->y, pt.x, pt.y);
	g_clVision.DrawMOverlayText(0, (nWidth / 2), (nHeight / 2), strTmp, M_COLOR_CYAN, _T("Arial"), 10, 0);
	g_SaveLGITLog(m_nUnit, "IlluminationCenter", m_pOpticalCenter->GetLogHeader(), m_pOpticalCenter->GetLogData());
	return nResult;
}
int CPRIFunc_Insp::Inspect_RelativeUniformity(const BYTE* pBuffer, int nImageWidth, int nImageHeight, TRelativeUniformitySpec& _Spec, TDATASPEC& tDataSpec, IplImage *cvImgRU, bool bUse8BitOnly)
{
	int nResult = R_RESULT_PASS;

	std::shared_ptr<CACMISShadingRelativeUniformity> m_pRelativeUniformity = std::make_shared<CACMISShadingRelativeUniformity>();

	//Logging
	std::cout << "[Relative Uniformity] Version = " << m_pRelativeUniformity->GetVersion() << std::endl;


	//Inspection
	if (!m_pRelativeUniformity->Inspect(pBuffer, nImageWidth, nImageHeight, _Spec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, bUse8BitOnly))
	{
		std::cout << "[Relative Uniformity] Inspection Fail! " << std::endl;
		return FALSE;
	}

	//Result 
	TRelativeUniformityResult m_stRelativeUniformityResult;

	m_stRelativeUniformityResult = *m_pRelativeUniformity->GetInspectionResult();

	int roiSize = _Spec.nROISize;
	if (_Spec.dSpecMax < m_stRelativeUniformityResult.dResultMax)
		nResult = R_RESULT_FAIL;

	//Logging
	std::cout << "[Relative Uniformity] Max= " << m_stRelativeUniformityResult.dResultMax << std::endl;
	std::cout << "[Relative Uniformity] Block( " << m_stRelativeUniformityResult.nMaxBlockX << " , " << m_stRelativeUniformityResult.nMaxBlockY << " )";
	std::cout << "X= " << (m_stRelativeUniformityResult.nMaxBlockX)*(_Spec.nROISize) << ", ";
	std::cout << "Y= " << (m_stRelativeUniformityResult.nMaxBlockY)*(_Spec.nROISize) << ", ";
	std::cout << "Width= " << _Spec.nROISize << ", " << "Height= " << _Spec.nROISize << std::endl;
	std::cout << "[Relative Uniformity] Ref Block( " << m_stRelativeUniformityResult.nRefBlockX << " , " << m_stRelativeUniformityResult.nRefBlockY << " )";
	std::cout << "X= " << (m_stRelativeUniformityResult.nRefBlockX)*(_Spec.nROISize) << ", ";
	std::cout << "Y= " << (m_stRelativeUniformityResult.nRefBlockY)*(_Spec.nROISize) << ", ";
	std::cout << "Width= " << _Spec.nROISize << ", " << "Height= " << _Spec.nROISize << std::endl;

	//Graphic
	RECT rect, rectRef;

	rect.left = m_stRelativeUniformityResult.nMaxBlockX * roiSize;
	rect.top = m_stRelativeUniformityResult.nMaxBlockY * roiSize;
	rect.right = rect.left + roiSize;
	rect.bottom = rect.top + roiSize;

	rectRef.left = m_stRelativeUniformityResult.nRefBlockX * roiSize;
	rectRef.top = m_stRelativeUniformityResult.nRefBlockY * roiSize;
	rectRef.right = rectRef.left + roiSize;
	rectRef.bottom = rectRef.top + roiSize;

	cvRectangle(cvImgRU, cvPoint(rect.left, rect.top), cvPoint(rect.right, rect.bottom), CV_LIGHTGREEN);
	cvRectangle(cvImgRU, cvPoint(rectRef.left, rectRef.top), cvPoint(rectRef.right, rectRef.bottom), CV_YELLOW);

	return nResult;
}
int CPRIFunc_Insp::Inspect_ColorSensitivity(const BYTE* pBuffer,  bool bUse8BitOnly)
{
    int nWidth = g_clModelData[m_nUnit].m_nWidth;
    int nHeight = g_clModelData[m_nUnit].m_nHeight;
    TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;

	int nResult = R_RESULT_PASS;
	int i;
    int nResultRI = -1, nResultRU = -1, nResultCS = -1, nResultRI_X;
    char title[100];

    // Image buffers
    std::vector<BYTE> vBmpBuffer(nWidth * nHeight * 3, 0);

    // output image
    IplImage *cvImgShading = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
    cvImgShading->imageData = (char*)vBmpBuffer.data();

    // for display
    //if (bRaw)
    //{
    //    ACMISSoftISP::xMakeBMP(pBuffer, vBmpBuffer.data(), nWidth, nHeight, tDataSpec);
    //}
    //else
    //{
    //   // std::copy(pBuffer, pBuffer + sizeof(BYTE) * nWidth * nHeight * 3, vBmpBuffer.data());
    //}
    // Spec information
    TShadingSpec tShadingSpec;
    memset(&tShadingSpec, 0x00, sizeof(TShadingSpec));
    //----------------------------------------------------------------------
    // Spec - Color Sensitivity
    //----------------------------------------------------------------------

    // Initialize ROI regions and offset values
    RECT rtRoi;
    double dOffset = 0.0;

    SetRect(&rtRoi, 856, 432, 965, 507);

    tShadingSpec.m_stColorSensitivitySpec.tROI.eROIType = ROIType_RECT;
    tShadingSpec.m_stColorSensitivitySpec.tROI.ROICount = 1;
    tShadingSpec.m_stColorSensitivitySpec.tROI.dOffset = &dOffset;
    tShadingSpec.m_stColorSensitivitySpec.tROI.pROIData = &rtRoi;

    tShadingSpec.m_stColorSensitivitySpec.dSpecDevMaxRG =   1.000000;
    tShadingSpec.m_stColorSensitivitySpec.dSpecDevMinRG =   1.000000;
    tShadingSpec.m_stColorSensitivitySpec.dSpecDevMaxBG =   1.000000;
    tShadingSpec.m_stColorSensitivitySpec.dSpecDevMinBG =   1.000000;
    tShadingSpec.m_stColorSensitivitySpec.dSpecDevMaxGrGb = 1.000000;
    tShadingSpec.m_stColorSensitivitySpec.dSpecDevMinGrGb = 1.000000;
    tShadingSpec.m_stColorSensitivitySpec.nTypicalValueType = 0;

    /*nResultCS = Inspect_ColorSensitivity(pBuffer, nWidth, nHeight, tShadingSpec.m_stColorSensitivitySpec, 
        tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, cvImgShading, bUse8BitOnly);
    std::cout << "nResult Color Sensitivity =" << nResultCS << std::endl;*/

    std::shared_ptr<CACMISShadingColorSensitivity> m_pColorSensitivity = std::make_shared<CACMISShadingColorSensitivity>();

    std::cout << "[Color Sensitivity] Version = " << m_pColorSensitivity->GetVersion() << std::endl;

    //Inspection
    /*if (!m_pColorSensitivity->Inspect(pBuffer, nWidth, nHeight, tShadingSpec.m_stColorSensitivitySpec, 
        tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, cvImgShading, bUse8BitOnly))
    {
        std::cout << "[Color Sensitivity] Inspection Fail! " << std::endl;
        return FALSE;
    }*/

    //Result
    //std::vector<TColorSensitivityResult> m_stColorSensitivityResult;
    //for (i = 0; i < _Spec.tROI.ROICount; i++)
    //{
    //    m_stColorSensitivityResult.push_back(*m_pColorSensitivity->GetInspectionResult(i));

    //    // Check Color Sensitivity RG
    //    if ((_Spec.dSpecDevMinRG > m_stColorSensitivityResult[i].tAdjustColorRatio.RG) || (_Spec.dSpecDevMaxRG < m_stColorSensitivityResult[i].tAdjustColorRatio.RG))
    //        nResult = R_RESULT_FAIL;
    //    // Check Color Sensitivity BG
    //    if ((_Spec.dSpecDevMinBG > m_stColorSensitivityResult[i].tAdjustColorRatio.BG) || (_Spec.dSpecDevMaxBG < m_stColorSensitivityResult[i].tAdjustColorRatio.BG))
    //        nResult = R_RESULT_FAIL;
    //    // Check Color Sensitivity GrGb
    //    if ((_Spec.dSpecDevMinGrGb > m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb) || (_Spec.dSpecDevMaxGrGb < m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb))
    //        nResult = R_RESULT_FAIL;

    //    //Logging
    //    TColorSensitivityResult* pResult = &m_stColorSensitivityResult[i];
    //    //printf("[Color Sensitivity] RG=%.4f, BG=%.4f, GrGb=%.4f \n", pResult->tColorRatio.RG, pResult->tColorRatio.BG, pResult->tColorRatio.GrGb);
    //    //printf("[Color Sensitivity] R=%.4f, B=%.4f, B=%.4f \n", pResult->tColorRatio.R, pResult->tColorRatio.G, pResult->tColorRatio.B);
    //    //printf("[Color Sensitivity] Gr=%.4f, Gb=%.4f \n", pResult->tColorRatio.Gr, pResult->tColorRatio.Gb);

    //    //Graphic
    //    const RECT* rt = m_pColorSensitivity->GetInspectionROI((EPos)i);
    //    cvRectangle(cvImgRI, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(0, 0, 255));
    //}



   /* if (ImagePath != nullptr && bSaveResultImage == true)
    {
        char filename[100];
        char *tmp = (char *)strrchr(ImagePath, '.');

        if (tmp != nullptr)
        {
            strncpy_s(filename, ImagePath, (int)(tmp - ImagePath));
        }
        else
        {
            strcpy_s(filename, ImagePath);
        }
        strcat_s(filename, "_Shading_result.bmp");
        printf("Saving Result image: %s\n", filename);
        cvSaveImage(filename, cvImgShading);
    }*/

    /*sprintf(title, "Shading%s%s", ImagePath != nullptr ? " - " : "", ImagePath != nullptr ? ImagePath : "");
    cvShowImage(title, cvImgShading);
    cvReleaseImage(&cvImgShading);
    cvWaitKey(0);*/
	//std::shared_ptr<CACMISShadingColorSensitivity> m_pColorSensitivity = std::make_shared<CACMISShadingColorSensitivity>();

	//std::cout << "[Color Sensitivity] Version = " << m_pColorSensitivity->GetVersion() << std::endl;

	////Inspection
	//if (!m_pColorSensitivity->Inspect(pBuffer, nWidth, nHeight, _Spec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, bUse8BitOnly))
	//{
	//	std::cout << "[Color Sensitivity] Inspection Fail! " << std::endl;
	//	return FALSE;
	//}

	////Result
	//std::vector<TColorSensitivityResult> m_stColorSensitivityResult;
	//for (i = 0; i < _Spec.tROI.ROICount; i++)
	//{
	//	m_stColorSensitivityResult.push_back(*m_pColorSensitivity->GetInspectionResult(i));

	//	// Check Color Sensitivity RG
	//	if ((_Spec.dSpecDevMinRG > m_stColorSensitivityResult[i].tAdjustColorRatio.RG) || (_Spec.dSpecDevMaxRG < m_stColorSensitivityResult[i].tAdjustColorRatio.RG))
	//		nResult = R_RESULT_FAIL;
	//	// Check Color Sensitivity BG
	//	if ((_Spec.dSpecDevMinBG > m_stColorSensitivityResult[i].tAdjustColorRatio.BG) || (_Spec.dSpecDevMaxBG < m_stColorSensitivityResult[i].tAdjustColorRatio.BG))
	//		nResult = R_RESULT_FAIL;
	//	// Check Color Sensitivity GrGb
	//	if ((_Spec.dSpecDevMinGrGb > m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb) || (_Spec.dSpecDevMaxGrGb < m_stColorSensitivityResult[i].tAdjustColorRatio.GrGb))
	//		nResult = R_RESULT_FAIL;

	//	//Logging
	//	TColorSensitivityResult* pResult = &m_stColorSensitivityResult[i];
	//	printf("[Color Sensitivity] RG=%.4f, BG=%.4f, GrGb=%.4f \n", pResult->tColorRatio.RG, pResult->tColorRatio.BG, pResult->tColorRatio.GrGb);
	//	printf("[Color Sensitivity] R=%.4f, B=%.4f, B=%.4f \n", pResult->tColorRatio.R, pResult->tColorRatio.G, pResult->tColorRatio.B);
	//	printf("[Color Sensitivity] Gr=%.4f, Gb=%.4f \n", pResult->tColorRatio.Gr, pResult->tColorRatio.Gb);

	//	//Graphic
	//	const RECT* rt = m_pColorSensitivity->GetInspectionROI((EPos)i);
	//	cvRectangle(cvImgRI, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(0, 0, 255));
	//}

	return nResult;
}

//-----------------------------------------------------------------------------
//
//	DEFECT 검사 (dark , white , hot)
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_Defect(BYTE* lowImage, BYTE* midImage, bool bAutoMode)
{
	int nBlackLevel = 0;
	TCHAR szLog[SIZE_OF_1K];
	// Spec information
	// Image information`
	//TDATASPEC tDataSpec;
	int nWidth = g_clModelData[m_nUnit].m_nWidth;
	int nHeight = g_clModelData[m_nUnit].m_nHeight;
	TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;
	int i = 0;
	// Spec information
	TAllDefectPixel_ONSEMI_RCCB stSpecAllOnsemiRCCBSpec;
	BYTE *pBuffer[2] = { NULL, NULL };

	std::shared_ptr<CACMISDefectAllDefectPixel_ONSEMI_RCCB> pOnsemiRCCBDefect = std::make_shared<CACMISDefectAllDefectPixel_ONSEMI_RCCB>();

	std::cout << std::endl;
	std::cout << __FUNCTION__ << std::endl;

	//GetImageData(MODEL_NIO, tDataSpec, stImgInfo);

	//std::vector<BYTE> vFrameBuffer1(nWidth * nHeight * 2); // mid-level Image  
	//std::vector<BYTE> vFrameBuffer2(nWidth * nHeight * 2); // low-level Image

	pBuffer[0] = midImage;// g_clLaonGrabberWrapper[m_nUnit].vDefectMidBuffer_6500K; // mid-level image for detecting dark/bright defect
	pBuffer[1] = lowImage;// g_clLaonGrabberWrapper[m_nUnit].vDefectLowBuffer; // low-level image for detecting hot defect

	

	// Image buffers
	std::vector<BYTE> vBmpBuffer1(nWidth * nHeight * 3, 0);
	std::vector<BYTE> vBmpBuffer2(nWidth * nHeight * 3, 0);

	// output image
	IplImage *cvImgDefect1 = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
	cvImgDefect1->imageData = (char*)vBmpBuffer1.data();

	IplImage *cvImgDefect2 = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
	cvImgDefect2->imageData = (char*)vBmpBuffer2.data();

	// for display
	ACMISSoftISP::xMakeBMP(pBuffer[0], vBmpBuffer1.data(), nWidth, nHeight, tDataSpec);
	ACMISSoftISP::xMakeBMP(pBuffer[1], vBmpBuffer2.data(), nWidth, nHeight, tDataSpec);

	memset(&stSpecAllOnsemiRCCBSpec, 0x00, sizeof(stSpecAllOnsemiRCCBSpec));

	//std::cout << "[AllDefectOnsemiRCCB] Version: " << pOnsemiRCCBDefect->GetVersion() << std::endl;
	_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]AllDefectOnsemiRCCB Version: %s"), pOnsemiRCCBDefect->GetVersion());
	AddLog(szLog, 1, m_nUnit, true);
	// Spec
	//m_DefectSpec
	int specCount = 0;
    stSpecAllOnsemiRCCBSpec.nBlockSizeHot = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];// 0;
	stSpecAllOnsemiRCCBSpec.nBlockSizeDark = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//11;
	stSpecAllOnsemiRCCBSpec.nBlockSizeBright = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//11;

	stSpecAllOnsemiRCCBSpec.nThresholdTypeHot = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//1;				// threshold type for hot defect
	stSpecAllOnsemiRCCBSpec.nThresholdTypeDark = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;				// threshold type for dark defect
	stSpecAllOnsemiRCCBSpec.nThresholdTypeBright = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;			// threshold type for bright defect

	stSpecAllOnsemiRCCBSpec.nThresholdTypeLineDefect = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//1;
	stSpecAllOnsemiRCCBSpec.nAlgorithmTypeLineDefect = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;

	stSpecAllOnsemiRCCBSpec.dDefectThresholdHot = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//400.0;		// threshold for hot defect		(dark image)
	stSpecAllOnsemiRCCBSpec.dDefectThresholdDark = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//10.0;		// threshold for dark defect	(mid-level image)
	stSpecAllOnsemiRCCBSpec.dDefectThresholdBright = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//10.0;		// threshold for bright defect	(mid-level image)

	stSpecAllOnsemiRCCBSpec.dDefectThresholdRowInDark = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//20;
	stSpecAllOnsemiRCCBSpec.dDefectThresholdRowInBright = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//20;
	stSpecAllOnsemiRCCBSpec.dDefectThresholdColumnInDark = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//100;
	stSpecAllOnsemiRCCBSpec.dDefectThresholdColumnInBright = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//50;
	stSpecAllOnsemiRCCBSpec.dDefectThresholdColumnFPN = g_clModelData[m_nUnit].m_DefectSpec[specCount++];//6;
	//stSpecAllOnsemiRCCBSpec.nDefectInCouplet = 2;
    //
    //Spec 제한--------------------------------------------------------------------
    //
	stSpecAllOnsemiRCCBSpec.nMaxHotDefectNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//126;				// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxDarkDefectNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//126;			// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxBrightDefectNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//126;			// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxHotCoupletNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//10;// 10;				// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxDarkCoupletNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//10;//10;			// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxBrightCoupletNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//10;//10;			// specification of the maximum number
	
    //
    //----------------------------------------------------------------------------------------------------------------------------
    //
	stSpecAllOnsemiRCCBSpec.nMaxHotClusterNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;				// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxDarkClusterNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;				// specification of the maximum number
	stSpecAllOnsemiRCCBSpec.nMaxBrightClusterNum = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;			// specification of the maximum number

	stSpecAllOnsemiRCCBSpec.nMaxRowDefectNumInDark = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;
	stSpecAllOnsemiRCCBSpec.nMaxRowDefectNumInBright = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;
	stSpecAllOnsemiRCCBSpec.nMaxColumnDefectNumInDark = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;
	stSpecAllOnsemiRCCBSpec.nMaxColumnDefectNumInBright = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//0;

	stSpecAllOnsemiRCCBSpec.nEnableChannel = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//1;
	//stSpecAllOnsemiRCCBSpec.nDefectInCouplet = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//2;
	stSpecAllOnsemiRCCBSpec.nDefectInCluster = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//2;
    stSpecAllOnsemiRCCBSpec.nDefectInClusterChannel = (int)g_clModelData[m_nUnit].m_DefectSpec[specCount++];//2

	//stSpecAllOnsemiRCCBSpec.dDefectThresholdColumnFPN = g_clModelData[m_nUnit].m_DefectSpec[specCount++];
    stSpecAllOnsemiRCCBSpec.nDefectType = EDefectKind_WhitePixel | EDefectKind_BlackPixel | EDefectKind_HotPixel |
		EDefectKind_WhiteCouplet | EDefectKind_BlackCouplet | EDefectKind_HotCouplet  | EDefectKind_WhiteCluster |
		EDefectKind_BlackCluster | EDefectKind_HotCluster;
	//tDataSpec.eOutMode = OUTMODE_BAYER_RGGB;
	//stSpecAllOnsemiRCCBSpec.nDefectInClusterChannel = 2;//nDefectInClusterChannel
	//
	for (i = 0; i < 14; i++)
	{
		g_clMesCommunication[m_nUnit].m_nMesDefectResult[i] = 1;
	}
	//dark , Bright , Hot defect이 각각 127개미만이고
	//Cluster개수가 0개 미만이면 pass
	//
	// Inspection
	bool bRet = false;
	bRet = pOnsemiRCCBDefect->InspectM((const BYTE**)pBuffer, nWidth, nHeight, stSpecAllOnsemiRCCBSpec, 
		tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, false, 2);
	if (bRet)
	{
		//Single Defect
		int nHotDefectCount = pOnsemiRCCBDefect->GetHotDefectCount();
		int nBrightDefectCount = pOnsemiRCCBDefect->GetBrightDefectCount();
		int nDarkDefectCount = pOnsemiRCCBDefect->GetDarkDefectCount();
		// Cluster
		int nHotClusterCount = pOnsemiRCCBDefect->GetHotDefectClusterCount();
		int nBrightClusterCount = pOnsemiRCCBDefect->GetBrightDefectClusterCount();
		int nDarkClusterCount = pOnsemiRCCBDefect->GetDarkDefectClusterCount();
		
		//--------------------------------------------------------------------------------------------
        g_clMandoInspLog[m_nUnit].m_LogDefectBright = nBrightDefectCount; 
        g_clMandoInspLog[m_nUnit].m_LogDefectDark = nDarkDefectCount; 
        g_clMandoInspLog[m_nUnit].m_LogDefectHot = nHotDefectCount;
		g_clMandoInspLog[m_nUnit].m_LogDefectBrightCluster = nHotClusterCount + pOnsemiRCCBDefect->GetBrightDefectClusterColorCount();
		g_clMandoInspLog[m_nUnit].m_LogDefectDarkCluster = nBrightClusterCount + pOnsemiRCCBDefect->GetDarkDefectClusterColorCount();
		g_clMandoInspLog[m_nUnit].m_LogDefectHotCluster = nDarkClusterCount;
		g_clMandoInspLog[m_nUnit].m_LogDefectDarkHorLine = pOnsemiRCCBDefect->GetDefectRowLineCountInDark();
		g_clMandoInspLog[m_nUnit].m_LogDefectDarkVerLine = pOnsemiRCCBDefect->GetDefectColumnLineCountInDark();
		g_clMandoInspLog[m_nUnit].m_LogDefectBrightHorLine = pOnsemiRCCBDefect->GetDefectRowLineCountInBright();
		g_clMandoInspLog[m_nUnit].m_LogDefectBrightVerLine = pOnsemiRCCBDefect->GetDefectColumnLineCountInBright();
		//g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN = pOnsemiRCCBDefect->GetDefectColumnFPNCount();
		int nCFPNcount = pOnsemiRCCBDefect->GetDefectColumnFPNCount();
		for (i = 0; i < nCFPNcount; i++)
		{
			const TDefectResult* pColumnFPNResult = pOnsemiRCCBDefect->GetDefectColumnFPNResult(i);
			g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[i] = pColumnFPNResult->dValue;
		}
		//
		//
		g_clMesCommunication[m_nUnit].m_nMesDefect[0] = g_clMandoInspLog[m_nUnit].m_LogDefectBright;
		g_clMesCommunication[m_nUnit].m_nMesDefect[1] = g_clMandoInspLog[m_nUnit].m_LogDefectDark;
		g_clMesCommunication[m_nUnit].m_nMesDefect[2] = g_clMandoInspLog[m_nUnit].m_LogDefectHot;
		g_clMesCommunication[m_nUnit].m_nMesDefect[3] = g_clMandoInspLog[m_nUnit].m_LogDefectBrightCluster;
		g_clMesCommunication[m_nUnit].m_nMesDefect[4] = g_clMandoInspLog[m_nUnit].m_LogDefectDarkCluster;
		g_clMesCommunication[m_nUnit].m_nMesDefect[5] = g_clMandoInspLog[m_nUnit].m_LogDefectHotCluster;
		g_clMesCommunication[m_nUnit].m_nMesDefect[6] = g_clMandoInspLog[m_nUnit].m_LogDefectDarkHorLine;
		g_clMesCommunication[m_nUnit].m_nMesDefect[7] = g_clMandoInspLog[m_nUnit].m_LogDefectDarkVerLine;
		g_clMesCommunication[m_nUnit].m_nMesDefect[8] = g_clMandoInspLog[m_nUnit].m_LogDefectBrightHorLine;
		g_clMesCommunication[m_nUnit].m_nMesDefect[9] = g_clMandoInspLog[m_nUnit].m_LogDefectBrightVerLine;
		//
		g_clMesCommunication[m_nUnit].m_nMesDefect[10] = g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[1];//Red
		g_clMesCommunication[m_nUnit].m_nMesDefect[11] = g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[0];//Cr
		g_clMesCommunication[m_nUnit].m_nMesDefect[12] = g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[3];//Cb
		g_clMesCommunication[m_nUnit].m_nMesDefect[13] = g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[2];//Blue
		//Red Cr Cb Blue 
		
		//
		if (g_clMandoInspLog[m_nUnit].m_LogDefectHot > stSpecAllOnsemiRCCBSpec.nMaxHotDefectNum)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] Hot Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectHot, stSpecAllOnsemiRCCBSpec.nMaxHotDefectNum);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect Hot NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect Hot :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectHot);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[2] = 0;
		}
		if (g_clMandoInspLog[m_nUnit].m_LogDefectDark > stSpecAllOnsemiRCCBSpec.nMaxDarkDefectNum)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] Dark Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectDark, stSpecAllOnsemiRCCBSpec.nMaxDarkDefectNum);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect Dark NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect Dark :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectDark);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[1] = 0;
		}
		if (g_clMandoInspLog[m_nUnit].m_LogDefectBright > stSpecAllOnsemiRCCBSpec.nMaxBrightDefectNum)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] Bright Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectBright, stSpecAllOnsemiRCCBSpec.nMaxBrightDefectNum);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect Bright NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect Bright :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectBright);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[0] = 0;
		}
		//
		if (g_clMandoInspLog[m_nUnit].m_LogDefectHotCluster > stSpecAllOnsemiRCCBSpec.nMaxHotClusterNum)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] HotCluster Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectHotCluster, stSpecAllOnsemiRCCBSpec.nMaxHotClusterNum);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect HotCluster NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect HotCluster :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectHotCluster);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[5] = 0;
		}
		
		if (g_clMandoInspLog[m_nUnit].m_LogDefectDarkCluster > stSpecAllOnsemiRCCBSpec.nMaxDarkClusterNum)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] DarkCluster Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectDarkCluster, stSpecAllOnsemiRCCBSpec.nMaxDarkClusterNum);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect DarkCluster NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect DarkCluster :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectDarkCluster);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[4] = 0;
		}
		if (g_clMandoInspLog[m_nUnit].m_LogDefectBrightCluster > stSpecAllOnsemiRCCBSpec.nMaxBrightClusterNum)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] BrightCluster Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectBrightCluster, stSpecAllOnsemiRCCBSpec.nMaxBrightClusterNum);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect BrightCluster NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect BrightCluster :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectBrightCluster);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[3] = 0;
		}
		//
		if (g_clMandoInspLog[m_nUnit].m_LogDefectDarkHorLine > 0)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] DarkHorLine Spec Out %d [%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectDarkHorLine, 0);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect DarkHorLine NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect DarkHorLine :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectDarkHorLine);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[6] = 0;
		}
		if (g_clMandoInspLog[m_nUnit].m_LogDefectDarkVerLine > 0)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] DarkDarkVerLine Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectDarkVerLine, 0);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect DarkDarkVerLine NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect DarkDarkVerLine :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectDarkVerLine);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[7] = 0;
		}
		if (g_clMandoInspLog[m_nUnit].m_LogDefectBrightHorLine > 0)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] BrightHorLine Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectBrightHorLine, 0);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect BrightHorLine NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect BrightHorLine :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectBrightHorLine);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[8] = 0;
		}
		if (g_clMandoInspLog[m_nUnit].m_LogDefectBrightVerLine > 0)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] BrightVerLine Spec Out %.1lf [%d]"), g_clMandoInspLog[m_nUnit].m_LogDefectBrightVerLine, 0);
			g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect BrightVerLine NG]");

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect BrightVerLine :%.1lf]"), g_clMandoInspLog[m_nUnit].m_LogDefectBrightVerLine);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}
			AddLog(szLog, 0, m_nUnit);
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			g_clMesCommunication[m_nUnit].m_nMesDefectResult[9] = 0;
		}
		//
		for (i = 0; i < nCFPNcount; i++)		//나중에 4개추가
		{
			if (g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[i] > stSpecAllOnsemiRCCBSpec.dDefectThresholdColumnFPN)
			{
				_stprintf_s(szLog, SIZE_OF_1K, _T("	[Defect] ColumnFPN-%d Spec Out %.1lf [%1lf]"), i, g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[i], stSpecAllOnsemiRCCBSpec.dDefectThresholdColumnFPN);
				g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [Defect ColumnFPN NG]");

				if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
				{
					g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [Defect ColumnFPN-%d :%.1lf]"), i, g_clMandoInspLog[m_nUnit].m_LogDefectColumnFPN[i]);
					g_clMandoInspLog[m_nUnit].m_nNGCnt++;
				}
				AddLog(szLog, 0, m_nUnit);
				g_clMandoInspLog[m_nUnit].m_bInspRes = false;
				g_clMesCommunication[m_nUnit].m_nMesDefectResult[10+i] = 0;
			}
		}

		
		//
		//
		for (i = 0; i < 14; i++)
		{
			if (g_clMesCommunication[m_nUnit].m_nMesDefectResult[i] == 0)
			{
				g_clMandoInspLog[m_nUnit].m_bInspRes = false;
			}
		}
		_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]Single Count Hot: %d"), nHotDefectCount);
		AddLog(szLog, 1, m_nUnit, true);
		_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]Single Count Birght: %d"), nBrightDefectCount);
		AddLog(szLog, 1, m_nUnit, true);
		_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]Single Count Dark: %d"), nDarkDefectCount);
		AddLog(szLog, 1, m_nUnit, true);
		_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]Cluster Count Hot: %d"), nHotClusterCount);
		AddLog(szLog, 1, m_nUnit, true);
		_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]Cluster Count Birght: %d"), nBrightClusterCount);
		AddLog(szLog, 1, m_nUnit, true);
		_stprintf_s(szLog, SIZE_OF_1K, _T("[Defect]Cluster Count Dark: %d"), nDarkClusterCount);
		AddLog(szLog, 1, m_nUnit, true);


        if (nHotDefectCount > stSpecAllOnsemiRCCBSpec.nMaxHotDefectNum || 
            nBrightDefectCount > stSpecAllOnsemiRCCBSpec.nMaxDarkDefectNum ||
            nDarkDefectCount > stSpecAllOnsemiRCCBSpec.nMaxBrightDefectNum)
		{
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
		}
        if (nHotClusterCount >    stSpecAllOnsemiRCCBSpec.nMaxHotCoupletNum ||
            nBrightClusterCount > stSpecAllOnsemiRCCBSpec.nMaxDarkCoupletNum ||
            nDarkClusterCount >   stSpecAllOnsemiRCCBSpec.nMaxBrightCoupletNum)
		
		{
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;
		}

		


		int i = 0;
		int count = 0;

		//count = pOnsemiRCCBDefect->GetDarkDefectCount();
		//std::cout << "[AllDefectOnsemiRCCB] Dark Defect Count=" << count << std::endl;

		for (i = 0; i < count; i++)
		{
			const TDefectResult* singleDefect = pOnsemiRCCBDefect->GetDarkDefectResult(i);
			if (singleDefect)
			{
				//std::cout << "[AllDefectOnsemiRCCB] x=" << singleDefect->ptPos.x << " y=" << singleDefect->ptPos.y << std::endl;
				cvRectangle(cvImgDefect1, cvPoint(singleDefect->ptPos.x, singleDefect->ptPos.y), cvPoint(singleDefect->ptPos.x, singleDefect->ptPos.y), CV_RGB(255, 0, 0));
			}
		}
		//count = pOnsemiRCCBDefect->GetBrightDefectCount();
		//std::cout << "[AllDefectOnsemiRCCB] Bright Defect Count=" << count << std::endl;

		for (i = 0; i < count; i++)
		{
			const TDefectResult* singleDefect = pOnsemiRCCBDefect->GetBrightDefectResult(i);
			if (singleDefect)
			{
				//std::cout << "[AllDefectOnsemiRCCB] x=" << singleDefect->ptPos.x << " y=" << singleDefect->ptPos.y << std::endl;

				cvRectangle(cvImgDefect1, cvPoint(singleDefect->ptPos.x, singleDefect->ptPos.y), cvPoint(singleDefect->ptPos.x, singleDefect->ptPos.y), CV_RGB(255, 0, 0));
			}
		}
		//count = pOnsemiRCCBDefect->GetHotDefectCount();
		//std::cout << "[AllDefectOnsemiRCCB] Hot Defect Count=" << count << std::endl;

		for (i = 0; i < count; i++)
		{
			const TDefectResult* singleDefect = pOnsemiRCCBDefect->GetHotDefectResult(i);
			if (singleDefect)
			{
				//std::cout << "[AllDefectOnsemiRCCB] x=" << singleDefect->ptPos.x << " y=" << singleDefect->ptPos.y << std::endl;

				cvRectangle(cvImgDefect2, cvPoint(singleDefect->ptPos.x, singleDefect->ptPos.y), cvPoint(singleDefect->ptPos.x, singleDefect->ptPos.y), CV_RGB(255, 0, 0));
			}
		}


		//count = pOnsemiRCCBDefect->GetDarkDefectClusterCount();
		//std::cout << "[AllDefectOnsemiRCCB] Dark Cluster Count=" << count << std::endl;

		for (i = 0; i < count; i++)
		{
			const TBlobResult* clusterDefect = pOnsemiRCCBDefect->GetDarkDefectClusterResult(i);

			if (clusterDefect)
			{
				//std::cout << "[AllDefectOnsemiRCCB] l=" << clusterDefect->rROI.left << " t=" << clusterDefect->rROI.top << " r=" << clusterDefect->rROI.right << " b=" << clusterDefect->rROI.bottom << std::endl;
				cvRectangle(cvImgDefect1, cvPoint(clusterDefect->rROI.left, clusterDefect->rROI.top), cvPoint(clusterDefect->rROI.right, clusterDefect->rROI.bottom), CV_RGB(255, 0, 0));
			}
		}
		//count = pOnsemiRCCBDefect->GetBrightDefectClusterCount();
		//std::cout << "[AllDefectOnsemiRCCB] Bright Cluster Count=" << count << std::endl;

		for (i = 0; i < count; i++)
		{
			const TBlobResult* clusterDefect = pOnsemiRCCBDefect->GetBrightDefectClusterResult(i);

			if (clusterDefect)
			{
				//std::cout << "[AllDefectOnsemiRCCB] l=" << clusterDefect->rROI.left << " t=" << clusterDefect->rROI.top << " r=" << clusterDefect->rROI.right << " b=" << clusterDefect->rROI.bottom << std::endl;

				cvRectangle(cvImgDefect1, cvPoint(clusterDefect->rROI.left, clusterDefect->rROI.top), cvPoint(clusterDefect->rROI.right, clusterDefect->rROI.bottom), CV_RGB(255, 0, 0));
			}
		}

		//count = pOnsemiRCCBDefect->GetHotDefectClusterCount();
		//std::cout << "[AllDefectOnsemiRCCB] Hot Cluster Count=" << count << std::endl;

		for (i = 0; i < count; i++)
		{
			const TBlobResult* clusterDefect = pOnsemiRCCBDefect->GetHotDefectClusterResult(i);

			if (clusterDefect)
			{
				//std::cout << "[AllDefectOnsemiRCCB] l=" << clusterDefect->rROI.left << " t=" << clusterDefect->rROI.top << " r=" << clusterDefect->rROI.right << " b=" << clusterDefect->rROI.bottom << std::endl;

				cvRectangle(cvImgDefect2, cvPoint(clusterDefect->rROI.left, clusterDefect->rROI.top), cvPoint(clusterDefect->rROI.right, clusterDefect->rROI.bottom), CV_RGB(255, 0, 0));
			}
		}

		if (bAutoMode == false)
		{
			//수동검사일때
			cvShowImage("cvImgDefect1", cvImgDefect1);
			cvShowImage("cvImgDefect2", cvImgDefect2);
			cvWaitKey(0);
			cvReleaseImage(&cvImgDefect1);
			cvReleaseImage(&cvImgDefect2);
			
		}
	}
	//tDataSpec.eOutMode = OUTMODE_BAYER_GRBG;
    g_SaveLGITLog(m_nUnit, "Defect", pOnsemiRCCBDefect->GetLogHeader(), pOnsemiRCCBDefect->GetLogData());
	return bRet;
}



//-----------------------------------------------------------------------------
//
//	UNIFORMITY 검사
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_Uniformity(BYTE* img, bool bAutoMode, bool bUse8BitOnly)
{
	bool bRes = false;
	int i = 0;
	int nResult = R_RESULT_PASS;
	TCHAR szLog[SIZE_OF_1K];

	int nWidth = g_clModelData[m_nUnit].m_nWidth;
	int nHeight = g_clModelData[m_nUnit].m_nHeight;
	TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;

	TColorUniformitySpec tColorUniformitySpec;
	memset(&tColorUniformitySpec, 0x00, sizeof(TColorUniformitySpec));
	//std::cout << std::endl;
	//std::cout << __FUNCTION__ << std::endl;

	//GetImageData(MODEL_NIO, tDataSpec, stImgInfo);

	// Image buffers
	//std::vector<BYTE> vFrameBuffer(stImgInfo.nSensorHeight * stImgInfo.nSensorWidth * 2);

	

	//----------------------------------------------------------------------
	// Spec - Color Uniformity
	//----------------------------------------------------------------------
    int specCount = 0;
    tColorUniformitySpec.nGridSizeX = g_clModelData[m_nUnit].m_UniformSpec[specCount++];// nWidth / 10;      //ui로
	tColorUniformitySpec.nGridSizeY = g_clModelData[m_nUnit].m_UniformSpec[specCount++];//nHeight / 10;      //ui로
	tColorUniformitySpec.nTypicalValueType = TypicalValue_Mean;      //ui로
	tColorUniformitySpec.nColorSpaceType = g_clModelData[m_nUnit].m_UniformSpec[specCount++];//ColorSpace_RGB;
	tColorUniformitySpec.nUseOverlap = 1;
    tColorUniformitySpec.nMaxDiffType = g_clModelData[m_nUnit].m_UniformSpec[specCount++];//0;                //ui로
	//m_stColorUniformitySpec.
	// Image buffers
	std::vector<BYTE> vBmpBuffer(nWidth * nHeight * 3, 0);
	std::vector<BYTE> vBuffer(nWidth * nHeight, 0);

	IplImage *cvImg = cvCreateImage(cvSize(nWidth, nHeight), 8, 3);
	cvImg->imageData = (char*)vBmpBuffer.data();

	ACMISSoftISP::xMakeBMP((BYTE*)img, vBmpBuffer.data(), nWidth, nHeight, tDataSpec);

	std::shared_ptr<CACMISShadingColorUniformity> m_pColorUniformity = std::make_shared<CACMISShadingColorUniformity>();

	//std::cout << "[Color Uniformity] Version = " << m_pColorUniformity->GetVersion() << std::endl;

	_stprintf_s(szLog, SIZE_OF_1K, _T("[Color Uniformity]Color Shading Version: %s"), m_pColorUniformity->GetVersion());
	AddLog(szLog, 1, m_nUnit, true);
	//Inspection

	if (!m_pColorUniformity->Inspect(img, nWidth, nHeight, tColorUniformitySpec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, tDataSpec.nBlackLevel, bUse8BitOnly))
	{
		cvReleaseImage(&cvImg);

		//std::cout << "[Color Uniformity] Inspection Fail! " << std::endl;
        _stprintf_s(szLog, SIZE_OF_1K, _T("[Color Uniformity] Inspection Fail!"));
        AddLog(szLog, 1, m_nUnit, true);
		return FALSE;
	}
	CvFont cvfont;
	CvPoint pt;
	int scale = (nWidth > 640 ? 1 : 2);
	double nFontSize = 0.5 / scale;
	char strTmp[1024];

	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);

	//Result
	for (int i = 0; i < m_pColorUniformity->GetInspectionRegionCount(); i++)
	{
		const TColorUniformityResult* pResult = m_pColorUniformity->GetInspectionResult(i);
		if (pResult == NULL)
			continue;
        if (i == 33)
        {
            g_clMandoInspLog[m_nUnit].m_Log_CU_LT_Delta_RG = pResult->dMaxDiffRG;
            g_clMandoInspLog[m_nUnit].m_Log_CU_LT_Delta_RB = pResult->dMaxDiffRB;
            g_clMandoInspLog[m_nUnit].m_Log_CU_LT_Delta_BG = pResult->dMaxDiffBG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[0] = g_clMandoInspLog[m_nUnit].m_Log_CU_LT_Delta_RG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[1] = g_clMandoInspLog[m_nUnit].m_Log_CU_LT_Delta_RB;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[2] = g_clMandoInspLog[m_nUnit].m_Log_CU_LT_Delta_BG;
        }
        else if (i == 63)
        {
            g_clMandoInspLog[m_nUnit].m_Log_CU_RT_Delta_RG = pResult->dMaxDiffRG;
            g_clMandoInspLog[m_nUnit].m_Log_CU_RT_Delta_RB = pResult->dMaxDiffRB;
            g_clMandoInspLog[m_nUnit].m_Log_CU_RT_Delta_BG = pResult->dMaxDiffBG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[3] = g_clMandoInspLog[m_nUnit].m_Log_CU_RT_Delta_RG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[4] = g_clMandoInspLog[m_nUnit].m_Log_CU_RT_Delta_RB;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[5] = g_clMandoInspLog[m_nUnit].m_Log_CU_RT_Delta_BG;
        }
        else if (i == 36)
        {
            g_clMandoInspLog[m_nUnit].m_Log_CU_LB_Delta_RG = pResult->dMaxDiffRG;
            g_clMandoInspLog[m_nUnit].m_Log_CU_LB_Delta_RB = pResult->dMaxDiffRB;
            g_clMandoInspLog[m_nUnit].m_Log_CU_LB_Delta_BG = pResult->dMaxDiffBG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[6] = g_clMandoInspLog[m_nUnit].m_Log_CU_LB_Delta_RG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[7] = g_clMandoInspLog[m_nUnit].m_Log_CU_LB_Delta_RB;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[8] = g_clMandoInspLog[m_nUnit].m_Log_CU_LB_Delta_BG;
        }
        else if (i == 66)
        {
            g_clMandoInspLog[m_nUnit].m_Log_CU_RB_Delta_RG = pResult->dMaxDiffRG;
            g_clMandoInspLog[m_nUnit].m_Log_CU_RB_Delta_RB = pResult->dMaxDiffRB;
            g_clMandoInspLog[m_nUnit].m_Log_CU_RB_Delta_BG = pResult->dMaxDiffBG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[9] = g_clMandoInspLog[m_nUnit].m_Log_CU_RB_Delta_RG;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[10] = g_clMandoInspLog[m_nUnit].m_Log_CU_RB_Delta_RB;
			g_clMesCommunication[m_nUnit].m_nMesColorUniformity[11] = g_clMandoInspLog[m_nUnit].m_Log_CU_RB_Delta_BG;
        }
		// Check Color Uniformity RG
		if (tColorUniformitySpec.dSpecMaxDiffRG > pResult->dMaxDiffRG)
			nResult = R_RESULT_FAIL;
		// Check Color Uniformity RB
		if (tColorUniformitySpec.dSpecMaxDiffRB > pResult->dMaxDiffRB)
			nResult = R_RESULT_FAIL;
		// Check Color Uniformity BG
		if (tColorUniformitySpec.dSpecMaxDiffBG > pResult->dMaxDiffBG)
			nResult = R_RESULT_FAIL;

		//Logging
		/*printf("[Color Uniformity] %.4f/%.4f/%.4f, Block(%d,%d) Ref Block(%d,%d)\n",
			pResult->dMaxDiffRG, pResult->dMaxDiffRB, pResult->dMaxDiffBG,
			pResult->nMaxBlockX, pResult->nMaxBlockY, pResult->nRefBlockX, pResult->nRefBlockY);*/
       
		//Graphic
		RECT rtROI;

		rtROI.left = max(pResult->nMaxBlockX * tColorUniformitySpec.nGridSizeX, 0);
		rtROI.top = max(pResult->nMaxBlockY * tColorUniformitySpec.nGridSizeY, 0);
		rtROI.right = min(rtROI.left + tColorUniformitySpec.nGridSizeX, (LONG)nWidth - 1);
		rtROI.bottom = min(rtROI.top + tColorUniformitySpec.nGridSizeY, (LONG)nHeight - 1);

		cvRectangle(cvImg, cvPoint(rtROI.left, rtROI.top), cvPoint(rtROI.right, rtROI.bottom), CV_RGB(128, 128, 128));

		pt.x = (int)rtROI.left + tColorUniformitySpec.nGridSizeX / 6;
		pt.y = (int)rtROI.top + tColorUniformitySpec.nGridSizeY / 3;
		sprintf_s(strTmp, "RG:%.4f", pResult->dMaxDiffRG);
		cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);

		pt.x = (int)rtROI.left + tColorUniformitySpec.nGridSizeX / 6;
		pt.y = (int)rtROI.top + tColorUniformitySpec.nGridSizeY / 2;
		sprintf_s(strTmp, "RB:%.4f", pResult->dMaxDiffRB);
		cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);

		pt.x = (int)rtROI.left + tColorUniformitySpec.nGridSizeX / 6;
		pt.y = (int)rtROI.top + tColorUniformitySpec.nGridSizeY * 2 / 3;
		sprintf_s(strTmp, "BG:%.4f", pResult->dMaxDiffBG);
		cvPutText(cvImg, strTmp, pt, &cvfont, CV_BLUE);
	}

	RECT rect;
	RECT rectRef;

	const TColorUniformityResult maxResult = m_pColorUniformity->GetInspectionMaxResult();

	rect.left = max(maxResult.nMaxBlockX * tColorUniformitySpec.nGridSizeX, 0);
	rect.top = max(maxResult.nMaxBlockY * tColorUniformitySpec.nGridSizeY, 0);
	rect.right = min(rect.left + tColorUniformitySpec.nGridSizeX, (LONG)nWidth - 1);
	rect.bottom = min(rect.top + tColorUniformitySpec.nGridSizeY, (LONG)nHeight - 1);
	cvRectangle(cvImg, cvPoint(rect.left, rect.top), cvPoint(rect.right, rect.bottom), CV_RGB(255, 0, 0));

	rectRef.left = max(maxResult.nRefBlockX * tColorUniformitySpec.nGridSizeX, 0);
	rectRef.top = max(maxResult.nRefBlockY * tColorUniformitySpec.nGridSizeY, 0);
	rectRef.right = min(rectRef.left + tColorUniformitySpec.nGridSizeX, (LONG)nWidth - 1);
	rectRef.bottom = min(rectRef.top + tColorUniformitySpec.nGridSizeY, (LONG)nHeight - 1);
	cvRectangle(cvImg, cvPoint(rectRef.left, rectRef.top), cvPoint(rectRef.right, rectRef.bottom), CV_RGB(255, 255, 0));

	/*printf("[Color Uniformity] Max=%.4f/%.4f/%.4f, Block(%d,%d) Ref Block(%d,%d)",
		maxResult.dMaxDiffRG, maxResult.dMaxDiffRB, maxResult.dMaxDiffBG,
		maxResult.nMaxBlockX, maxResult.nMaxBlockY, maxResult.nRefBlockX, maxResult.nRefBlockY);*/

    _stprintf_s(szLog, SIZE_OF_1K, _T("[Color Uniformity] % .4f / %.4f / %.4f"), maxResult.dMaxDiffRG, maxResult.dMaxDiffRB, maxResult.dMaxDiffBG);
    AddLog(szLog, 1, m_nUnit, true);
    _stprintf_s(szLog, SIZE_OF_1K, _T("[Color Uniformity] Block(%d,%d)"), maxResult.nMaxBlockX, maxResult.nMaxBlockY);
    AddLog(szLog, 1, m_nUnit, true);
    _stprintf_s(szLog, SIZE_OF_1K, _T("[Color Uniformity] Ref Block(%d,%d)"), maxResult.nRefBlockX, maxResult.nRefBlockY);
    AddLog(szLog, 1, m_nUnit, true);
	if (bAutoMode == false)
	{
		//cvShowImage("Color Uniformity", cvImg);
		//cvWaitKey(0);
	}
	cvReleaseImage(&cvImg);
    if (nResult == R_RESULT_PASS)
    {
        bRes = true;
    }
    g_SaveLGITLog(m_nUnit, "ColorUniformity", m_pColorUniformity->GetLogHeader(), m_pColorUniformity->GetLogData());
	return bRes;
}



//-----------------------------------------------------------------------------
//
//	STAIN 검사(BY PRI)
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_OpenStain(IplImage* img, bool bAutoMode)
{
	bool bRes = false;
	return bRes;

}


CString CPRIFunc_Insp::SetDir_Check(CString sPath)
{
	CString sRtn = _T(""), FolderName = _T("");
	CFileFind finder;
	BOOL IsFind;

	SYSTEMTIME time;
	::GetLocalTime(&time);

	FolderName.Format(_T("%s\\%04d%02d"), (TCHAR*)(LPCTSTR)sPath, time.wYear, time.wMonth);
	IsFind = finder.FindFile(FolderName);
	if (!IsFind)
	{
		CreateDirectory(FolderName, NULL);
	}

	sRtn.Format(_T("%s\\%04d%02d\\%02d"), (TCHAR*)(LPCTSTR)sPath, time.wYear, time.wMonth, time.wDay);
	IsFind = finder.FindFile(sRtn);
	if (!IsFind)
	{
		CreateDirectory(sRtn, NULL);
	}

	sRtn.Format(_T("%s\\%04d%02d\\%02d\\"), (TCHAR*)(LPCTSTR)sPath, time.wYear, time.wMonth, time.wDay);

	return sRtn;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_OpenStainLGIT(unsigned char* pImgBuff, bool bAutoMode/* = false*/)
{
	TDATASPEC tDataSpec;

	// Spec information
	TStainSpec tStainSpec;

	//GetImageData(MODEL_NIO, tDataSpec, stImgInfo);

	tDataSpec.eDataFormat = DATAFORMAT_BAYER_12BIT;
	tDataSpec.eOutMode = OUTMODE_BAYER_BGGR;// OUTMODE_BAYER_RGGB;//OUTMODE_BAYER_GRBG;
	tDataSpec.eSensorType = SENSORTYPE_RCCB;
	tDataSpec.nBlackLevel = 0;

	// Image buffers
	//std::vector<BYTE> vFrameBuffer(stImgInfo.nSensorHeight * stImgInfo.nSensorWidth * 2);

	memset(&tStainSpec, 0x00, sizeof(TStainSpec));

	//----------------------------------------------------------------------
	// Spec - BlackSpot
	//----------------------------------------------------------------------
	tStainSpec.stSpecBlackSpot.nBlockWidth = 32;
	tStainSpec.stSpecBlackSpot.nBlockHeight = 32;
	tStainSpec.stSpecBlackSpot.nClusterSize = 5;
	tStainSpec.stSpecBlackSpot.nDefectInCluster = 5;
	tStainSpec.stSpecBlackSpot.dDefectRatio = 0.45000;
	tStainSpec.stSpecBlackSpot.nMaxSingleDefectNum = 100000;	// noise image
	tStainSpec.stSpecBlackSpot.tCircleSpec.bEnableCircle = false;
	tStainSpec.stSpecBlackSpot.tCircleSpec.nPosOffsetX = 5;
	tStainSpec.stSpecBlackSpot.tCircleSpec.nPosOffsetY = 5;
	tStainSpec.stSpecBlackSpot.tCircleSpec.dRadiusRatioX = 0.45;
	tStainSpec.stSpecBlackSpot.tCircleSpec.dRadiusRatioY = 0.45;

	//----------------------------------------------------------------------
	// Spec - LCB
	//----------------------------------------------------------------------
	// !
	tStainSpec.stSpecLCB.dCenterThreshold = g_clModelData[m_nUnit].m_dStainLsbCenter;//29.0;
	// !
	tStainSpec.stSpecLCB.dCornerThreshold = g_clModelData[m_nUnit].m_dStainLsbCorner;//65.0;
	// !
	tStainSpec.stSpecLCB.dEdgeThreshold = g_clModelData[m_nUnit].m_dStainLsbEdge;//80.0;
	tStainSpec.stSpecLCB.nMaxSingleDefectNum = 50000;
	tStainSpec.stSpecLCB.nMinDefectWidthHeight = 10;
	tStainSpec.stSpecLCB.tCircleSpec.bEnableCircle = false;
	tStainSpec.stSpecLCB.tCircleSpec.nPosOffsetX = 5;
	tStainSpec.stSpecLCB.tCircleSpec.nPosOffsetY = 5;
	tStainSpec.stSpecLCB.tCircleSpec.dRadiusRatioX = 0.45;
	tStainSpec.stSpecLCB.tCircleSpec.dRadiusRatioY = 0.45;

	//----------------------------------------------------------------------
	// Spec - Ymean
	//----------------------------------------------------------------------
	tStainSpec.stSpecYmean.nDefectBlockSize = 32;
	tStainSpec.stSpecYmean.nEdgeSize = 100;
	// !
	tStainSpec.stSpecYmean.fCenterThreshold = g_clModelData[m_nUnit].m_dStainYMeanCenter;//3.0;
	// !
	tStainSpec.stSpecYmean.fEdgeThreshold = g_clModelData[m_nUnit].m_dStainYMeanEdge;//6.0;
	// !
	tStainSpec.stSpecYmean.fCornerThreshold = g_clModelData[m_nUnit].m_dStainYMeanCorner;//6.0;
	tStainSpec.stSpecYmean.nLscBlockSize = 128;
	tStainSpec.stSpecYmean.tCircleSpec.bEnableCircle = false;
	tStainSpec.stSpecYmean.tCircleSpec.nPosOffsetX = 5;
	tStainSpec.stSpecYmean.tCircleSpec.nPosOffsetY = 5;
	tStainSpec.stSpecYmean.tCircleSpec.dRadiusRatioX = 0.45;
	tStainSpec.stSpecYmean.tCircleSpec.dRadiusRatioY = 0.45;

	//----------------------------------------------------------------------
	// Inspect Main Camera
	//----------------------------------------------------------------------

	// Load image
	//LoadImageData(vFrameBuffer.data(), _IMG_NIO_Stain_MAIN_01_raw);

	// Inspect
	if(this->InspectStain(tDataSpec, tStainSpec, pImgBuff, g_clModelData[m_nUnit].m_nWidth, g_clModelData[m_nUnit].m_nHeight, true, true, true, bAutoMode) == 0)
		return true;
	else
		return false;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
int CPRIFunc_Insp::InspectStain(TDATASPEC &tDataSpec, TStainSpec &tStainSpec, unsigned char *pBuffer, int nWidth, int nHeight, bool bEnableBlackSpot/* = true*/, bool bEnableLCB/* = true*/, bool bEnableRYUmean/* = true*/, bool bAutoMode/* = false*/)
{
	
	return 1;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
int CPRIFunc_Insp::InspectBlackSpotContrast(const BYTE* pBuffer, int nWidth, int nHeight, TBlackSpotContrast& _Spec, EDATAFORMAT dataFormat, EOUTMODE outMode, ESENSORTYPE sensorType, int nBlackLevel, IplImage *cvImgBlackSpot)
{
	
	return 1;
}
//-----------------------------------------------------------------------------
//
//	이물(stain) 검사
//
//-----------------------------------------------------------------------------

bool CPRIFunc_Insp::func_Insp_Stain(BYTE* img, bool bAutoMode, bool bUse8BitOnly)
{
    int nBlackLevel = 0;
    int nWidth = g_clModelData[m_nUnit].m_nWidth;
    int nHeight = g_clModelData[m_nUnit].m_nHeight;
    TDATASPEC& tDataSpec = g_clLaonGrabberWrapper[m_nUnit].dTDATASPEC_n;
    //
    IplImage *cvImg = cvCreateImage(cvSize(nWidth, nHeight), 8, 3); // bmp for display

    //
	BlackSpotInsp((BYTE*)img, nWidth, nHeight, tDataSpec, cvImg);// g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.imageItp);
    LCBInsp((BYTE*)img, nWidth, nHeight, tDataSpec, cvImg);//g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.imageItp);
    Blemish_YmeanInsp((BYTE*)img, nWidth, nHeight, tDataSpec, cvImg);//g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.imageItp);
	//
	
    return true;
}

int CPRIFunc_Insp::InspectStain(BYTE* stainImg, bool bAutoMode)
{
    SYSTEMTIME time;
    ::GetLocalTime(&time);

    CFileFind finder;
    BOOL IsFind;
    CString FolderName;
    CString rawName;
    //stainImg = Raw 이미지
    FolderName.Format("%s\\%04d%02d\\%02d", IMG_DIR, time.wYear, time.wMonth, time.wDay);

    IsFind = finder.FindFile(FolderName);
    if (!IsFind)
    {
        FolderName.Format("%s", BASE_DIR);
        IsFind = finder.FindFile(FolderName);
        if (!IsFind)
        {
            CreateDirectory(FolderName, NULL);
        }

        FolderName.Format("%s", IMG_DIR);
        IsFind = finder.FindFile(FolderName);
        if (!IsFind)
        {
            CreateDirectory(FolderName, NULL);
        }

        FolderName.Format("%s\\%04d", IMG_DIR, time.wYear, time.wYear);
        CreateDirectory(FolderName, NULL);

        FolderName.Format("%s\\%04d%02d", IMG_DIR, time.wYear, time.wMonth);
        CreateDirectory(FolderName, NULL);

        FolderName.Format("%s\\%04d%02d\\%02d", IMG_DIR, time.wYear, time.wMonth, time.wDay);
        CreateDirectory(FolderName, NULL);
    }
    SYSTEMTIME SysTime;
    ::GetLocalTime(&SysTime);

    finder.Close();

    CString		fileName;
    fileName.Format("%s\\%s_Stain_%04d%02d%02d%02d%02d%02d.bmp", FolderName, g_clMandoInspLog[m_nUnit].m_sBarcodeID, SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
    rawName.Format("%s\\%s_Stain_%04d%02d%02d%02d%02d%02d.raw", FolderName, g_clMandoInspLog[m_nUnit].m_sBarcodeID, SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
    //if(!bAutoMode && false)
    {
        CFile savefile;
        CFileException  e;

        if (!savefile.Open(rawName, CFile::modeCreate | CFile::modeWrite, &e))
        {
            AfxMessageBox("File open fail:" + e.m_cause);
        }
        savefile.Write(stainImg, g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.nFrameImageSize);
        savefile.Close();
    }
    CString sTemp = "";
    //========================================================================================
    char	sIniPath[1000];
    wsprintf(sIniPath, "%s\\stainSpec.ini", DATA_DIR, g_clSysData.m_szModelName); //D:\SETUP\TESLA_SIDE\Data\stainSpec.ini
    CMapData spec;
    GetIni(sIniPath, spec);//bEnableCircle = wide = 1, side = 0
                           //=========================================================================================
    int nBlackLevel = 64; // Eliminate black level of sensor when you grab a frame.
    IplImage *cvImageObject = cvCreateImage(cvSize(g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.nWidth, g_clLaonGrabberWrapper[m_nUnit].m_stMIUDevice.nHeight), 8, 3); // bmp for display
    cvImageObject->imageData = (char*)g_clLaonGrabberWrapper[m_nUnit].m_pFrameBMPBuffer;

    // 
    int nResult = R_RESULT_PASS;
    int nResultBlackSpot = 0;
    int nResultLCB = 0;
    int nResultRUYmean = 0;
    int totalStainNum = 0;
    g_clVision.ClearOverlay(m_nUnit);

    if (nResult == R_RESULT_PASS)
    {
       // totalStainNum += LCBInsp(spec, cvImageObject, stainImg);
    }
    //★★★★---------------------------------------------------------------------- Spec - Ymean
    if (nResult == R_RESULT_PASS)
    {
       // totalStainNum += Blemish_YmeanInsp(spec, cvImageObject, stainImg);
    }
    cvSaveImage("D:\\StainImg.bmp", cvImageObject);
    return 1;
}


int CPRIFunc_Insp::BlackSpotInsp(BYTE* bsimg, int nWidth, int nHeight, TDATASPEC& tDataSpec, IplImage* _timg)
{
    CString szLog;
    int nBlackLevel = 0;
    TBlackSpotContrastN tBlackSpotSpec;
    TCircleSpecN tStainSpec;

	IplImage *cvImgBlackSpot = cvCreateImage(cvSize(nWidth, nHeight), 8, 3); // bmp for display
	cvImgBlackSpot->imageData = (char*)g_clLaonGrabberWrapper[m_nUnit].m_pFrameBMPBuffer;
    int specCount = 0;
    tBlackSpotSpec.nBlockWidth = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0;32;
    tBlackSpotSpec.nBlockHeight = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//32;
    tBlackSpotSpec.nClusterSize = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//5;
    tBlackSpotSpec.nDefectInCluster = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//5;
    tBlackSpotSpec.dDefectRatio = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.45000;
    tBlackSpotSpec.nMaxSingleDefectNum = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//100000;	// noise image
    //
    tBlackSpotSpec.tCircleSpec.bEnableCircle = (bool)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//false;
    tBlackSpotSpec.tCircleSpec.nPosOffsetX = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//5;
    tBlackSpotSpec.tCircleSpec.nPosOffsetY = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//5;
    tBlackSpotSpec.tCircleSpec.dRadiusRatioX = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.45;
    tBlackSpotSpec.tCircleSpec.dRadiusRatioY = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.45;
    tBlackSpotSpec.tCircleSpec.dThresholdRatio = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.5;
    tBlackSpotSpec.tCircleSpec.dROIRange = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.5;
    tBlackSpotSpec.tCircleSpec.nUsedFixedCircle = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0;
    //
    tBlackSpotSpec.tMultiCircleSpec.bEnableMultiCircle = (int)g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0;
    tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[0] = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.2;
    tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[1] = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.4;
    tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[2] = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.52;
    tBlackSpotSpec.tMultiCircleSpec.dThreshold[0] = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.45;
    tBlackSpotSpec.tMultiCircleSpec.dThreshold[1] = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.45;
    tBlackSpotSpec.tMultiCircleSpec.dThreshold[2] = g_clModelData[m_nUnit].m_BlemishSpec[specCount++];//0.8;
    tBlackSpotSpec.tMultiCircleSpec.nBlobSize[0] = 0;//0;
    tBlackSpotSpec.tMultiCircleSpec.nBlobSize[1] = 0;//0;
    tBlackSpotSpec.tMultiCircleSpec.nBlobSize[2] = 0;//0;

    int nResult = R_RESULT_PASS;
    std::shared_ptr<CACMISImageBlackSpotContrastCommon> pInspectBlackSpot = std::make_shared<CACMISImageBlackSpotContrastCommon>();

    // inspection
    int nDefectCount = pInspectBlackSpot->Inspect((BYTE*)bsimg, nWidth, nHeight, tBlackSpotSpec, tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, nBlackLevel);

    //std::shared_ptr<CACMISImageBlackSpotContrastCommon> pInspectBlackSpot = std::make_shared<CACMISImageBlackSpotContrastCommon>();
    //pInspectBlackSpot->Inspect((BYTE*)stainImg,  gMIUDevice.nWidth, gMIUDevice.nHeight, stSpecBlackSpot,dTDATASPEC_n.eDataFormat,dTDATASPEC_n.eOutMode,dTDATASPEC_n.eSensorType,0);////★★★★
    //int nDefectCount = pInspectBlackSpot->Inspect((BYTE*)stainImg, gMIUDevice.nWidth, gMIUDevice.nHeight, stSpecBlackSpot, dTDATASPEC_n.eDataFormat, dTDATASPEC_n.eOutMode, dTDATASPEC_n.eSensorType, nBlackLevel);

    // logging
    //std::cout << "[BlackSpot] Version: " << pInspectBlackSpot->GetVersion() << std::endl;
    //std::cout << "[BlackSpot] DefectCount=" << nDefectCount << std::endl;
    //std::cout << "[BlackSpot] SingleDefectCount=" << pInspectBlackSpot->GetSingleDefectCount() << std::endl;
    //std::cout << "[BlackSpot] BlobCount=" << pInspectBlackSpot->GetDefectBlobCount() << std::endl;

    szLog.Format("[BlackSpot] BlackSpot %s", pInspectBlackSpot->GetVersion());
    AddLog(szLog, 1, m_nUnit, true);
    szLog.Format("[BlackSpot] DefectCount %d", nDefectCount);
    AddLog(szLog, 1, m_nUnit, true);
    szLog.Format("[BlackSpot] SingleDefectCount %d", pInspectBlackSpot->GetSingleDefectCount());
    AddLog(szLog, 1, m_nUnit, true);
    szLog.Format("[BlackSpot] BlobCount %d", pInspectBlackSpot->GetDefectBlobCount());
    AddLog(szLog, 1, m_nUnit, true);
   

    g_clMandoInspLog[m_nUnit].m_LogBlemishBlackSpot = pInspectBlackSpot->GetDefectBlobCount();

	g_clMesCommunication[m_nUnit].m_nMesBlemish[0] = g_clMandoInspLog[m_nUnit].m_LogBlemishBlackSpot;

	g_clMesCommunication[m_nUnit].m_nMesBlemishResult[0] = 1;
	if (g_clMesCommunication[m_nUnit].m_nMesBlemish[0] > 0)
	{
		g_clMesCommunication[m_nUnit].m_nMesBlemishResult[0] = 0;
	}
	CvFont cvfont;
	CvPoint pt;
	int scale = (nWidth > 640 ? 1 : 2);
	double nFontSize = 1 / scale;
	CString sTemp;
	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);
	sTemp.Format("BlackSpot BlobCount : %d", pInspectBlackSpot->GetDefectBlobCount());
	pt.x = 50;
	pt.y = 50;
	cvPutText(cvImgBlackSpot, sTemp, pt, &cvfont, CV_BLUE);
    if (pInspectBlackSpot->GetSingleDefectCount() > tBlackSpotSpec.nMaxSingleDefectNum) 
    {
        nResult = R_FAIL_NOISE;
    }
    else if (pInspectBlackSpot->GetDefectBlobCount() > 0) 
    {
        nResult = R_FAIL_BLACK_SPOT;
		g_clMandoInspLog[m_nUnit].m_bInspRes = false;
		g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [STAIN BLACKSPOT NG]");

		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [LCB BLOBCOUNT:%d]"), pInspectBlackSpot->GetDefectBlobCount());
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}
		for (int i = 0; i < (int)pInspectBlackSpot->GetDefectBlobCount(); i++)
		{
			const RECT* rt = pInspectBlackSpot->GetDefectBlobRect(i);
			cvRectangle(cvImgBlackSpot, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(255, 0, 0));
			g_clVision.DrawMOverlayBox(m_nUnit, rt->left, rt->top, rt->right, rt->bottom, M_COLOR_BLUE, 1, FALSE);
		}
    }
    if (nResult)
    {
        

        const TDefectResult* pMaxResult = pInspectBlackSpot->GetMaxDefectResult();

        int crossSize = 20;
        cvLine(cvImgBlackSpot, cvPoint(pMaxResult->ptPos.x - crossSize, pMaxResult->ptPos.y - crossSize),
            cvPoint(pMaxResult->ptPos.x + crossSize, pMaxResult->ptPos.y + crossSize), CV_RGB(255, 0, 0));
        cvLine(cvImgBlackSpot, cvPoint(pMaxResult->ptPos.x + crossSize, pMaxResult->ptPos.y - crossSize),
            cvPoint(pMaxResult->ptPos.x - crossSize, pMaxResult->ptPos.y + crossSize), CV_RGB(255, 0, 0));

        if (tBlackSpotSpec.tCircleSpec.bEnableCircle)
        {
            int ocx = (int)pMaxResult->dContrastMaxR;
            int ocy = (int)pMaxResult->dContrastMaxGb;
            int radx = (int)pMaxResult->dContrastMaxGr;
            int rady = (int)pMaxResult->dContrastMaxB;

            int nZone_X = (int)(radx * tBlackSpotSpec.tCircleSpec.dRadiusRatioX);
            int nZone_Y = (int)(rady * tBlackSpotSpec.tCircleSpec.dRadiusRatioY);


           // std::cout << "[BlackSpot] ocx=" << ocx << "ocy = " << ocy << "radx = " << nZone_X << "rady = " << nZone_Y << std::endl;
            //std::cout << "[BlackSpot] posx=" << pMaxResult->ptPos.x << "poxy = " << pMaxResult->ptPos.y << std::endl;

            cvEllipse(cvImgBlackSpot, cvPoint(ocx, ocy), cvSize(nZone_X, nZone_Y), 0, 0, 360, CV_RGB(0, 255, 255));
        }

        if (tBlackSpotSpec.tMultiCircleSpec.bEnableMultiCircle)
        {
            double dRadYRatio = 1.0;
            if (tBlackSpotSpec.tCircleSpec.nUsedFixedCircle)
            {
                dRadYRatio = tBlackSpotSpec.tCircleSpec.dRadiusRatioY / tBlackSpotSpec.tCircleSpec.dRadiusRatioX;
            }

            int ocx = (int)pMaxResult->dContrastMaxR;
            int ocy = (int)pMaxResult->dContrastMaxGb;
            int radx = (int)pMaxResult->dContrastMaxGr;
            int rady = (int)pMaxResult->dContrastMaxB;

            int nZoneA_X = (int)(radx * tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[0]);
            int nZoneA_Y = (int)(rady * tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[0] * dRadYRatio);
            int nZoneB_X = (int)(radx * tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[1]);
            int nZoneB_Y = (int)(rady * tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[1] * dRadYRatio);
            int nZoneC_X = (int)(radx * tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[2]);
            int nZoneC_Y = (int)(rady * tBlackSpotSpec.tMultiCircleSpec.dZoneSizeRatio[2] * dRadYRatio);

            cvEllipse(cvImgBlackSpot, cvPoint(ocx, ocy), cvSize(nZoneA_X, nZoneA_Y), 0, 0, 360, CV_RGB(0, 255, 255));
            cvEllipse(cvImgBlackSpot, cvPoint(ocx, ocy), cvSize(nZoneB_X, nZoneB_Y), 0, 0, 360, CV_RGB(0, 255, 255));
            cvEllipse(cvImgBlackSpot, cvPoint(ocx, ocy), cvSize(nZoneC_X, nZoneC_Y), 0, 0, 360, CV_RGB(0, 255, 255));

            //printf("[BlackSpot Multi Circle] ocX=%d, ocY=%d , dRadYRatio=%f, radZoneA(%d,%d), radZoneB(%d,%d), radZoneC(%d,%d)", ocx, ocy, dRadYRatio, nZoneA_X, nZoneA_Y, nZoneB_X, nZoneB_Y, nZoneC_X, nZoneC_Y);

        }

        if ((tBlackSpotSpec.tMultiCircleSpec.bEnableMultiCircle || tBlackSpotSpec.tCircleSpec.bEnableCircle) && tBlackSpotSpec.tCircleSpec.nUsedFixedCircle)
        {
            RECT rtRefEdge;
            RECT rtCenter;
            //oc threshold test roi - top
            rtRefEdge.left = max(nWidth / 2 - 100 / 2, 0);
            rtRefEdge.top = (LONG)(0.1 * nHeight / 2);
            rtRefEdge.right = min(rtRefEdge.left + 100 - 1, (LONG)nWidth - 1);
            rtRefEdge.bottom = min(rtRefEdge.top + 100 - 1, (LONG)nHeight - 1);

            //oc threshold test roi - center
            rtCenter.left = rtRefEdge.left;
            rtCenter.top = max(nHeight / 2 - 100 / 2, 0);
            rtCenter.right = rtRefEdge.right;
            rtCenter.bottom = min(nHeight / 2 + 100 / 2 - 1, nHeight - 1);

            cvRectangle(cvImgBlackSpot, cvPoint(rtRefEdge.left, rtRefEdge.top), cvPoint(rtRefEdge.right, rtRefEdge.bottom), CV_RGB(255, 86, 12));
            cvRectangle(cvImgBlackSpot, cvPoint(rtCenter.left, rtCenter.top), cvPoint(rtCenter.right, rtCenter.bottom), CV_RGB(255, 86, 12));
        }
    }
	g_clLaonGrabberWrapper[m_nUnit].JpgImageSave(cvImgBlackSpot, 0);
	cvReleaseImage(&cvImgBlackSpot);
    g_SaveLGITLog(m_nUnit, "BlackSpot", pInspectBlackSpot->GetLogHeader(), pInspectBlackSpot->GetLogData());
    //cvSaveImage("D:\\cvImgBlackSpot.bmp", cvImgBlackSpot);
    return true;
}

int CPRIFunc_Insp::LCBInsp(BYTE* img, int nWidth, int nHeight, TDATASPEC& tDataSpec, IplImage* _timg)
{
    int nResult = R_RESULT_PASS;
    int nResultLCB = 0;
    int nBlackLevel = 0;
    CString szLog;
    TLCBSpecN tStainSpec;
    memset(&tStainSpec, 0x00, sizeof(TLCBSpecN));
    int specCount = 0;
	IplImage *bmpImg = cvCreateImage(cvSize(nWidth, nHeight), 8, 3); // bmp for display
	bmpImg->imageData = (char*)g_clLaonGrabberWrapper[m_nUnit].m_pFrameBMPBuffer;
    //----------------------------------------------------------------------
    // Spec - LCB
    //----------------------------------------------------------------------
    tStainSpec.dCenterThreshold = g_clModelData[m_nUnit].m_LcbSpec[specCount++];// 35.0;
    tStainSpec.dEdgeThreshold = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//13.5;
    tStainSpec.dCornerThreshold = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//40.5;
    tStainSpec.nMaxSingleDefectNum = (int)g_clModelData[m_nUnit].m_LcbSpec[specCount++];//50000;
    tStainSpec.nMinDefectWidthHeight = (int)g_clModelData[m_nUnit].m_LcbSpec[specCount++];//12;
	tStainSpec.dCenterMaxR = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//9;
	tStainSpec.dCenterMaxGr = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dCenterMaxGb = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dCenterMaxB = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//9;
	tStainSpec.dEdgeMaxR = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dEdgeMaxGr = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dEdgeMaxGb = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dEdgeMaxB = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dCornerMaxR = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dCornerMaxGr = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dCornerMaxGb = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
	tStainSpec.dCornerMaxB = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0;
    tStainSpec.tCircleSpec.bEnableCircle = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//true;
    tStainSpec.tCircleSpec.nPosOffsetX = (int)g_clModelData[m_nUnit].m_LcbSpec[specCount++];//5;
    tStainSpec.tCircleSpec.nPosOffsetY = (int)g_clModelData[m_nUnit].m_LcbSpec[specCount++];//5;
    tStainSpec.tCircleSpec.dRadiusRatioX = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.5;
    tStainSpec.tCircleSpec.dRadiusRatioY = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.5;
    tStainSpec.tCircleSpec.dThresholdRatio = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.5;
    tStainSpec.tCircleSpec.dROIRange = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.5;
    tStainSpec.tCircleSpec.nUsedFixedCircle = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//false;
    tStainSpec.tMultiCircleSpec.bEnableMultiCircle = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//false;
    tStainSpec.tMultiCircleSpec.dZoneSizeRatio[0] = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.25;
    tStainSpec.tMultiCircleSpec.dZoneSizeRatio[1] = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.35;
    tStainSpec.tMultiCircleSpec.dZoneSizeRatio[2] = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//0.45;
    tStainSpec.tMultiCircleSpec.dThreshold[0] = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//9.0;
    tStainSpec.tMultiCircleSpec.dThreshold[1] = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//15.0;
    tStainSpec.tMultiCircleSpec.dThreshold[2] = g_clModelData[m_nUnit].m_LcbSpec[specCount++];//50.0;
    tStainSpec.tMultiCircleSpec.nBlobSize[0] = 0;
    tStainSpec.tMultiCircleSpec.nBlobSize[1] = 0;
    tStainSpec.tMultiCircleSpec.nBlobSize[2] = 0;


    std::shared_ptr<CACMISImageStainLCBCommon> pInspectLCB = std::make_shared<CACMISImageStainLCBCommon>();
    
    nResultLCB = pInspectLCB->Inspect((BYTE*)img, nWidth, nHeight, tStainSpec,tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType,nBlackLevel);

    if (nResultLCB > 0)
    {
        nResult = R_FAIL_STAIN;
    }
    szLog.Format("[LCB] Version %s", pInspectLCB->GetVersion());
    AddLog(szLog, 1, m_nUnit, true);
    //szLog.Format("[LCB] SingleDefectCount %d", nResultLCB);
    //AddLog(szLog, 1, m_nUnit, true);
    szLog.Format("[LCB] DefectBlobCount %d", pInspectLCB->GetDefectBlobCount());
    AddLog(szLog, 1, m_nUnit, true);
    int ocx = 0, ocy = 0, radx = 0, rady = 0;
   

	CvFont cvfont;
	CvPoint pt;
	int scale = (nWidth > 640 ? 1 : 2);
	double nFontSize = 1 / scale;
	CString sTemp;
	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);
	sTemp.Format("LCB BlobCount : %d", pInspectLCB->GetDefectBlobCount());
	pt.x = 50;
	pt.y = 80;
	cvPutText(bmpImg, sTemp, pt, &cvfont, CV_BLUE);
    if (pInspectLCB->GetDefectBlobCount() > 0)
    {
        //이물불량
        g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [STAIN LCB NG]");
		g_clMandoInspLog[m_nUnit].m_bInspRes = false;
        if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
        {
            g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [LCB BLOBCOUNT:%d]"), pInspectLCB->GetDefectBlobCount());
            g_clMandoInspLog[m_nUnit].m_nNGCnt++;
        }
		for (int i = 0; i < pInspectLCB->GetDefectBlobCount(); i++)
		{
			const RECT* rt = pInspectLCB->GetDefectBlobRect(i);
			cvRectangle(bmpImg, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(0, 0, 255));
			g_clVision.DrawMOverlayBox(m_nUnit, rt->left, rt->top, rt->right, rt->bottom, M_COLOR_BLUE, 1, FALSE);
		}
    }
    g_clMandoInspLog[m_nUnit].m_LogBlemishLcb = pInspectLCB->GetDefectBlobCount();
	g_clMesCommunication[m_nUnit].m_nMesBlemish[1] = g_clMandoInspLog[m_nUnit].m_LogBlemishLcb;
	g_clMesCommunication[m_nUnit].m_nMesBlemishResult[1] = 1;
	if (g_clMesCommunication[m_nUnit].m_nMesBlemish[1] > 0)
	{
		g_clMesCommunication[m_nUnit].m_nMesBlemishResult[1] = 0;
	}
    if (tStainSpec.tCircleSpec.bEnableCircle || tStainSpec.tMultiCircleSpec.bEnableMultiCircle)
    {
        const TDefectResult* pCircleMaxResult = pInspectLCB->GetMaxDefectResult(EIMAGEREGION_CIRCLE);

        ocx = (int)pCircleMaxResult->dContrastMaxR;
        ocy = (int)pCircleMaxResult->dContrastMaxGb;
        radx = (int)pCircleMaxResult->dContrastMaxGr * tStainSpec.tCircleSpec.dRadiusRatioX;
        rady = (int)pCircleMaxResult->dContrastMaxB  *tStainSpec.tCircleSpec.dRadiusRatioY;
       
        if (tStainSpec.tCircleSpec.bEnableCircle)
        {
            std::cout << "[LCB Circle] ocx=" << ocx << "ocy = " << ocy << "radx = " << radx << "rady = " << rady << std::endl;
            cvEllipse(bmpImg, cvPoint(ocx, ocy), cvSize(radx, rady), 0, 0, 360, CV_RGB(0, 255, 255),2);
            g_clVision.DrawMOverlayCircle(m_nUnit, ocx - radx, ocy - rady, ocx + radx, ocy + rady, M_COLOR_MAGENTA, 1, FALSE);
            //cvEllipse(bmpImg, cvPoint(ocx, ocy), cvSize(radx, rady), 0, 0, 360, CV_RGB(0, 255, 255), 2);
            
            //vision.ellipselist[CCD].addList(CPoint(ocx - radx, ocy - rady), CPoint(ocx + radx, ocy + rady), PS_SOLID, M_COLOR_CYAN);
        }
        else
        {
            double dRadYRatio = 1.0;
            if (tStainSpec.tCircleSpec.nUsedFixedCircle)
            {
                dRadYRatio = tStainSpec.tCircleSpec.dRadiusRatioY / tStainSpec.tCircleSpec.dRadiusRatioX;
            }
            //반지름x
            //반지름y
            int nZoneA_X = (int)(radx * tStainSpec.tMultiCircleSpec.dZoneSizeRatio[0]);
            int nZoneA_Y = (int)(rady * tStainSpec.tMultiCircleSpec.dZoneSizeRatio[0] * dRadYRatio);
            int nZoneB_X = (int)(radx * tStainSpec.tMultiCircleSpec.dZoneSizeRatio[1]);
            int nZoneB_Y = (int)(rady * tStainSpec.tMultiCircleSpec.dZoneSizeRatio[1] * dRadYRatio);
            int nZoneC_X = (int)(radx * tStainSpec.tMultiCircleSpec.dZoneSizeRatio[2]);
            int nZoneC_Y = (int)(rady * tStainSpec.tMultiCircleSpec.dZoneSizeRatio[2] * dRadYRatio);
            cvEllipse(bmpImg, cvPoint(ocx, ocy), cvSize(nZoneA_X, nZoneA_Y), 0, 0, 360, CV_RGB(0, 255, 255), 2);
            cvEllipse(bmpImg, cvPoint(ocx, ocy), cvSize(nZoneB_X, nZoneB_Y), 0, 0, 360, CV_RGB(0, 255, 255), 2);
            cvEllipse(bmpImg, cvPoint(ocx, ocy), cvSize(nZoneC_X, nZoneC_Y), 0, 0, 360, CV_RGB(0, 255, 255), 2);
            //
            g_clVision.DrawMOverlayCircle(m_nUnit, ocx - nZoneA_X, ocy - nZoneA_Y, ocx + nZoneA_X, ocy + nZoneA_Y, M_COLOR_MAGENTA, 1, FALSE);
            g_clVision.DrawMOverlayCircle(m_nUnit, ocx - nZoneB_X, ocy - nZoneB_Y, ocx + nZoneB_X, ocy + nZoneB_Y, M_COLOR_MAGENTA, 1, FALSE);
            g_clVision.DrawMOverlayCircle(m_nUnit, ocx - nZoneC_X, ocy - nZoneC_Y, ocx + nZoneC_X, ocy + nZoneC_Y, M_COLOR_MAGENTA, 1, FALSE);
            //vision.ellipselist[CCD].addList(CPoint(ocx - nZoneA_X, ocy - nZoneA_Y), CPoint(ocx + nZoneA_X, ocy + nZoneA_Y), PS_SOLID, M_COLOR_CYAN);

        }
        if (tStainSpec.tCircleSpec.nUsedFixedCircle)
        {
            RECT rtRefEdge;
            RECT rtCenter;
            //oc threshold test roi - top
            rtRefEdge.left = max(nWidth / 2 - 100 / 2, 0);
            rtRefEdge.top = (LONG)(0.1 * nHeight / 2);
            rtRefEdge.right = min(rtRefEdge.left + 100 - 1, (LONG)nWidth - 1);
            rtRefEdge.bottom = min(rtRefEdge.top + 100 - 1, (LONG)nHeight - 1);

            //oc threshold test roi - center
            rtCenter.left = rtRefEdge.left;
            rtCenter.top = max(nHeight / 2 - 100 / 2, 0);
            rtCenter.right = rtRefEdge.right;
            rtCenter.bottom = min(nHeight / 2 + 100 / 2 - 1, nHeight - 1);

            cvRectangle(bmpImg, cvPoint(rtRefEdge.left, rtRefEdge.top), cvPoint(rtRefEdge.right, rtRefEdge.bottom), CV_RGB(255, 86, 12));
            cvRectangle(bmpImg, cvPoint(rtCenter.left, rtCenter.top), cvPoint(rtCenter.right, rtCenter.bottom), CV_RGB(255, 86, 12));

            g_clVision.DrawMOverlayBox(m_nUnit, rtRefEdge.left, rtRefEdge.top, rtRefEdge.right, rtRefEdge.bottom, M_COLOR_BLUE, 1, FALSE);
            g_clVision.DrawMOverlayBox(m_nUnit, rtCenter.left, rtCenter.top, rtCenter.right, rtCenter.bottom, M_COLOR_BLUE, 1, FALSE);
        }
        
    }
    else
    {
        int nCenterCount = pInspectLCB->GetDefectCount(EIMAGEREGION_CENTER);
        const TDefectResult* pCenterMaxResult = pInspectLCB->GetMaxDefectResult(EIMAGEREGION_CENTER);


        
        //std::cout << "[LCB] SingleDefectCount=" << nDefectCount << std::endl;
    }
	

    if (nResult)
    {
        if (tStainSpec.tCircleSpec.bEnableCircle || tStainSpec.tMultiCircleSpec.bEnableMultiCircle)
        {
            int nCircleCount = pInspectLCB->GetDefectCount(EIMAGEREGION_CIRCLE);
            if (tStainSpec.tCircleSpec.nUsedFixedCircle)
            {
                RECT rtRefEdge;
                RECT rtCenter;
                //oc threshold test roi - top
                rtRefEdge.left = max(g_clModelData[m_nUnit].m_nWidth / 2 - 100 / 2, 0);
                rtRefEdge.top = (LONG)(0.1 * g_clModelData[m_nUnit].m_nHeight / 2);
                rtRefEdge.right = min(rtRefEdge.left + 100 - 1, (LONG)g_clModelData[m_nUnit].m_nWidth - 1);
                rtRefEdge.bottom = min(rtRefEdge.top + 100 - 1, (LONG)g_clModelData[m_nUnit].m_nHeight - 1);

                //oc threshold test roi - center
                rtCenter.left = rtRefEdge.left;
                rtCenter.top = max(g_clModelData[m_nUnit].m_nHeight / 2 - 100 / 2, 0);
                rtCenter.right = rtRefEdge.right;
                rtCenter.bottom = min(g_clModelData[m_nUnit].m_nHeight / 2 + 100 / 2 - 1, g_clModelData[m_nUnit].m_nHeight - 1);

                cvRectangle(bmpImg, cvPoint(rtRefEdge.left, rtRefEdge.top), cvPoint(rtRefEdge.right, rtRefEdge.bottom), CV_RGB(255, 86, 12));
                cvRectangle(bmpImg, cvPoint(rtCenter.left, rtCenter.top), cvPoint(rtCenter.right, rtCenter.bottom), CV_RGB(255, 86, 12));

                g_clVision.DrawMOverlayBox(m_nUnit, rtRefEdge, M_COLOR_RED, 1, FALSE, PS_SOLID);
                g_clVision.DrawMOverlayBox(m_nUnit, rtCenter, M_COLOR_RED, 1, FALSE, PS_SOLID);
                //vision.boxlist[CCD].addList(rtRefEdge, PS_SOLID, M_COLOR_RED);
                //vision.boxlist[CCD].addList(rtCenter, PS_SOLID, M_COLOR_RED);

            }
        }
        //for (int i = 0; i < pInspectLCB->GetDefectBlobCount(); i++)
        //{
        //    const RECT* rt = pInspectLCB->GetDefectBlobRect(i);
        //    cvRectangle(bmpImg, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(0, 0, 255));
        //    //vision.boxlist[CCD].addList(rt, PS_SOLID, M_COLOR_RED);
        //    g_clVision.DrawMOverlayBox(m_nUnit, rt->left, rt->top, rt->right, rt->bottom, M_COLOR_RED, 1, FALSE);
        //}
        //
    }
    //cvSaveImage("D:\\StainImg.bmp", bmpImg);
    //
	g_clLaonGrabberWrapper[m_nUnit].JpgImageSave(bmpImg, 0);
	cvReleaseImage(&bmpImg);
    //CalibrationInspLog.func_LogSave_Stain("LCB", pInspectLCB->GetLogHeader(), pInspectLCB->GetLogData());
    g_SaveLGITLog(m_nUnit, "LCB", pInspectLCB->GetLogHeader(), pInspectLCB->GetLogData());
    return nResultLCB;
}
//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
int CPRIFunc_Insp::Blemish_YmeanInsp(BYTE* img, int nWidth, int nHeight, TDATASPEC& tDataSpec, IplImage* _timg)
{
	
    int nResult = R_RESULT_PASS;
    int nResultRUYmean = 0;
    int nBlackLevel = 0;
    CString szLog = "";
    TStainSpec tStainSpec;
    TRU_YmeanSpecN stSpecYmean;
    memset(&stSpecYmean, 0x00, sizeof(TRU_YmeanSpecN));
    int specCount = 0;


	IplImage *bmpImg = cvCreateImage(cvSize(nWidth, nHeight), 8, 3); // bmp for display
	bmpImg->imageData=	(char*)g_clLaonGrabberWrapper[m_nUnit].m_pFrameBMPBuffer;
    //----------------------------------------------------------------------
    // Spec - Ymean
    //----------------------------------------------------------------------
    stSpecYmean.nEdgeSize = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];// 100;
    stSpecYmean.fCenterThreshold = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//10.75;
    stSpecYmean.fEdgeThreshold = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//15.0;
    stSpecYmean.fCornerThreshold = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//15.0;
    stSpecYmean.nDefectBlockSize = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//15;
    stSpecYmean.nLscBlockSize = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//64;
    stSpecYmean.nCalcType = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0;
    stSpecYmean.nMaxRecursiveCount = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//1000;
    stSpecYmean.dMaxDefectSize = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//70.0;
    stSpecYmean.dPixelSize = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//4.2;

    stSpecYmean.tCircleSpec.bEnableCircle = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//false;
    stSpecYmean.tCircleSpec.nPosOffsetX = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//5;
    stSpecYmean.tCircleSpec.nPosOffsetY = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//5;
    stSpecYmean.tCircleSpec.dRadiusRatioX = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.45;
    stSpecYmean.tCircleSpec.dRadiusRatioY = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.45;
    stSpecYmean.tCircleSpec.dThresholdRatio = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.5;
    stSpecYmean.tCircleSpec.dROIRange = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.5;
    stSpecYmean.tCircleSpec.nUsedFixedCircle = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0;
    stSpecYmean.tMultiCircleSpec.bEnableMultiCircle = (int)g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//false;
    stSpecYmean.tMultiCircleSpec.dZoneSizeRatio[0] = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.2;
    stSpecYmean.tMultiCircleSpec.dZoneSizeRatio[1] = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.4;
    stSpecYmean.tMultiCircleSpec.dZoneSizeRatio[2] = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.52;
    stSpecYmean.tMultiCircleSpec.dThreshold[0] = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.45;
    stSpecYmean.tMultiCircleSpec.dThreshold[1] = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.45;
    stSpecYmean.tMultiCircleSpec.dThreshold[2] = g_clModelData[m_nUnit].m_YmeanSpec[specCount++];//0.8;
    stSpecYmean.tMultiCircleSpec.nBlobSize[0] = 0;
    stSpecYmean.tMultiCircleSpec.nBlobSize[1] = 0;
    stSpecYmean.tMultiCircleSpec.nBlobSize[2] = 0;

    std::shared_ptr<CACMISImageStainRU_YmeanCommon> pInspectBlemish_Ymean = std::make_shared<CACMISImageStainRU_YmeanCommon>();//delete,x

    pInspectBlemish_Ymean->Inspect((BYTE*)img, nWidth, nHeight, stSpecYmean,
        tDataSpec.eDataFormat, tDataSpec.eOutMode, tDataSpec.eSensorType, nBlackLevel);
    nResultRUYmean = pInspectBlemish_Ymean->GetDefectBlobCount();

	CvFont cvfont;
	CvPoint pt;
	int scale = (nWidth > 640 ? 1 : 2);
	double nFontSize = 1 / scale;
	CString sTemp;
	cvInitFont(&cvfont, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_NORMAL, nFontSize, nFontSize, 0, 1, 10);
	sTemp.Format("Ymean BlobCount : %d", pInspectBlemish_Ymean->GetDefectBlobCount());
	pt.x = 50;
	pt.y = 110;
	cvPutText(bmpImg, sTemp, pt, &cvfont, CV_BLUE);
    if (nResultRUYmean > 0)
    {
        nResult = R_FAIL_STAIN;// R_FAIL_BLACK_SPOT;
        //이물불량
		g_clMandoInspLog[m_nUnit].m_bInspRes = false;
        g_clMandoInspLog[m_nUnit].m_sNGList += _T(" [STAIN YMEAN NG]");

        if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
        {
            g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("NG [YMEAN BLOBCOUNT:%d]"), pInspectBlemish_Ymean->GetDefectBlobCount());
            g_clMandoInspLog[m_nUnit].m_nNGCnt++;
        }
		for (int i = 0; i < pInspectBlemish_Ymean->GetDefectBlobCount(); i++)
		{
			const RECT* rt = pInspectBlemish_Ymean->GetDefectBlobRect(i);
			cvRectangle(bmpImg, cvPoint(rt->left, rt->top), cvPoint(rt->right, rt->bottom), CV_RGB(138, 43, 226), 2);
			g_clVision.DrawMOverlayBox(m_nUnit, rt->left, rt->top, rt->right, rt->bottom, M_COLOR_BLUE, 1, FALSE);
			//vision.boxlist[CCD].addList(rt, PS_SOLID, M_COLOR_CYAN);
		}
    }

    szLog.Format("[RUYMean] Version %s", pInspectBlemish_Ymean->GetVersion());
    AddLog(szLog, 1, m_nUnit, true);
    szLog.Format("[RUYMean] GetDefectBlobCount %d", nResultRUYmean);
    AddLog(szLog, 1, m_nUnit, true);
    g_clMandoInspLog[m_nUnit].m_LogBlemishRU_Ymean = nResultRUYmean;

	g_clMesCommunication[m_nUnit].m_nMesBlemish[2] = g_clMandoInspLog[m_nUnit].m_LogBlemishRU_Ymean;

	g_clMesCommunication[m_nUnit].m_nMesBlemishResult[2] = 1;
	if (g_clMesCommunication[m_nUnit].m_nMesBlemish[2] > 0)
	{
		g_clMesCommunication[m_nUnit].m_nMesBlemishResult[2] = 0;
	}
    if (nResult)
    {
        if (stSpecYmean.tCircleSpec.bEnableCircle || stSpecYmean.tMultiCircleSpec.bEnableMultiCircle)
        {
            int ocx = 0, ocy = 0, radx = 0, rady = 0;
            int nCircleCount = pInspectBlemish_Ymean->GetDefectCount(EIMAGEREGION_CIRCLE);
            const TDefectResult* pCircleMaxResult = pInspectBlemish_Ymean->GetMaxDefectResult(EIMAGEREGION_CIRCLE);

            ocx = (int)pCircleMaxResult->dContrastMaxR;
            ocy = (int)pCircleMaxResult->dContrastMaxGb;
            radx = (int)pCircleMaxResult->dContrastMaxGr* stSpecYmean.tCircleSpec.dRadiusRatioX;
            rady = (int)pCircleMaxResult->dContrastMaxB *stSpecYmean.tCircleSpec.dRadiusRatioY;

            if (stSpecYmean.tCircleSpec.bEnableCircle)
            {
                //std::cout << "[RUYMean] ocx=" << ocx << "ocy = " << ocy << "radx = " << radx << "rady = " << rady << std::endl;
                cvEllipse(bmpImg, cvPoint(ocx, ocy), cvSize(radx, rady), 0, 0, 360, CV_RGB(0, 255, 255));
                //vision.ellipselist[CCD].addList(CPoint(ocx - radx, ocy - rady), CPoint(ocx + radx, ocy + rady), PS_SOLID, M_COLOR_CYAN);
            }
        }
    }
	g_clLaonGrabberWrapper[m_nUnit].JpgImageSave(bmpImg, 2);
	cvReleaseImage(&bmpImg);
    //CalibrationInspLog.func_LogSave_Stain("[RU_Ymean]", pInspectBlemish_Ymean->GetLogHeader(), pInspectBlemish_Ymean->GetLogData());
    g_SaveLGITLog(m_nUnit, "RUYMean", pInspectBlemish_Ymean->GetLogHeader(), pInspectBlemish_Ymean->GetLogData());
    return nResultRUYmean;
}
//-----------------------------------------------------------------------------
//
//	전류 측정
//
//-----------------------------------------------------------------------------
bool CPRIFunc_Insp::func_Insp_CurrentMeasure(bool bLogDraw, bool bAutoMode)
{
	double cur = 0.0;

	bool	bRes = false;

	TCHAR szLog[SIZE_OF_1K];

	CMapData spec;
	//GetIni("SPEC.INI", spec);
	TCHAR	szPath[SIZE_OF_1K];


	//g_clVision.ClearOverlay(CAM_CCD);


	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Model\\%s\\SPEC.INI"), BASE_DATA_PATH, g_clSysData.m_szModelName);
	GetIni(szPath, spec);

	double m_dCurrentMin = spec["CURRENT_SPEC.current_min.d"].d;
	double m_dCurrentMax = spec["CURRENT_SPEC.current_max.d"].d;

	//MIU.GetCurrent( &cur ); 
#ifdef ON_LINE_GRABBER
	g_clLaonGrabberWrapper[m_nUnit].GetCurrent(&cur);
#endif

	if ((cur > m_dCurrentMin) && (cur < m_dCurrentMax))
	{
		bRes = true;
	}

	// 20141202 LHC - current 측정 하여 MES 저장
	if (bRes == true)
	{
		g_clMesCommunication[m_nUnit].m_dMesCurrent = cur;
		g_clMesCommunication[m_nUnit].m_nMesCurrentResult = 1;
	}
	else
	{
		g_clMesCommunication[m_nUnit].m_dMesCurrent = cur;
		g_clMesCommunication[m_nUnit].m_nMesCurrentResult = 0;
	}

	g_clMandoInspLog[m_nUnit].m_dCurrent = cur;

	if (bLogDraw == true)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	전류 측정치 : %.02lf"), cur);
		AddLog(szLog, 0, m_nUnit);

		g_clMandoInspLog[m_nUnit].m_dCurrent = cur;

		if (bRes == false)
		{
			//만도 차량용Camera 검사 Log 저장 Defect_Black
			g_clMandoInspLog[m_nUnit].m_bInspRes = false;						//검사 결과 실패
			g_clMandoInspLog[m_nUnit].m_sNGList += _T("[CURRENT ERROR]");	//NG 사유

			if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
			{
				//! Main Display화면 Overlay NG List
				g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("CURRENT ERROR : %.02lf"), cur);
				g_clMandoInspLog[m_nUnit].m_nNGCnt++;
			}

			if (bAutoMode == true)	g_clTaskWork[m_nUnit].m_nCurrentNgCount++;	//자동일 경우만 검사 NG 수량 증가
		}
	}

	return bRes;
}

//-----------------------------------------------------------------------------
//
//	TEST PATTERN 검사
//
//-----------------------------------------------------------------------------
int CPRIFunc_Insp::func_Insp_TestPattern(bool bAutoMode)
{/* 결과값
 -1 일때 영상 Grab 상태 아님
 0 일때 패턴 일치
 양수 값일 때 1Frame에서 틀린 픽셀수
 */
	TCHAR szPath[SIZE_OF_1K];
	CFileFind clFinder;
	int readLen;


	//g_clVision.ClearOverlay(CAM_CCD);


	//if (m_bThreadUsed == false) return -1;  //Thread 사용 안하니 Pass
	cTestPat_Ref_buf = (unsigned char*)malloc(g_clModelData[m_nUnit].m_nWidth * g_clModelData[m_nUnit].m_nHeight);

	//#ifdef ON_LINE_GRABBER
	//	// Mono로 변경
	//	g_clLaonGrabberWrapper[m_nUnit].ChangeMono();
	//
	//	//!! CM_Grabber Test Pattern Mode 변경
	//	g_clLaonGrabberWrapper[m_nUnit].ChangePatternMode(1);
	//	/////////////////////////////////////////////////////////////////
	//
	//	//정지영상
	//	g_clLaonGrabberWrapper[m_nUnit].SetCurrentState(CCD_GRAB_PAUSE);
	//#endif

	Sleep(1000);

	//-- Test Image 변경

	_stprintf_s(szPath, _T("%s\\Model\\%s\\TestPattern.raw"), BASE_DATA_PATH, g_clSysData.m_szModelName);
	if (clFinder.FindFile(szPath) == FALSE)
	{
#ifdef ON_LINE_GRABBER
		// Raw로 변경
		g_clLaonGrabberWrapper[m_nUnit].ChangeRaw();

		g_clLaonGrabberWrapper[m_nUnit].ChangePatternMode(0);
		//LIVE 영상
		g_clLaonGrabberWrapper[m_nUnit].SetCurrentState(CCD_GRAB_LIVE);
#endif

		return -1;
	}

	FILE *fp = NULL;
	m_iPatternTest_ErrCnt = 0;

	_tfopen_s(&fp, szPath, _T("rt+"));
	if (fp != NULL)
	{
		readLen = (int)fread(cTestPat_Ref_buf, 1, (g_clModelData[m_nUnit].m_nWidth * g_clModelData[m_nUnit].m_nHeight), fp);
		//m_iPatternTest_ErrCnt = 0;
		fclose(fp);
	}
	else
	{
		return -1;
	}

	for (int i = 0; i < (g_clModelData[m_nUnit].m_nWidth * g_clModelData[m_nUnit].m_nHeight); i++)
	{
		// if (((unsigned char*)imagePattern->imageData[i] - (unsigned char*)cTestPat_Ref_buf[i]) % 0x100 != 0 )
		//if (MIU.imgBufBit8[i] - cTestPat_Ref_buf[i])
#ifdef ON_LINE_GRABBER	
		if (g_clLaonGrabberWrapper[m_nUnit].m_pImgBuff8Bit[i] - cTestPat_Ref_buf[i])
#endif
		{
			m_iPatternTest_ErrCnt++;
		}
	}

	free(cTestPat_Ref_buf);

	//#ifdef ON_LINE_GRABBER	
	//		// Raw로 변경
	//		g_clLaonGrabberWrapper[m_nUnit].ChangeRaw();
	//
	//		g_clLaonGrabberWrapper[m_nUnit].ChangePatternMode(0);
	//
	//		/////////////////////////////////////////////////////////////////
	//
	//		//Live 영상
	//		g_clLaonGrabberWrapper[m_nUnit].SetCurrentState(CCD_GRAB_LIVE);	
	//#endif

	//만도 차량용Camera 검사 Log 저장 TestPattern
	if (m_iPatternTest_ErrCnt > 0)
	{
		g_clMandoInspLog[m_nUnit].m_bInspRes = false;						//검사 결과 실패
		g_clMandoInspLog[m_nUnit].m_sNGList += _T("[TEST_PATTERN ERROR]");	//NG 사유
																			//MandoInspLog.s12C.Format("NG_%d개", m_iPatternTest_ErrCnt);
		g_clMandoInspLog[m_nUnit].m_sI2C.Format("NG");

		//! Main Display화면 Overlay NG List
		if (g_clMandoInspLog[m_nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[m_nUnit].m_sDispNG[g_clMandoInspLog[m_nUnit].m_nNGCnt].Format(_T("TEST_PATTERN ERROR : %d"), m_iPatternTest_ErrCnt);
			g_clMandoInspLog[m_nUnit].m_nNGCnt++;
		}

		g_clMesCommunication[m_nUnit].m_sMesI2C.Format(_T("FAIL"));
		g_clMesCommunication[m_nUnit].m_nMesI2CResult = 0;
	}
	else
	{
		g_clMandoInspLog[m_nUnit].m_sI2C.Format("OK");

		g_clMesCommunication[m_nUnit].m_sMesI2C.Format(_T("PASS"));
		g_clMesCommunication[m_nUnit].m_nMesI2CResult = 1;
	}

	g_clMandoInspLog[m_nUnit].m_sI2C.Format(_T("OK"));

	g_clMesCommunication[m_nUnit].m_sMesI2C.Format(_T("PASS"));
	g_clMesCommunication[m_nUnit].m_nMesI2CResult = 1;


	return m_iPatternTest_ErrCnt;
}
////////TESLA ADD
int CPRIFunc_Insp::func_CalibrateImageEmbedded(TCHAR *ptszImgPath, CString &sResult)
{
	int nResult = -1;
	DWORD dwStartTime = GetTickCount();
	WCHAR wstrImagePath[1024];
	int nLen = strlen(ptszImgPath) + 1;
	TCHAR szLog[SIZE_OF_1K];

	MultiByteToWideChar(CP_ACP, 0, ptszImgPath, -1, wstrImagePath, nLen - 1);
	wstrImagePath[nLen - 1] = 0;

	_stprintf_s(szLog, SIZE_OF_1K, _T("imagefile : %s"), ptszImgPath);
	AddLog(szLog, 0, m_nUnit);

	TESLA_CALIB_RESULT *ptagCalibResult = CalibrateImage(wstrImagePath);

		if (ptagCalibResult != NULL)
		{
			CString strResult = _T("Calibration Result\r\n");
			CString strTemp;

			strTemp = ptagCalibResult->szVersion;
			strResult += _T("Version : ") + strTemp + _T("\r\n");

			strTemp.Format(_T("Theta : (%lf, %lf, %lf)\r\n"), ptagCalibResult->dTheta1, ptagCalibResult->dTheta2, ptagCalibResult->dTheta3);
			strResult += strTemp;

			strTemp.Format(_T("Shift : (%lf, %lf)\r\n"), ptagCalibResult->dShift1, ptagCalibResult->dShift2);
			strResult += strTemp;

			strTemp.Format(_T("D : %lf\r\n"), ptagCalibResult->dD);
			strResult += strTemp;

			strTemp.Format(_T("F : %lf\r\n"), ptagCalibResult->dF);
			strResult += strTemp;

			strTemp.Format(_T("K : (%lf, %lf, %lf, %lf)\r\n"), ptagCalibResult->dK1, ptagCalibResult->dK2, ptagCalibResult->dK3, ptagCalibResult->dK4);
			strResult += strTemp;

			strTemp.Format(_T("C_Mat : (%lf, %lf)\r\n"), ptagCalibResult->dCMat1, ptagCalibResult->dCMat2);
			strResult += strTemp;

			strTemp.Format(_T("Val : %lf\r\n"), ptagCalibResult->dVal);
			strResult += strTemp;

			strTemp.Format(_T("Val_Init : %lf\r\n"), ptagCalibResult->dValInit);
			strResult += strTemp;

			strTemp.Format(_T("Time - %dms"), GetTickCount() - dwStartTime);
			strResult += strTemp;

			sResult = strResult;

			//delete ptagCalibResult;
			//ptagCalibResult = NULL;
		}
		else
		{
			CString strError;
			DWORD dwLastError = GetLastError();

			nResult = (int)dwLastError;

			switch (dwLastError)
			{
			case CALIBRATIONDLL_NOT_INITIALIZED:
				strError = _T("Blob parameters are not set.");
				break;
			case CALIBRATIONDLL_INVALID_IMAGE_PATH:
				strError = _T("Invalid Image Path.");
				break;
			case CALIBRATIONDLL_IMAGE_NOT_EXIST:
				strError = _T("Image file is not exist.");
				break;
			case CALIBRATIONDLL_EXE_NOT_EXIST:
				strError = _T("TeslaCal.exe is not exist.");
				break;
			case CALIBRATIONDLL_FAILED_EXE_RUN:
				strError = _T("Failed to run TeslaCal.exe");
				break;
			case CALIBRATIONDLL_FAILED_CALIBRATION:
				strError = _T("Failed to run calibraation.");
				break;
			case CALIBRATIONDLL_INVALID_OBJECT_SIZE:
				strError = _T("Invalid object size.");
				break;
			case CALIBRATIONDLL_FAILED_FIND_CIRCLE:
				strError = _T("Failed to find circles.");
				break;
			case CALIBRATIONDLL_FAILED_GENERATE_AREA:
				strError = _T("Failed to generate areas.");
				break;
			default:
				strError = _T("Unknown error.");
				break;
			}
			sResult = strError;
		}
	
	return nResult;
}
int CPRIFunc_Insp::func_EvaluateUndistortImage(TCHAR *ptszImgPath, CString &sResult)
{
	int nResult = -1;
	DWORD dwStartTime = GetTickCount();
	WCHAR wstrImagePath[1024];
	int nLen = strlen(ptszImgPath) + 1;

	MultiByteToWideChar(CP_ACP, 0, ptszImgPath, -1, wstrImagePath, nLen - 1);
	wstrImagePath[nLen - 1] = 0;

	EVALUATE_RESULT *ptagEvaluateResult = EvaluateUndistortImage(wstrImagePath, 36, 24, true);

	if (ptagEvaluateResult != NULL)
	{
		CString strResult = _T("Rectangle Test Result\r\n");
		CString strTemp;

		for (int i = 0; i < 12; i++)
		{
			strTemp.Format(_T("[%02d] %lf\r\n"), i, (ptagEvaluateResult->fRectangleLineResult[i]));
			strResult += strTemp;
		}

		strTemp.Format(_T("Col Straight Avrg : %lf\r\n"), ptagEvaluateResult->dStraightCols);
		strResult += strTemp;

		strTemp.Format(_T("Row Straight Avrg : %lf\r\n"), ptagEvaluateResult->dStraightRows);
		strResult += strTemp;

		strResult += _T("Dist (Average, Deviation, Min, Max)\r\n");

		strTemp.Format(_T("Col (%lf, %lf, %lf, %lf)\r\n"),
			ptagEvaluateResult->dColDistAverage,
			ptagEvaluateResult->dColDistDeviation,
			ptagEvaluateResult->dColDistMin,
			ptagEvaluateResult->dColDistMax);

		strResult += strTemp;

		strTemp.Format(_T("Row (%lf, %lf, %lf, %lf)\r\n"),
			ptagEvaluateResult->dRowDistAverage,
			ptagEvaluateResult->dRowDistDeviation,
			ptagEvaluateResult->dRowDistMin,
			ptagEvaluateResult->dRowDistMax);

		strResult += strTemp;

		DWORD dwEndTime = GetTickCount() - dwStartTime;
		strTemp.Format(_T("Time - %dms"), dwEndTime);

		strResult += strTemp;

		sResult = strResult;

		//for (auto val : ptagEvaluateResult->vecRectangleLineResult)
		//{
		//	if (val)
		//		delete val;
		//	val = NULL;
		//}
		//ptagEvaluateResult = NULL;
		//delete ptagEvaluateResult;
	}
	else
	{
		CString strError;
		DWORD dwLastError = GetLastError();

		nResult = (int)dwLastError;

		switch (dwLastError)
		{
		case CALIBRATIONDLL_NOT_INITIALIZED:
			strError = _T("Blob parameters are not set.");
			break;
		case CALIBRATIONDLL_INVALID_IMAGE_PATH:
			strError = _T("Invalid Image Path.");
			break;
		case CALIBRATIONDLL_IMAGE_NOT_EXIST:
			strError = _T("Image file is not exist.");
			break;
		case CALIBRATIONDLL_EXE_NOT_EXIST:
			strError = _T("TeslaCal.exe is not exist.");
			break;
		case CALIBRATIONDLL_FAILED_EXE_RUN:
			strError = _T("Failed to run TeslaCal.exe");
			break;
		case CALIBRATIONDLL_FAILED_CALIBRATION:
			strError = _T("Failed to run calibraation.");
			break;
		case CALIBRATIONDLL_INVALID_OBJECT_SIZE:
			strError = _T("Invalid object size.");
			break;
		case CALIBRATIONDLL_FAILED_FIND_CIRCLE:
			strError = _T("Failed to find circles.");
			break;
		case CALIBRATIONDLL_FAILED_GENERATE_AREA:
			strError = _T("Failed to generate areas.");
			break;
		default:
			strError = _T("Unknown error.");
			break;
		}
		sResult = strError;
	}

	return nResult;
}
int CPRIFunc_Insp::func_EvaluateDefault(TCHAR *ptszImgPath, CString &sResult)
{
	int nResult = -1;
	DWORD dwStartTime = GetTickCount();
	WCHAR wstrImagePath[1024];
	int nLen = strlen(ptszImgPath) + 1;

	MultiByteToWideChar(CP_ACP, 0, ptszImgPath, -1, wstrImagePath, nLen - 1);
	wstrImagePath[nLen - 1] = 0;

	dwStartTime = GetTickCount();

	EVALUATE_RESULT *ptagEvaluateDefault = EvaluateUndistortDefault(wstrImagePath, 36, 24, true);
	if (ptagEvaluateDefault != NULL)
	{
		CString strResult = _T("Rectangle Test Result - Default Value\r\n");
		CString strTemp;

		for (int i = 0; i < 12; i++)
		{
			strTemp.Format(_T("[%02d] %lf\r\n"), i, (ptagEvaluateDefault->fRectangleLineResult[i]));
			strResult += strTemp;
		}

		strTemp.Format(_T("Col Straight Avrg : %lf\r\n"), ptagEvaluateDefault->dStraightCols);
		strResult += strTemp;

		strTemp.Format(_T("Row Straight Avrg : %lf\r\n"), ptagEvaluateDefault->dStraightRows);
		strResult += strTemp;

		strResult += _T("Dist (Average, Deviation, Min, Max)\r\n");

		strTemp.Format(_T("Col (%lf, %lf, %lf, %lf)\r\n"),
			ptagEvaluateDefault->dColDistAverage,
			ptagEvaluateDefault->dColDistDeviation,
			ptagEvaluateDefault->dColDistMin,
			ptagEvaluateDefault->dColDistMax);

		strResult += strTemp;

		strTemp.Format(_T("Row (%lf, %lf, %lf, %lf)\r\n"),
			ptagEvaluateDefault->dRowDistAverage,
			ptagEvaluateDefault->dRowDistDeviation,
			ptagEvaluateDefault->dRowDistMin,
			ptagEvaluateDefault->dRowDistMax);

		strResult += strTemp;

		DWORD dwEndTime = GetTickCount() - dwStartTime;
		strTemp.Format(_T("Time - %dms"), dwEndTime);

		strResult += strTemp;

		sResult = strResult;

		//for (auto val : ptagEvaluateDefault->vecRectangleLineResult)
		//{
		//	if (val)
		//		delete val;
		//	val = NULL;
		//}

		//delete ptagEvaluateDefault;
	}
	else
	{
		CString strError;
		DWORD dwLastError = GetLastError();

		switch (dwLastError)
		{
		case CALIBRATIONDLL_NOT_INITIALIZED:
			strError = _T("Blob parameters are not set.");
			break;
		case CALIBRATIONDLL_INVALID_IMAGE_PATH:
			strError = _T("Invalid Image Path.");
			break;
		case CALIBRATIONDLL_IMAGE_NOT_EXIST:
			strError = _T("Image file is not exist.");
			break;
		case CALIBRATIONDLL_EXE_NOT_EXIST:
			strError = _T("TeslaCal.exe is not exist.");
			break;
		case CALIBRATIONDLL_FAILED_EXE_RUN:
			strError = _T("Failed to run TeslaCal.exe");
			break;
		case CALIBRATIONDLL_FAILED_CALIBRATION:
			strError = _T("Failed to run calibraation.");
			break;
		case CALIBRATIONDLL_INVALID_OBJECT_SIZE:
			strError = _T("Invalid object size.");
			break;
		case CALIBRATIONDLL_FAILED_FIND_CIRCLE:
			strError = _T("Failed to find circles.");
			break;
		case CALIBRATIONDLL_FAILED_GENERATE_AREA:
			strError = _T("Failed to generate areas.");
			break;
		default:
			strError = _T("Unknown error.");
			break;
		}
		sResult = strError;
	}
	return nResult;
}