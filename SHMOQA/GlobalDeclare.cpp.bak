//-----------------------------------------------------------------------------
//
//	GlobalDeclare.cpp
//
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "GlobalDeclare.h"
#include "GlobalDefine.h"


CAutoInspDlg* g_pCarAABonderDlg;
CMessagePopupDlg* g_pMessagePopupDlg[MAX_POPUP_COUNT];
int g_nPopupIndex;

CSystemData g_clSysData;
CModelData g_clModelData[MAX_UNIT_COUNT];
CMarkData g_clMarkData[MAX_UNIT_COUNT];
CTaskWork g_clTaskWork[MAX_UNIT_COUNT];

CVision g_clVision;
CModelFinder g_clModelFinder;
CAxlMotorSet g_clMotorSet;
CDioControl  g_clDioControl;
CSimpleAdo g_clAdo;

CLaonGrabberWrapper g_clLaonGrabberWrapper[MAX_UNIT_COUNT];

CInspection_Alg g_clAlg[MAX_UNIT_COUNT];
CPRIFunc_Insp g_clPriInsp[MAX_UNIT_COUNT];
CMandoFinalSFR g_clMandoFinalSFR[MAX_UNIT_COUNT];

CMandoSfrSpec g_clMandoSfrSpec[MAX_UNIT_COUNT];
CMandoInspLog g_clMandoInspLog[MAX_UNIT_COUNT];
CMesCommunication g_clMesCommunication[MAX_UNIT_COUNT];

//CLightControl		LightControl;
CLightControl		LightControl[3];
//CQueue<STRUC_LOG_NODE*> g_clLogQueue;


//-----------------------------------------------------------------------------
//
//	현재 경로 구하기
//
//-----------------------------------------------------------------------------
unsigned int g_GetCurrentPath(TCHAR* pPath)
{
	unsigned int nLength;
	int i;

	nLength = GetModuleFileName(NULL, pPath, SIZE_OF_1K);
	if (nLength != 0)
	{
		for (i = nLength; i > 0; i--)
		{
			if (pPath[i - 1] == _T('\\'))
			{
				pPath[i] = NULL;
				return i;
			}
		}
	}

	return 0;
}
//////////////////////////////////////////////////////////////////////////
void eeprom_Data_Sum(CString WriteData, int WritebyteLength, int type, byte* rtnData, bool autoRun)
{
	unsigned char pData[MAX_PATH];
	int errorCode = 0;
	int i = 0;
	int j = 0;
	int leng = WriteData.GetLength();
	int byteLength = 0;
	int value = 0;
	float fNum = 0.0;
	double testnum = 0.0;
	CString strTemp;
	int startNum = 0;
	unsigned char szTemp[MAX_PATH];
	memset(pData, 0, sizeof(pData));
	memset(rtnData, 0, sizeof(WritebyteLength));

	if (type == FLOAT_MODE)
	{
		fNum = (float)_ttof(WriteData);//fNum = (_ttof(WriteData));//atof  //wtof
		memcpy(szTemp, &fNum, sizeof(float));//들어갈때 반대로 값이 들어간다 
	}
	else if (type == ASCII_MODE)
	{
		startNum = (WritebyteLength - leng);//(WritebyteLength - 1 - leng);
		strTemp = CovertToHex(WriteData, type);
	}
	else if (type == ASCII_MODE_2)
	{
		strTemp = CovertToHex(WriteData, type);
	}
	//ASCII_MODE_2
	strTemp.Replace(" ", "");
	byteLength = strTemp.GetLength();
	//
	switch (type)
	{
	case ASCII_MODE:
		leng = WritebyteLength;
		break;
	case ASCII_MODE_2:
		leng = 2;//3바트일경우만 쓸거라서
		memcpy(rtnData, strTemp.GetBuffer(0), byteLength);
		break;
	case FLOAT_MODE:
		leng = 4;
		for (i = 0; i < leng; i++)
		{
			strTemp.AppendFormat("%02X", szTemp[3 - i]);// szTemp[3 - x]);
		}
		break;
	case DEC_MODE:
		//
		leng = 1;
		//
		//dec -->hex로 바꾸는 코드
		value = _ttoi(WriteData);
		strTemp.Format("%x ", value);
		//
		break;
	case HEX_MODE:
		leng = WritebyteLength;
		strTemp.Format("%s", WriteData);//그대로 쓰는 코드
		break;
	}
	for (int i = 0; i < leng; i++)
	{
		if (type == ASCII_MODE)
		{
			if (i >= (startNum))
			{
				//value = (int)(WriteData[i - startNum]);
				pData[i] = (unsigned char)_tcstol(strTemp.Mid((i - startNum) * 2, 2), NULL, 16);
			}
			else
			{
				pData[i] = (unsigned char)_tcstol("20", NULL, 16);
			}
		}
		else if (type == ASCII_MODE_2)
		{
			pData[i] = (unsigned char)_tcstol(strTemp.Mid(i, (i + 1)), NULL, 16);
		}
		else
		{
			pData[i] = (unsigned char)_tcstol(strTemp.Mid(i * 2, 2), NULL, 16);//hex코드로 입력했을대기존코드

		}
		rtnData[i] = pData[i];
	}
}

CString CovertToHex(CString data, int type)
{
	CString rtnValue;
	CString temporary;
	unsigned char szTemp[1024];
	int value = 0;
	float fNum = 0.0;
	temporary.Empty();
	rtnValue.Empty();
	data.Replace(" ", "");
	memset(szTemp, 0x00, 1024);
	int len = 0;

	if (type == FLOAT_MODE)
	{
		fNum = (_ttof(data));
		memcpy(szTemp, &fNum, sizeof(float));
		len = 4;
	}
	else if (type == ASCII_MODE)
	{
		len = data.GetLength();
	}
	else if (type == ASCII_MODE_2)
	{
		len = 1;// data.GetLength();
	}
	else if (type == DEC_MODE)
	{
		len = 1;
	}
	for (int x = 0; x < len; x++)
	{
		if (type == FLOAT_MODE)
		{
			temporary.Format("%02X", szTemp[3 - x]);// szTemp[3 - x]);
													//Hex 로 변경
		}
		else if (type == ASCII_MODE)
		{
			value = (int)(data[x]);
			temporary.Format("%X", value);//temporary.Format("%02X", value);기존
										  //temporary.Format("%d", value);//
										  //ASCII : 입력된 String 을 ASCII Code 로 변경
		}
		else if (type == ASCII_MODE_2)
		{
			value = _ttoi(data);
			temporary.Format("%X", value);
		}
		else if (type == DEC_MODE)
		{
			value = _ttoi(data);
			temporary.Format("%X", value);
		}
		rtnValue += temporary;
	}
	return rtnValue;
}
CString CovertToChar(CString data, int mode)
{
	CString rtnValue;
	CString temporary;
	temporary.Empty();
	rtnValue.Empty();
	data.Replace(" ", "");
	int len = (int)data.GetLength();
	byte value;
	UINT32 AAA;
	float fNum = 0.0;
	if (mode == ASCII_MODE)
	{
		for (int x = 0; x < len; x++)//for (int x = 0; x < len; x += 2)
		{
			value = (byte)_tcstol(data.Mid(x * 2, 2), NULL, 16);
			temporary.Format("%c", value);
			rtnValue += temporary;
		}
	}
	else if (mode == FLOAT_MODE)
	{
		sscanf_s(data.GetBuffer(0), "%X", &AAA);
		fNum = *((float*)&AAA);
		rtnValue.Format("%f", fNum);
	}
	else if (mode == DEC_MODE)
	{
		value = (byte)_tcstol(data.Mid(0, 2), NULL, 16);
		temporary.Format("%X", value);
		rtnValue += temporary;
	}

	return rtnValue;
}

//-----------------------------------------------------------------------------
//
//	로그 큐 PUSH
//
//-----------------------------------------------------------------------------
void AddLog(CString str,int Balnk, int nUnit, bool buzzer)
{
    SYSTEMTIME stSysTime;
    CString sListLog;
    int nCount;

    GetLocalTime(&stSysTime);

    sListLog.Format(_T("[%02d:%02d:%02d.%03d] %s"), stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond, stSysTime.wMilliseconds, (TCHAR*)(LPCTSTR)str);

    nCount = g_pCarAABonderDlg->m_clListLog[nUnit].GetCount();
    if (nCount > 300)
    {
        g_pCarAABonderDlg->m_clListLog[nUnit].DeleteString(0);
    }
    nCount = g_pCarAABonderDlg->m_clListLog[nUnit].AddString(sListLog);
    g_pCarAABonderDlg->m_clListLog[nUnit].SetCurSel(nCount);
    LogSave(sListLog, nUnit);
    //LogModule.MainLogSave(sListLog, nUnit); //LogSave(sListLog);
}
void inspMES(int nUnit)
{
	int i = 0;
	//Defect
	for (i = 0; i < 14; i++)
	{
		if (g_clMesCommunication[nUnit].m_nMesDefectResult[i] == 0)
		{
			g_clMesCommunication[nUnit].m_nMesFinalResult = 0;
		}
	}


	//sfr
	for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
	{
		if (g_clMesCommunication[nUnit].m_nMesMTFResult[i] == 0)
		{
			g_clMesCommunication[nUnit].m_nMesFinalResult = 0;
		}
	}

	//oc
	for (i = 0; i < 2; i++)
	{
		if (g_clMesCommunication[nUnit].m_dMesOCResult[i] == 0)
		{
			g_clMesCommunication[nUnit].m_nMesFinalResult = 0;
		}
		if (g_clMesCommunication[nUnit].m_dMesDeltaOCResult[i] == 0)
		{
			g_clMesCommunication[nUnit].m_nMesFinalResult = 0;
		}
	}
	//Blemish
	for (i = 0; i < 3; i++)
	{
		if (g_clMesCommunication[nUnit].m_nMesBlemishResult[i] == 0)
		{
			g_clMesCommunication[nUnit].m_nMesFinalResult = 0;
		}

	}
}
void LogSave(CString logStr , int nUnit)
{
    TCHAR szPath[SIZE_OF_1K];
    SYSTEMTIME time;
    ::GetLocalTime(&time);

    FILE *out;

    CFileFind finder;
    BOOL IsFind;
    CString FolderName;
   
    FolderName.Format("%s\\%04d%02d\\%02d", BASE_LOG_PATH, time.wYear, time.wMonth, time.wDay);
    IsFind = finder.FindFile(FolderName);
    if (!IsFind)
    {
       /* FolderName.Format("%s", BASE_DIR);
        IsFind = finder.FindFile(FolderName);
        if (!IsFind)
        {
            CreateDirectory(FolderName, NULL);
        }

        FolderName.Format("%s", BASE_TP_DIR);
        IsFind = finder.FindFile(FolderName);
        if (!IsFind)
        {
            CreateDirectory(FolderName, NULL);
        }

        FolderName.Format("%s", BASE_LOG_PATH);
        IsFind = finder.FindFile(FolderName);
        if (!IsFind)
        {
            CreateDirectory(FolderName, NULL);
        }

        FolderName.Format("%s\\%04d%02d", BASE_LOG_PATH, time.wYear, time.wMonth);
        CreateDirectory(FolderName, NULL);*/
    }

    finder.Close();

    char fileName[1000];
    wsprintf(fileName, "%s\\%04d%02d%02d_LogDataAA.txt", FolderName, time.wYear, time.wMonth, time.wDay);
    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\AA%d\\%04d%02d\\%02d\\LogData-AA%d.txt"), BASE_LOG_PATH, nUnit + 1,
        time.wYear, time.wMonth, time.wDay, nUnit + 1);
    if (!fopen_s(&out, szPath, "a"))
    {
        fprintf_s(out, "%02d:%02d:%02d:%03d %s\n", time.wHour, time.wMinute, time.wSecond, time.wMilliseconds, logStr);
        fclose(out);
    }
}

void ResultSavePath(TCHAR* sPath, CString logStr)
{
	TCHAR szPath[SIZE_OF_1K];
	SYSTEMTIME time;
	::GetLocalTime(&time);

	FILE *out;

	CFileFind finder;
	BOOL IsFind;
	CString FolderName;

	FolderName.Format("%s", sPath);

	int nfindstr = FolderName.Find('.');

	FolderName = FolderName.Mid(0, nfindstr);

	IsFind = finder.FindFile(FolderName);
	if (!IsFind)
	{

	}
	finder.Close();

	char fileName[1000];
	//wsprintf(fileName, "%s\\%04d%02d%02d_RESULT.txt", FolderName, time.wYear, time.wMonth, time.wDay);
	_stprintf_s(szPath, SIZE_OF_1K, _T("%s_RSEULT.txt"), FolderName);
	if (!fopen_s(&out, szPath, "a"))
	{
		fprintf_s(out, "%s", logStr);
		fclose(out);
	}
}

void AddLog_old(TCHAR* szLog, int nLogType, int nUnit, bool bBuzzer/* = false*/)
{

	//SYSTEMTIME stSysTime;
	//GetLocalTime(&stSysTime);
	//CString sMsg = _T("");
	//
	//if (bBuzzer == true)
	//{//! Main 통신 추가
	//	sMsg.Format(_T("#AA%d@ALARM&ERR$"), nUnit + 1);
	//	g_pCarAABonderDlg->SendDataToAAMain(nUnit, sMsg);
	//}
	//
	//STRUC_LOG_NODE* pNode = new STRUC_LOG_NODE;
	//if (pNode != NULL)
	//{
	//	memset(pNode->szBuff, 0x00, sizeof(pNode->szBuff));

	//	_stprintf_s(pNode->szBuff, SIZE_OF_1K, _T("[%02d:%02d:%02d.%03d] %s"), stSysTime.wHour,
	//		stSysTime.wMinute, stSysTime.wSecond, stSysTime.wMilliseconds, szLog);
	//	pNode->nBuffSize = (int)_tcslen(pNode->szBuff);
	//	pNode->nLogType = nLogType;
	//	pNode->nUnit = nUnit;

	//	//g_clLogQueue.Push(pNode);
	//}
}

//-----------------------------------------------------------------------------
//
//	팝업창 표시
//
//-----------------------------------------------------------------------------
void g_ShowMsgPopup(CString sTitle, CString sMsg, COLORREF bgColor)
{
	int nIndex;
	int i;

	nIndex = g_nPopupIndex;

	for (i = 0; i < MAX_POPUP_COUNT; i++)
	{
		if (g_pMessagePopupDlg[i] != NULL)
		{
			if (g_pMessagePopupDlg[i]->IsWindowVisible() == FALSE)
			{
				g_nPopupIndex = i;
				break;
			}
		}
	}

	nIndex = g_nPopupIndex;
	if (g_pMessagePopupDlg[nIndex] != NULL)
	{
		if (g_pMessagePopupDlg[nIndex]->IsWindowVisible() == TRUE)
			g_pMessagePopupDlg[nIndex]->ShowWindow(SW_HIDE);

		g_pMessagePopupDlg[nIndex]->SetContents(sTitle, sMsg, MESSAGE_BG_COLOR, nIndex);
		g_pMessagePopupDlg[nIndex]->ShowWindow(SW_SHOW);
	}
}

//-----------------------------------------------------------------------------
//
//	Modal 창 표시
//
//-----------------------------------------------------------------------------
bool g_ShowMsgModal(CString sTitle, CString sMsg, COLORREF bgColor)
{
	CMessageModalDlg* pDlg = new CMessageModalDlg(sTitle, sMsg, bgColor);
	if (pDlg != NULL)
	{
		if (pDlg->DoModal() == IDYES)
		{
			delete pDlg;

			return true;
		}

		delete pDlg;
	}

	return false;
}

//-----------------------------------------------------------------------------
//
//	ASK 창 표시
//
//-----------------------------------------------------------------------------
int g_ShowMsgAsk(CString sTitle, CString sMsg, COLORREF bgColor, int nAskCount, TCHAR* pszAsk[])
{
	int nRetVal = 0;

	CMessageAskDlg* pDlg = new CMessageAskDlg(sTitle, sMsg, bgColor, nAskCount, pszAsk);
	if (pDlg != NULL)
	{
		nRetVal = (int)pDlg->DoModal();

		delete pDlg;
	}

	return nRetVal;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
int g_GetSFR(int nUnit, int nMode)
{
    TCHAR	szLog[SIZE_OF_1K];
    int i;

#ifdef ON_LINE_MIL
    g_clVision.ClearOverlay(nUnit);
#endif

    float fMaxSfrN4[MAX_SFR_INSP_CNT] = { 0.0, };
    float fMaxSfrN8[MAX_SFR_INSP_CNT] = { 0.0, };

#ifdef ON_LINE_MIL
    int nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_X, NULL);
    int nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_Y, NULL);
    int nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_PITCH, NULL);

    if (nSizeX <= 0 || nSizeY <= 0)
    {
        AddLog(_T("MilProcImageChild 사이즈 오류."), 1, nUnit);
        return -1;
    }
#endif

    for (i = 0; i < 4; i++)
    {
        g_clTaskWork[nUnit].m_stSfrInsp.clRectROI[i] = g_clModelData[nUnit].m_clSfrInfo.m_clRectCircle[i];
#ifdef ON_LINE_MIL
        g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRectROI[i], M_COLOR_GREEN, 1, FALSE, PS_DOT);
#endif
    }

    if (g_GetSfrRectROI(nUnit, nMode) == false)
    {
        g_clVision.DrawOverlayAll(nUnit);
        return -1;
    }
    
    //int boxIndex[12] = { SFR_CENTER_INDEX, SFR_LEFT_UP_INDEX, SFR_RIGHT_UP_INDEX, SFR_LEFT_DOWN_INDEX, SFR_RIGHT_DOWN_INDEX, SFR_CENTER_INDEX_2, SFR_LEFT_UP_INDEX_2, SFR_RIGHT_UP_INDEX_2, SFR_LEFT_DOWN_INDEX_2, SFR_RIGHT_DOWN_INDEX_2, SFR_CENTER_INDEX_3, SFR_CENTER_INDEX_4 };
    bool sfrRt = false;
    //int dic[20] = { 1,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1 };//수직 = 0 , 수평 = 1
    //double dFrequency[1] = { SFR_N_4_POSITION_X };
    //double dSfrFinalResult[MAX_SFR_INSP_CNT][1] = { { 0.0 }, }; // SFR result
    //std::shared_ptr<CACMISResolutionSFR> m_pChartProc = std::make_shared<CACMISResolutionSFR>();
    //std::shared_ptr<ResolutionImageBufferManager> mgr = std::make_shared<ResolutionImageBufferManager>((const VOIDTYPE*)g_clLaonGrabberWrapper[nUnit].m_pFrameRawBuffer, g_clModelData[nUnit].m_nWidth, g_clModelData[nUnit].m_nHeight, g_clModelData[nUnit].m_nWidth);
    //m_pChartProc->SetAlgorithmConfig(g_clModelData[nUnit].m_nRoiSizeX, g_clModelData[nUnit].m_nRoiSizeY, 45.0, 0, ESFRAlgorithm_ISO12233, ESFRMethod_Freq2SFR, ESFRFreq_CyclePerPixel, false);
    //(*mgr.get()).SetDataSpec(g_clLaonGrabberWrapper[nUnit].dTDATASPEC_n.eDataFormat, g_clLaonGrabberWrapper[nUnit].dTDATASPEC_n.eOutMode, g_clLaonGrabberWrapper[nUnit].dTDATASPEC_n.eSensorType, 0);
    //m_pChartProc->SetImageBuffer(*mgr.get());

    //new
    std::shared_ptr<CACMISResolutionSFR> m_pSFRProc = std::make_shared<CACMISResolutionSFR>();
    POINT ptROICenter[MAX_SFR_INSP_CNT];
    for (int i = 0; i < MAX_SFR_INSP_CNT; i++)
    {
        ptROICenter[i].x = g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].left + (g_clModelData[nUnit].m_nRoiSizeX / 2);
        ptROICenter[i].y = g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].top + (g_clModelData[nUnit].m_nRoiSizeY / 2);
        //
        g_clTaskWork[nUnit].m_vDirection[i] = g_clModelData[nUnit].m_nDirection[i]; // 0: Vertical, 1: Horizontal
        g_clTaskWork[nUnit].m_vFrquency[i] =  g_clModelData[nUnit].m_dLinePulse;//0.225
        g_clTaskWork[nUnit].m_vOffset[i] = 0.0;
        g_clTaskWork[nUnit].m_vSFR[i] = 0.0;
        g_clTaskWork[nUnit].m_vThreshold[i] = 0.0;
        g_clTaskWork[nUnit].m_vROI[i].ptCenter.x = ptROICenter[i].x;
        g_clTaskWork[nUnit].m_vROI[i].ptCenter.y = ptROICenter[i].y;
        g_clTaskWork[nUnit].m_vROI[i].nROIWidth = g_clModelData[nUnit].m_nDirection[i] == SFR_ROI_HORIZONTAL ? g_clModelData[nUnit].m_nRoiSizeX : g_clModelData[nUnit].m_nRoiSizeY;
        g_clTaskWork[nUnit].m_vROI[i].nROIHeight = g_clModelData[nUnit].m_nDirection[i] == SFR_ROI_HORIZONTAL ? g_clModelData[nUnit].m_nRoiSizeY : g_clModelData[nUnit].m_nRoiSizeX;
    }
    TSFRSpec m_stSFRSpec;
    m_stSFRSpec.tSFRConfig.nMaxROIWidth = g_clModelData[nUnit].m_nRoiSizeX;
    m_stSFRSpec.tSFRConfig.nMaxROIHeight = g_clModelData[nUnit].m_nRoiSizeY;
    m_stSFRSpec.tSFRConfig.dMaxEdgeAngle = 45.0;
    m_stSFRSpec.tSFRConfig.dPixelSize = g_clModelData[nUnit].m_dCcdCellSize;// 4.2;
    m_stSFRSpec.tSFRConfig.eAlgorithmType = ESFRAlgorithm_ISO12233;
    m_stSFRSpec.tSFRConfig.eAlgorithmMethod = ESFRMethod_Freq2SFR;
    m_stSFRSpec.tSFRConfig.eFrequencyUnit = ESFRFreq_LinePairPerMilliMeter;// ESFRFreq_CyclePerPixel;//ESFRFreq_LinePairPerMilliMeter
    m_stSFRSpec.eSFRDeltaAlgorithmType = ESFRDelta_Diff;
    m_stSFRSpec.dEdgeDir = g_clTaskWork[nUnit].m_vDirection.data();
    m_stSFRSpec.dFrequency = g_clTaskWork[nUnit].m_vFrquency.data();
    m_stSFRSpec.dSFR = g_clTaskWork[nUnit].m_vSFR.data();
    m_stSFRSpec.dThreshold = g_clTaskWork[nUnit].m_vThreshold.data();
    m_stSFRSpec.dGamma = 1.0;
    m_stSFRSpec.tROI.dOffset = g_clTaskWork[nUnit].m_vOffset.data();
    m_stSFRSpec.tROI.eROIType = ROIType_POINT;
    m_stSFRSpec.tROI.pROIData = g_clTaskWork[nUnit].m_vROI.data();
    m_stSFRSpec.tROI.ROICount = MAX_SFR_INSP_CNT;
    m_stSFRSpec.tDelataSpec = NULL;

    int nBlackLevel = 0;
    bool bRet = m_pSFRProc->Inspect(g_clLaonGrabberWrapper[nUnit].m_pFrameRawBuffer, 
        g_clModelData[nUnit].m_nWidth, g_clModelData[nUnit].m_nHeight,
        m_stSFRSpec, 
        g_clLaonGrabberWrapper[nUnit].dTDATASPEC_n.eDataFormat, g_clLaonGrabberWrapper[nUnit].dTDATASPEC_n.eOutMode, g_clLaonGrabberWrapper[nUnit].dTDATASPEC_n.eSensorType,
        nBlackLevel);
    //
    int sfrMax = m_pSFRProc->GetMaxResolutionCount();
    float sfrValue = 0.0;
	double _offset = 0.0;
    for (int i = 0; i < sfrMax; i++)
    {
        const TSFRROIResult* pROIResult = m_pSFRProc->GetSFRROIResult(i);
        sfrValue = pROIResult->dFinalResult[0];
        if (pROIResult)
        {
            if (!_finite(sfrValue))
            {
                g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] = 0.0;
            }
			else
			{
				g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] = sfrValue * g_clMandoSfrSpec[nUnit].m_dSfrOffsetMultiply; //20% UP 
				g_clMandoInspLog[nUnit].m_LogSfr[i] = g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i];
				fMaxSfrN4[i] = g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i];
            }

            _stprintf_s(szLog, SIZE_OF_1K, _T("SFR [%d]  =  %lf"), i, fMaxSfrN4[i]);

            AddLog(szLog, 1, nUnit);
        }
    }

#if  (____MODEL_NAME == TESLA_WIDE)
    int boxIndex[12] = {
        SFR_CENTER_INDEX,   SFR_LEFT_UP_INDEX_1_40,  SFR_RIGHT_UP_INDEX_1_40,    SFR_LEFT_DOWN_INDEX_1_40,   SFR_RIGHT_DOWN_INDEX_1_40,
        SFR_CENTER_INDEX_2, SFR_LEFT_UP_INDEX_2_40,  SFR_RIGHT_UP_INDEX_2_40,   SFR_LEFT_DOWN_INDEX_2_40,    SFR_RIGHT_DOWN_INDEX_2_40,
        SFR_CENTER_INDEX_3, SFR_CENTER_INDEX_4 };
#elif (____MODEL_NAME == TESLA_MAIN_NARROW)
    int boxIndex[12] = {
        SFR_CENTER_INDEX,   SFR_LEFT_CENTER_INDEX_1_40,  SFR_RIGHT_CENTER_INDEX_1_40,    SFR_LEFT_UP_INDEX,   SFR_RIGHT_UP_INDEX,
        SFR_CENTER_INDEX_2, SFR_LEFT_CENTER_INDEX_2_40,  SFR_RIGHT_DCENTER_INDEX_2_40,   SFR_LEFT_UP_INDEX_2, SFR_RIGHT_UP_INDEX_2,
        SFR_CENTER_INDEX_3, SFR_CENTER_INDEX_4 };
#endif
    


    int nStep = 0;// g_clTaskWork[nUnit].m_nCountOfTotalStepAA;
    int sfrIndex = 0;
    for (int i = 0; i < 5; i++)
    {
        if (i == 0)
        {
            g_clTaskWork[nUnit].m_stSfrInsp._fAverSfr[i] = (float)((fMaxSfrN4[boxIndex[i]] + fMaxSfrN4[boxIndex[i + 5]] + fMaxSfrN4[boxIndex[i + 10]] + fMaxSfrN4[boxIndex[i + 11]]) / 4.0);
        }
        else
        { 
            g_clTaskWork[nUnit].m_stSfrInsp._fAverSfr[i] = (float)((fMaxSfrN4[boxIndex[i]] + fMaxSfrN4[boxIndex[i + 5]]) / 2.0);
        }
    }

    //---------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------
    //Spec Check
    //---------------------------------------------------------------------------------------------------

	//
    _stprintf_s(szLog, SIZE_OF_1K, _T("[SFR] SPEC CHECK!! "));
    AddLog(szLog, 1, nUnit);
    char szTmp[256];
	bool sfrRtn = true;;
    CString NGData = _T("");
    double specTemp = 0.0;
	for (i = 0; i < sfrMax; i++)
	{
		
		specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_Spec[i][0][0];
		_stprintf_s(szTmp, SIZE_OF_100BYTE, _T("%d"), i);
		g_clVision.DrawMOverlayText(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].left + 10, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].top + 10, szTmp, M_COLOR_GREEN, _T("Arial"), 10, 12);
		if (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] < specTemp)
		{
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i], M_COLOR_RED, 1, FALSE);
		}
		else
		{
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i], M_COLOR_BLUE, 1, FALSE);
		}
		/*
		//spec 개별 비교

		if (g_clMesCommunication[nUnit].m_dMesMTF[i] < specTemp)
		{
			g_clMesCommunication[nUnit].m_nMesMTFResult[i] = 0;
			g_clMesCommunication[nUnit].m_nMesFinalResult = 0;
			sfrRtn = false;
			NGData.Format(_T("SFR[%d] SPEC ERROR : %.3lf(Spec :%.3lf)"),i, g_clMesCommunication[nUnit].m_dMesMTF[i], specTemp);
			_stprintf_s(szLog, SIZE_OF_1K, _T("SFR[%d] SPEC ERROR : %.3lf([Spec :%.3lf]"),i, g_clMesCommunication[nUnit].m_dMesMTF[i], specTemp);
			AddLog(szLog, 1, nUnit);
			if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
			{
				g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
				g_clMandoInspLog[nUnit].m_nNGCnt++;
			}
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i], M_COLOR_RED, 1, FALSE);
		}
		else
		{
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i], M_COLOR_BLUE, 1, FALSE);
			g_clMesCommunication[nUnit].m_nMesMTFResult[i] = 1;
		}*/
	}
		//
		//
		//spec 평균 비교
	double dCenter = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[0] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[1] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[2] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[3]) / 4;

	double dTL04 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[4] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[5]) / 2;
	double dTR04 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[6] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[7]) / 2;
	double dBL04 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[8] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[9]) / 2;
	double dBR04 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[10] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[11]) / 2;
	g_clMesCommunication[nUnit].m_dMesMTF[0] = dCenter;
	g_clMesCommunication[nUnit].m_dMesMTF[1] = dTL04;
	g_clMesCommunication[nUnit].m_dMesMTF[2] = dTR04;
	g_clMesCommunication[nUnit].m_dMesMTF[3] = dBL04;
	g_clMesCommunication[nUnit].m_dMesMTF[4] = dBR04;
	//
#if ____MODEL_NAME == TESLA_MAIN_NARROW
	double dTL08 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[12] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[13]) / 2;
	double dTR08 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[14] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[15]) / 2;
	double dBL08 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[16] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[17]) / 2;
	double dBR08 = (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[18] + g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[19]) / 2;
	g_clMesCommunication[nUnit].m_dMesMTF[5] = dTL08;
	g_clMesCommunication[nUnit].m_dMesMTF[6] = dTR08;
	g_clMesCommunication[nUnit].m_dMesMTF[7] = dBL08;
	g_clMesCommunication[nUnit].m_dMesMTF[8] = dBR08;

#endif
	for (i = 0; i < MAX_LAST_INSP_COUNT; i++)
	{
		g_clMesCommunication[nUnit].m_nMesMTFResult[i] = 1;

	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[0];
	if (dCenter < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[0] = 0;
		NGData.Format(_T("SFR CENTER SPEC ERROR : %.3lf(Spec :%.3lf)"), dCenter, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR CENTER SPEC ERROR : %.3lf([Spec :%.3lf]"), dCenter, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[1];

	if (dTL04 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[1] = 0;
		NGData.Format(_T("SFR 04FTL SPEC ERROR : %.3lf(Spec :%.3lf)"), dTL04, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 04FTL SPEC ERROR : %.3lf([Spec :%.3lf]"), dTL04, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[2];
	if (dTR04 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[2] = 0;
		NGData.Format(_T("SFR 04FTR SPEC ERROR : %.3lf(Spec :%.3lf)"), dTR04, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 04FTR SPEC ERROR : %.3lf([Spec :%.3lf]"), dTR04, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[3];
	if (dBL04 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[3] = 0;
		NGData.Format(_T("SFR 04FBL SPEC ERROR : %.3lf(Spec :%.3lf)"), dBL04, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 04FBL SPEC ERROR : %.3lf([Spec :%.3lf]"), dBL04, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[4];
	if (dBR04 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[4] = 0;
		NGData.Format(_T("SFR 04FBR SPEC ERROR : %.3lf(Spec :%.3lf)"), dBR04, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 04FBR SPEC ERROR : %.3lf([Spec :%.3lf]"), dBR04, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
#if ____MODEL_NAME == TESLA_MAIN_NARROW
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[5];
	if (dTL08 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[5] = 0;
		NGData.Format(_T("SFR 08FTL SPEC ERROR : %.3lf(Spec :%.3lf)"), dTL08, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 08FTL SPEC ERROR : %.3lf([Spec :%.3lf]"), dTL08, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[6];
	if (dTR08 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[6] = 0;
		NGData.Format(_T("SFR 084FTR SPEC ERROR : %.3lf(Spec :%.3lf)"), dTR08, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 08FTR SPEC ERROR : %.3lf([Spec :%.3lf]"), dTR08, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[7];
	if (dBL08 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[7] = 0;
		NGData.Format(_T("SFR 08FBL SPEC ERROR : %.3lf(Spec :%.3lf)"), dBL08, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 08FBL SPEC ERROR : %.3lf([Spec :%.3lf]"), dBL08, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
	specTemp = g_clMandoSfrSpec[nUnit].m_dAASFR_SumAveSpec[8];
	if (dBR08 < specTemp)
	{
		sfrRtn = false;
		g_clMesCommunication[nUnit].m_nMesMTFResult[8] = 0;
		NGData.Format(_T("SFR 08FBR SPEC ERROR : %.3lf(Spec :%.3lf)"), dBR08, specTemp);
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 08FBR SPEC ERROR : %.3lf([Spec :%.3lf]"), dBR08, specTemp);
		AddLog(szLog, 1, nUnit);
		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt] += NGData;
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
	}
#endif

    //여기에 SPEC 아웃인 BOX는 빨간색으로
	if (sfrRtn == false)
	{
		g_clMandoInspLog[nUnit].m_sNGList += _T(" [SFR NG]");
	}
	
    g_SaveLGITLog(nUnit, "SFR", m_pSFRProc->GetLogHeader(), m_pSFRProc->GetLogData());
    
    //---------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------
    //---------------------------------------------------------------------------------------------------
#ifdef ON_LINE_MIL
    g_clVision.DrawOverlayAll(nUnit);
#endif

    return 1;
}
//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
int g_GetMTF(int nUnit, int nMode)
{
	TCHAR	szLog[SIZE_OF_1K];
	int i;

#ifdef ON_LINE_MIL
	g_clVision.ClearOverlay(nUnit);
#endif

	float fMaxSfrN4[MAX_SFR_INSP_CNT] = { 0.0, };
	float fMaxSfrN8[MAX_SFR_INSP_CNT] = { 0.0, };

#ifdef ON_LINE_MIL
	int nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_X, NULL);
	int nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_Y, NULL);
	int nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_PITCH, NULL);

	if (nSizeX <= 0 || nSizeY <= 0)
	{
		AddLog(_T("MilProcImageChild 사이즈 오류."), 1, nUnit);
		return - 1;
	}
#endif

	for (i = 0; i < 4; i++)
	{
		g_clTaskWork[nUnit].m_stSfrInsp.clRectROI[i] = g_clModelData[nUnit].m_clSfrInfo.m_clRectCircle[i];
#ifdef ON_LINE_MIL
		g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRectROI[i], M_COLOR_GREEN, 1, FALSE, PS_DOT);
#endif
	}
	
	if (g_GetSfrRectROI(nUnit, nMode) == false)
	{
		g_clVision.DrawOverlayAll(nUnit);
		return -1;
	}	

	for (i = 0; i < MAX_SFR_INSP_CNT; i++)
	{
		if (nMode != SFR_FINAL)
		{
			if ((i != SFR_CENTER_INDEX) && (i != SFR_CENTER_INDEX_2) && (i != SFR_CENTER_INDEX_3) && (i != SFR_CENTER_INDEX_4) &&
				(i != SFR_LEFT_UP_INDEX) && (i != SFR_RIGHT_UP_INDEX) && (i != SFR_RIGHT_DOWN_INDEX) && (i != SFR_LEFT_DOWN_INDEX) &&
				(i != SFR_LEFT_UP_INDEX_2) && (i != SFR_RIGHT_UP_INDEX_2) && (i != SFR_RIGHT_DOWN_INDEX_2) && (i != SFR_LEFT_DOWN_INDEX_2))
				continue;
		}

		if (g_GetPatchCenterAndSFR(nUnit, i) == false && (i < MAX_MTF_COUNT))
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[SFR 측정] SFR 계산 실패 : POS (%d)"), i);
			AddLog(szLog, 1, nUnit);
			return -1;
		}

		if (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] > fMaxSfrN4[i])
		{
			fMaxSfrN4[i] = g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i];
			fMaxSfrN8[i] = g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN8[i];
		}
	}	

	int curIndexA;
	int boxIndex[12] = { SFR_CENTER_INDEX, SFR_LEFT_UP_INDEX, SFR_RIGHT_UP_INDEX, SFR_LEFT_DOWN_INDEX, SFR_RIGHT_DOWN_INDEX, SFR_CENTER_INDEX_2, SFR_LEFT_UP_INDEX_2, SFR_RIGHT_UP_INDEX_2, SFR_LEFT_DOWN_INDEX_2, SFR_RIGHT_DOWN_INDEX_2, SFR_CENTER_INDEX_3, SFR_CENTER_INDEX_4 };
	int nStep = g_clTaskWork[nUnit].m_nCountOfTotalStepAA;

	for (int i = 0; i < 5; i++)
	{
		curIndexA = boxIndex[i];

		if (i == 0)
		{
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][i] = (float)((fMaxSfrN4[boxIndex[i]] + fMaxSfrN4[boxIndex[i + 5]] + fMaxSfrN4[boxIndex[i + 10]] + fMaxSfrN4[boxIndex[i + 11]]) / 4.0);
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStep][i] = (float)((fMaxSfrN8[boxIndex[i]] + fMaxSfrN8[boxIndex[i + 5]] + fMaxSfrN8[boxIndex[i + 10]] + fMaxSfrN8[boxIndex[i + 11]]) / 4.0);

			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].x =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].right) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].right) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].right) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].right) / 2.0)) / 4.0;

			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].y =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].bottom) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].bottom) / 2.0) +
					((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].bottom) / 2.0) +
					((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].bottom) / 2.0)) / 4.0;
		}
		else
		{
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][i] = (float)((fMaxSfrN4[boxIndex[i]] + fMaxSfrN4[boxIndex[i + 5]]) / 2.0);
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStep][i] = (float)((fMaxSfrN8[boxIndex[i]] + fMaxSfrN8[boxIndex[i + 5]]) / 2.0);

			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].x =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].right) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].right) / 2.0)) / 2.0;
			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].y =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].bottom) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].bottom) / 2.0)) / 2.0;
		}
	}

	/*for (int i = MOTOR_LENS_X; i <= MOTOR_LENS_TY; i++)
	{
		if ((i == MOTOR_LENS_TY) || (i == MOTOR_PCB_TX) || (i == MOTOR_PCB_TY))
		{
			g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStep][i - MOTOR_LENS_X] = (float)g_clMotorSet.GetCommandPos(nUnit, i);
		}
		else
		{
#ifdef ON_LINE_MOTOR		
			g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStep][i - MOTOR_LENS_X] = (float)g_clMotorSet.GetEncoderPos(nUnit, i);
#endif
		}
	}*/

	//! Log Save 추가 해야함.
	//if (!saveSfrLog(Mode))
	//{
	//	return -1;
	//}

	if (g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][0] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][1] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][2] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][3] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][4] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF)
	{/* 센터 MTF 값이 리미트 이상이면 fine pitch 이동 */
		g_clTaskWork[nUnit].m_bFlagFineMove = true;
	}
		
	//g_clTaskWork.m_nCountOfTotalStepAA++;
	//TRACE("g_clTaskWork.m_nCountOfTotalStepAA=================>%d\n", g_clTaskWork.m_nCountOfTotalStepAA);

	if (nMode == SFR_FINAL)
	{
		for (int i = 0; i < MAX_SFR_INSP_COUNT; i++)
		{
			g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] = fMaxSfrN4[i];
			g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN8[i] = fMaxSfrN8[i];
		}
	}

	if (nMode != 2)
	{
		//g_pCarAABonderDlg->DrawGraph(2);
	}
	
#ifdef ON_LINE_MIL
	g_clVision.DrawOverlayAll(nUnit);
#endif

	return 1;
}

//-----------------------------------------------------------------------------
//
//	원형마크 찾은 결과를 바탕으로 SFR 사각 영역을 정한다.
//
//-----------------------------------------------------------------------------
bool g_GetSfrRectROI(int nUnit, int nMode)
{
	int nPitch, nSizeX, nSizeY;
	int nHeightX, nHeightY, nWidthX, nWidthY;
	int nModelHeightX, nModelHeightY, nModelWidthX, nModelWidthY;
	double dRadX, dRadY, dModelRadX, dModelRadY;
	double dDegX, dDegY, dModelDegX, dModelDegY;
	double dRadAvg;
    TCHAR szPos[SIZE_OF_100BYTE];
    CString sLog;

	nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_PITCH, M_NULL);
	nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_X, M_NULL);
	nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_Y, M_NULL);

    //원형마크 찾기
	if (g_FindCirclePos(nUnit, g_clVision.m_pImgBuff[nUnit][1], nPitch, nSizeX, nSizeY, g_clModelData[nUnit].m_clSfrInfo.m_clRectCircle) == false)
		return false;
    //
	nHeightX = ((g_clTaskWork[nUnit].m_clPtCircle[0].y - g_clTaskWork[nUnit].m_clPtCircle[1].y) + (g_clTaskWork[nUnit].m_clPtCircle[2].y - g_clTaskWork[nUnit].m_clPtCircle[3].y)) / 2;
	nWidthX = ((g_clTaskWork[nUnit].m_clPtCircle[1].x - g_clTaskWork[nUnit].m_clPtCircle[0].x) + (g_clTaskWork[nUnit].m_clPtCircle[3].x - g_clTaskWork[nUnit].m_clPtCircle[2].x)) / 2;
	nHeightY = ((g_clTaskWork[nUnit].m_clPtCircle[2].x - g_clTaskWork[nUnit].m_clPtCircle[0].x) + (g_clTaskWork[nUnit].m_clPtCircle[3].x - g_clTaskWork[nUnit].m_clPtCircle[1].x)) / 2;
	nWidthY = ((g_clTaskWork[nUnit].m_clPtCircle[2].y - g_clTaskWork[nUnit].m_clPtCircle[0].y) + (g_clTaskWork[nUnit].m_clPtCircle[3].y - g_clTaskWork[nUnit].m_clPtCircle[1].y)) / 2;


	if (nWidthX != 0)
		dRadX = atan((double)nHeightX / (double)nWidthX);
	else
		dRadX = 0.0;

	if (nWidthY != 0)
		dRadY = atan((double)nHeightY / (double)nWidthY);
	else
		dRadY = 0.0;

	dDegX = dRadX * 180.0 / M_PI;
	dDegY = dRadY * 180.0 / M_PI;

	nModelHeightX = ((g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].y - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].y) + (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].y - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].y)) / 2;
	nModelWidthX = ((g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].x - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].x) + (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].x - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].x)) / 2;
	nModelHeightY = ((g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].x - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].x) + (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].x - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].x)) / 2;
	nModelWidthY = ((g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].y - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].y) + (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].y - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].y)) / 2;

	if (nModelWidthX != 0)
		dModelRadX = atan((double)nModelHeightX / (double)nWidthX/*nModelWidthX*/);
	else
		dModelRadX = 0.0;

	if (nModelWidthY != 0)
		dModelRadY = atan((double)nModelHeightY / (double)nModelWidthY);
	else
		dModelRadY = 0.0;

	dModelDegX = dModelRadX * 180.0 / M_PI;
	dModelDegY = dModelRadY * 180.0 / M_PI;

	dRadAvg = ((dRadX + dRadY) - (dModelRadX + dModelRadY)) / 2.0;

	int nCenterX, nCenterY;
	int nShiftX, nShiftY;
	double dExpandX = 0.0, dExpandY = 0.0;
	int nExpandXUpper, nExpandXLower;
	int nExpandYUpper, nExpandYLower;

	nCenterX = (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].x + g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].x + g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].x + g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].x) / 4;
	nCenterY = (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].y + g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].y + g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].y + g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].y) / 4;

	nShiftX = nCenterX - (g_clTaskWork[nUnit].m_clPtCircle[0].x + g_clTaskWork[nUnit].m_clPtCircle[1].x + g_clTaskWork[nUnit].m_clPtCircle[2].x + g_clTaskWork[nUnit].m_clPtCircle[3].x) / 4;
	nShiftY = nCenterY - (g_clTaskWork[nUnit].m_clPtCircle[0].y + g_clTaskWork[nUnit].m_clPtCircle[1].y + g_clTaskWork[nUnit].m_clPtCircle[2].y + g_clTaskWork[nUnit].m_clPtCircle[3].y) / 4;

	nExpandXUpper = ((g_clTaskWork[nUnit].m_clPtCircle[1].x - g_clTaskWork[nUnit].m_clPtCircle[0].x) + (g_clTaskWork[nUnit].m_clPtCircle[3].x - g_clTaskWork[nUnit].m_clPtCircle[2].x)) / 2;
	nExpandXLower = ((g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].x - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].x) + (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].x - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].x)) / 2;

	if (nExpandXLower != 0)
		dExpandX = (double)nExpandXUpper / (double)nExpandXLower;
	else
		dExpandX = 0.0;

	nExpandYUpper = ((g_clTaskWork[nUnit].m_clPtCircle[2].y - g_clTaskWork[nUnit].m_clPtCircle[0].y) + (g_clTaskWork[nUnit].m_clPtCircle[3].y - g_clTaskWork[nUnit].m_clPtCircle[1].y)) / 2;
	nExpandYLower = ((g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[2].y - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[0].y) + (g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[3].y - g_clModelData[nUnit].m_clSfrInfo.m_clPtCircle[1].y)) / 2;

	if (nExpandYLower != 0)
		dExpandY = (double)nExpandYUpper / (double)nExpandYLower;

	double dCosVal = cos(dRadAvg);
	double dSinVal = sin(dRadAvg);

	int nSx, nSy, nEx, nEy;
	int nUpperX = 0, nUpperY = 0;
	int nLowerX = 0, nLowerY = 0;
	int nMaxThreshold = -1, nMaxThreshold2 = -1;
	int nCount;
	int i;

    nCount = MAX_LAST_INSP_COUNT;

	for (i = 0; i < nCount; i++)
	{
		// 구자현 수정.
		if (nMode != SFR_FINAL)
		{
			if (i == 1)
				i = 7;
		}

		//////////////////////////////////////////////////////////////////////////////////////////

		//nSx = (int)(nCenterX - (nCenterX - g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].x) * dExpandX - nShiftX + 0.5);
		//nSy = (int)(nCenterY - (nCenterY - g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].y) * dExpandY - nShiftY + 0.5);

		////		vision.crosslist[CCD].addList(iSx, iSy, 100, M_COLOR_GREEN);		

		//double	dCenX = (g_clTaskWork[nUnit].m_clPtCircle[0].x + g_clTaskWork[nUnit].m_clPtCircle[1].x + g_clTaskWork[nUnit].m_clPtCircle[2].x + g_clTaskWork[nUnit].m_clPtCircle[3].x) / 4;
		//double	dCenY = (g_clTaskWork[nUnit].m_clPtCircle[0].y + g_clTaskWork[nUnit].m_clPtCircle[1].y + g_clTaskWork[nUnit].m_clPtCircle[2].y + g_clTaskWork[nUnit].m_clPtCircle[3].y) / 4;

		//double	dTempX = nSx - dCenX;
		//double	dTempY = dCenY - nSy;

		//double	dRotX = (dCosVal * dTempX) - (dSinVal * dTempY);
		//double	dRotY = (dSinVal * dTempX) + (dCosVal * dTempY);

		//double	dRealX = dRotX + dCenX;
		//double	dRealY = dCenY - dRotY;

		int offsetX = g_clTaskWork[nUnit].m_dOcResultX;
		int offsetY = g_clTaskWork[nUnit].m_dOcResultY;// *-1;
		double dCenterX = nSizeX / 2;
		double dCenterY = nSizeY / 2;
		int nShiftX = dCenterX - (g_clTaskWork[nUnit].m_clPtCircle[0].x + g_clTaskWork[nUnit].m_clPtCircle[1].x + g_clTaskWork[nUnit].m_clPtCircle[2].x + g_clTaskWork[nUnit].m_clPtCircle[3].x) / 4;
		int nShiftY = dCenterY - (g_clTaskWork[nUnit].m_clPtCircle[0].y + g_clTaskWork[nUnit].m_clPtCircle[1].y + g_clTaskWork[nUnit].m_clPtCircle[2].y + g_clTaskWork[nUnit].m_clPtCircle[3].y) / 4;

		offsetX += nShiftX;
		offsetY += nShiftY * -1;

		offsetX = (g_clModelData[nUnit].m_clSfrInfo.m_dSfrOcX - g_clTaskWork[nUnit].m_dOcResultX) * -1;
		offsetY = (g_clModelData[nUnit].m_clSfrInfo.m_dSfrOcY - g_clTaskWork[nUnit].m_dOcResultY) * -1;

		nSx = g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].x + offsetX; //(int)(dRealX + 0.5);
		nSy = g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].y + offsetY;//(int)(dRealY + 0.5);

		nEx = (int)(nSx + g_clModelData[nUnit].m_clSfrInfo.m_nSizeX + offsetX); // + 0.5);
		nEy = (int)(nSy + g_clModelData[nUnit].m_clSfrInfo.m_nSizeY + offsetY);//( + 0.5);

		if (nSx < 0)	nSx = 0;
		if (nSy < 0)	nSy = 0;
		if (nEx > nSizeX)	nEx = nSizeX - 1;
		if (nEy > nSizeY)	nEy = nSizeY - 1;

		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].left = nSx;
		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].top = nSy;
		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].right = nEx;
		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].bottom = nEy;

		TRACE(_T("[%d] ===> LEFT:%d, TOP:%d, RIGHT:%d, BOTTOM:%d\n"), i, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].left,
			g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].top, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].right,
			g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].bottom);
        //
        //
        bool rtn = false;
        rtn = findRectPosPattern(nUnit, g_clVision.m_pImgBuff[nUnit][2], nPitch, nSizeX, nSizeY, i, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i]);
        if (rtn)
        {
            g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i], M_COLOR_MAGENTA, 1, FALSE, PS_SOLID);
        }
        else
        {
            g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i], M_COLOR_RED, 1, FALSE, PS_SOLID);
        }
        //
        if (findSmallSfrRectPos(nUnit, g_clVision.m_pImgBuff[nUnit][2], nPitch, nSizeX, nSizeY, i, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i]) == false)
        {
            //g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i], M_COLOR_RED, 1, FALSE, PS_DOT);
            continue;
        }
//기존코드
		/*if (g_FindRectPos2(nUnit, g_clVision.m_pImgBuff[nUnit][2], nPitch, nSizeX, nSizeY, i, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i]) == false)
		{
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i], M_COLOR_RED, 1, FALSE, PS_SOLID);
			continue;
		}
		g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i], M_COLOR_MAGENTA, 1, FALSE, PS_SOLID);
        
		if (g_FindSfrRectPos(nUnit, g_clVision.m_pImgBuff[nUnit][2], nPitch, nSizeX, nSizeY, i, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i]) == false)
		{
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i], M_COLOR_RED, 1, FALSE, PS_DOT);
			continue;
		}*/ 
//

	}

	g_clVision.DrawOverlayAll(nUnit);

	return true;
}
//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_FindFovPos(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, CRect* clRectRoi)
{
    int maxSize = 50;

    TCHAR szLog[SIZE_OF_1K];

    if (pImage == NULL)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("영상 버퍼가 잘못되었습니다."));
        AddLog(szLog, 1, nUnit);
        return false;
    }

    if (nSizeX <= 0 || nSizeY <= 0)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("영상 사이즈가 잘못되었습니다. ( X : %d Y : %d )"), nSizeX, nSizeY);
        AddLog(szLog, 1, nUnit);

        return false;
    }

    int aiHistX[5000];
    int aiHistY[5000];
	int offsetX = g_clTaskWork[nUnit].m_dOcResultX;
	int offsetY = g_clTaskWork[nUnit].m_dOcResultY;// *-1;
	//double dCenterX = nSizeX / 2;
	//double dCenterY = nSizeY / 2;
	//int nShiftX = dCenterX - (g_clTaskWork[nUnit].m_clPtCircle[0].x + g_clTaskWork[nUnit].m_clPtCircle[1].x + g_clTaskWork[nUnit].m_clPtCircle[2].x + g_clTaskWork[nUnit].m_clPtCircle[3].x) / 4;
	//int nShiftY = dCenterY - (g_clTaskWork[nUnit].m_clPtCircle[0].y + g_clTaskWork[nUnit].m_clPtCircle[1].y + g_clTaskWork[nUnit].m_clPtCircle[2].y + g_clTaskWork[nUnit].m_clPtCircle[3].y) / 4;
	
	offsetX = (g_clModelData[nUnit].m_clSfrInfo.m_dFovOcX - g_clTaskWork[nUnit].m_dOcResultX) * -1;
	offsetY = (g_clModelData[nUnit].m_clSfrInfo.m_dFovOcY - g_clTaskWork[nUnit].m_dOcResultY) * -1;

	//offsetX = nShiftX * -1;
	//offsetY = nShiftY * -1;

	//CRect m_clRectFovTemp;
	//m_clRectFovTemp = g_clModelData[nUnit].m_clSfrInfo.m_clRectFov;
	/*clRectRoi->left += offsetX;
	clRectRoi->right += offsetX;
	clRectRoi->bottom += offsetY;
	clRectRoi->top += offsetY;
*/
	//g_clVision.DrawMOverlayBox(nUnit,m_clRectFovTemp,M_COLOR_DARK_YELLOW, 1, FALSE, PS_SOLID);
	//g_clVision.DrawOverlayAll(nUnit);

    for (int i = 0; i < MAX_FOV_COUNT; i++)
    {
		clRectRoi[i].left += offsetX; 
		clRectRoi[i].top += offsetY;
		clRectRoi[i].right += offsetX;
		clRectRoi[i].bottom += offsetY;

        if (i > 2 && i < 6)continue;
        if (clRectRoi[i].left < 0 || clRectRoi[i].top < 0 || clRectRoi[i].right > nSizeX || clRectRoi[i].bottom > nSizeY)
        {
			_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] FOV 검색 영역이 잘못되었습니다. ( L %d,  T %d,  R %d,  B %d )"), i + 1, clRectRoi[i].left, clRectRoi[i].top, clRectRoi[i].right, clRectRoi[i].bottom);
			if (clRectRoi[i].left < 0)
				clRectRoi[i].left = 1;
			if(clRectRoi[i].top < 0)
				clRectRoi[i].top = 1;
			if (clRectRoi[i].right > nSizeX)
				clRectRoi[i].right = nSizeX;
			if (clRectRoi[i].bottom > nSizeY)
				clRectRoi[i].bottom = nSizeY;
            AddLog(szLog, 0, nUnit);
            //return false;
        }

        int iSx, iSy, iEx, iEy;
        int x, y, iPos;
        int iMaxX = -1, iMinX = 9999;
        int iMaxY = -1, iMinY = 9999;
        int iMax_Left = -1, iMax_Right = -1, iMax_Up = -1, iMax_Down = -1;

        int iMaxX2 = -1, iMinX2 = 9999;
        int iMaxY2 = -1, iMinY2 = 9999;
        int iMax_Left2 = -1, iMax_Right2 = -1, iMax_Up2 = -1, iMax_Down2 = -1;

        int iSum;
        int iGap;

        int iSum_Left, iSum_Right;
        int iSum_Top, iSum_Bottom;

        iSx = clRectRoi[i].left;
        iSy = clRectRoi[i].top;
        iEx = clRectRoi[i].right;
        iEy = clRectRoi[i].bottom;

        ::memset(aiHistY, 0, sizeof(int)*(5000));
        ::memset(aiHistX, 0, sizeof(int)*(5000));


        /* X방향 히스토그램 */
        for (x = iSx; x < iEx; x++)
        {
            iPos = iSy * nPitch + x;
            iSum = 0;

            for (y = iSy; y < iEy; y++)
            {
                //				iSum += (ucImage[iPos]*ucImage[iPos]);
                iSum += (pImage[iPos]);
                iPos += nPitch;
            }

            aiHistX[x - iSx] = iSum;
        }

        /* X방향부터 엣지 찾기 */
        for (x = iSx + 5; x < iEx - 5; x++)
        {
            iSum_Left = aiHistX[x - iSx - 4] + aiHistX[x - iSx - 3] + aiHistX[x - iSx - 2] + aiHistX[x - iSx - 1];
            iSum_Right = aiHistX[x - iSx + 4] + aiHistX[x - iSx + 3] + aiHistX[x - iSx + 2] + aiHistX[x - iSx + 1];


            iGap = iSum_Left - iSum_Right;
			
            if (iGap > 300 && iGap > iMax_Left)
            { 
                iMax_Left = iGap;
                iMinX = x; 
            }
			
            iGap = iSum_Right - iSum_Left;
			
            if (iGap>300 && iGap > iMax_Right)
            {
                iMax_Right = iGap;
                iMaxX = x;
            }
        }


        iMax_Left = 0;
        iMinX2 = 0;
        int tmpSx = iMaxX - 400;
        int tmpEx = iMinX - 30;
        if (tmpSx < (iSx + 5))
            tmpSx = (iSx + 5);
        if (tmpEx >(iEx - 5))
            tmpEx = (iSx - 5);

        for (x = tmpSx; x < iMaxX; x++)
        {
            iSum_Left = aiHistX[x - iSx - 4] + aiHistX[x - iSx - 3] + aiHistX[x - iSx - 2] + aiHistX[x - iSx - 1];
            iSum_Right = aiHistX[x - iSx + 4] + aiHistX[x - iSx + 3] + aiHistX[x - iSx + 2] + aiHistX[x - iSx + 1];

            iGap = iSum_Left - iSum_Right;

            if (iGap>400 && iGap > iMax_Left)
            {
                iMax_Left = iGap;
                iMinX2 = x;
            }
        }


        iMax_Right = 0;
        iMaxX2 = 0;

        tmpSx = iMinX + 30;
        tmpEx = iMinX + 400;
        if (tmpSx < (iSx + 5))
            tmpSx = (iSx + 5);
        if (tmpEx >(iEx - 5))
            tmpEx = (iEx - 5);


        for (x = tmpSx; x < tmpEx; x++)
        {
            iSum_Left = aiHistX[x - iSx - 4] + aiHistX[x - iSx - 3] + aiHistX[x - iSx - 2] + aiHistX[x - iSx - 1];
            iSum_Right = aiHistX[x - iSx + 4] + aiHistX[x - iSx + 3] + aiHistX[x - iSx + 2] + aiHistX[x - iSx + 1];

            iGap = iSum_Right - iSum_Left;

			//원형마크 크게 찾느거 400에서 600으로 수정해서 해결
			if (iGap > 600 && iGap > iMax_Right)//if (iGap > 400 && iGap > iMax_Right)
            {
                iMax_Right = iGap;
                iMaxX2 = x;
            }
        }


        if (iMaxX - iMinX > 30 && iMaxX - iMinX < maxSize && iMinX > 0)
        {
            iMinX = iMinX;
            iMaxX = iMaxX;
        }
        else if (iMaxX2 - iMinX > 30 && iMaxX2 - iMinX < maxSize && iMinX > 0)
        {
            iMinX = iMinX;
            iMaxX = iMaxX2;
        }
        else if (iMaxX - iMinX2 > 30 && iMaxX - iMinX2 < maxSize && iMinX2 > 0)
        {
            iMinX = iMinX2;
            iMaxX = iMaxX;
        }

        /* Y 방향 히스토그램 */
        for (y = iSy; y < iEy; y++)
        {
            iPos = y * nPitch + iMinX;
            iSum = 0;

            for (x = iMinX; x<iMaxX; x++)
            {
                iSum += pImage[iPos++];
            }

            aiHistY[y - iSy] = iSum;
        }

        for (y = iSy + 5; y < iEy - 5; y++)
        {
            iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
            iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

            iGap = iSum_Top - iSum_Bottom;

            if (iGap > iMax_Up)
            {
                iMax_Up = iGap;
                iMinY = y;
            }

            iGap = iSum_Bottom - iSum_Top;

            if (iGap > iMax_Down)
            {
                iMax_Down = iGap;
                iMaxY = y;
            }
        }


        if (iMinY >= iMaxY)
        {
            int iMinY2 = -9999;
            int iMaxY2 = -9999;
            int iMax_Up2 = 0;
            int iMax_Down2 = 0;

            int tmpSy = iMinY + 5;
            int tmpEy = iEy - 5;

            for (y = tmpSy; y < tmpEy; y++)
            {
                iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
                iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

                iGap = iSum_Bottom - iSum_Top;

                if (iGap > iMax_Down2 && (iGap>1000))
                {
                    iMax_Down2 = iGap;
                    iMaxY2 = y;
                }
            }


            tmpSy = iSy + 5;
            tmpEy = iMaxY - 5;

            for (y = tmpSy; y < tmpEy; y++)
            {
                iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
                iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

                iGap = iSum_Top - iSum_Bottom;

                if (iGap > iMax_Up2 && (iGap>1000))
                {
                    iMax_Up2 = iGap;
                    iMinY2 = y;
                }
            }

            if ((iMaxY - iMinY2) > 50 && (iMaxY - iMinY2) < 250)
            {
                iMinY = iMinY2;
            }
            else if ((iMaxY2 - iMinY) > 50 && (iMaxY2 - iMinY) < 250)
            {
                iMaxY = iMaxY2;
            }
        }
        else if ((iMaxY - iMinY) > 400)
        {
            int iMaxY2 = -9999;
            int iMinY2 = -9999;
            int iMax_Up2 = 0;
            int iMax_Down2 = 0;

            int tmpSy = iMinY + 5;
            int tmpEy = iMaxY - 5;

            for (y = tmpSy; y < tmpEy; y++)
            {
                iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
                iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

                iGap = iSum_Top - iSum_Bottom;

                if (iGap > iMax_Up2 && (iGap > 1000))
                {
                    iMax_Up2 = iGap;
                    iMinY2 = y;
                }

                iGap = iSum_Bottom - iSum_Top;

                if (iGap > iMax_Down2 && (iGap > 1000))
                {
                    iMax_Down2 = iGap;
                    iMaxY2 = y;
                }
            }

            if ((iMinY2 > 0) && ((iMaxY - iMinY2) > 50 && (iMaxY - iMinY2) < 250))
            {
                iMinY = iMinY2;
            }
            else if ((iMaxY2 > 0) && ((iMaxY2 - iMinY) > 50 && (iMaxY2 - iMinY) < 250))
            {
                iMaxY = iMaxY2;
            }
        }


        if (iMinX > iMaxX || (iMaxX - iMinX > maxSize))
        {
			if (iMinY == iMaxY)
			{
				iMaxY += 50;
			}
            g_clVision.DrawMOverlayBox(nUnit, iMinX, iMinY, iMaxX, iMaxY, M_COLOR_RED,1, FALSE, PS_SOLID);

            _stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 좌우 인식 위치가 비정상 입니다. (좌 %d, 우 %d)"), i + 1, iMinX, iMaxX);
            AddLog(szLog, 0, nUnit);
            return false;
        }


        if (iMinY > iMaxY || (iMaxY - iMinY > maxSize))
        {
            g_clVision.DrawMOverlayBox(nUnit, iMinX, iMinY, iMaxX, iMaxY, M_COLOR_RED, 2, FALSE, PS_SOLID);

            _stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 상하 인식 위치가 비정상 입니다. (상 %d, 하 %d)"), i + 1, iMinY, iMaxY);
            AddLog(szLog, 0, nUnit);
            return false;
        }


        if (iMaxX < 0 || iMaxY < 0 || iMaxX > nSizeX || iMaxY > nSizeY ||
            iMinX < 0 || iMinY < 0 || iMinX > nSizeX || iMinY > nSizeY)
        {
            _stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] Max, Min 위치를 찾지 못했습니다."), i + 1);
            AddLog(szLog, 0, nUnit);
            return false;
        }
#ifdef ON_LINE_MIL
		g_clVision.DrawMOverlayBox(nUnit, clRectRoi[i], M_COLOR_GREEN, 1, FALSE, PS_DOT);
		//g_clVision.DrawMOverlayBox(nUnit, g_clModelData[nUnit].m_clSfrInfo.m_clRectFov[i], M_COLOR_GREEN, 1, FALSE, PS_DOT);
		g_clVision.DrawMOverlayBox(nUnit, iMinX, iMinY, iMaxX, iMaxY, M_COLOR_YELLOW, 1, FALSE, PS_SOLID);
#endif
        
         
        g_clTaskWork[nUnit].m_clPtFov[i].x = (iMaxX + iMinX) / 2;
        g_clTaskWork[nUnit].m_clPtFov[i].y = (iMaxY + iMinY) / 2;
		g_clTaskWork[nUnit].m_FindFovRect[i].left = iMinX;
		g_clTaskWork[nUnit].m_FindFovRect[i].right = iMaxX;
		g_clTaskWork[nUnit].m_FindFovRect[i].top = iMinY;
		g_clTaskWork[nUnit].m_FindFovRect[i].bottom = iMaxY;

        //g_clModelData[nUnit].Save(g_clSysData.m_szModelName);

        g_clVision.DrawMOverlayCross(nUnit, g_clTaskWork[nUnit].m_clPtFov[i], 200, M_COLOR_YELLOW, 1, FALSE);// TRUE);

    }
    return true;
}
//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_FindCirclePos(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, CRect* clRectRoi)
{	
	int maxSize = 200;

	TCHAR szLog[SIZE_OF_1K];

	if (pImage == NULL)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("영상 버퍼가 잘못되었습니다."));
		AddLog(szLog, 1, nUnit);
		return false;
	}

	if (nSizeX <= 0 || nSizeY <= 0)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("영상 사이즈가 잘못되었습니다. ( X : %d Y : %d )"), nSizeX, nSizeY);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	int aiHistX[5000];
	int aiHistY[5000];

	for (int i = 0; i<4; i++)
	{
		if (clRectRoi[i].left < 0 || clRectRoi[i].top < 0 || clRectRoi[i].right > nSizeX || clRectRoi[i].bottom > nSizeY)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 원형 마크 검색 영역이 잘못되었습니다. ( L %d,  T %d,  R %d,  B %d )"), i + 1, clRectRoi[i].left, clRectRoi[i].top, clRectRoi[i].right, clRectRoi[i].bottom);
			AddLog(szLog, 0, nUnit);

			return false;
		}

		int iSx, iSy, iEx, iEy;
		int x, y, iPos;
		int iMaxX = -1, iMinX = 9999;
		int iMaxY = -1, iMinY = 9999;
		int iMax_Left = -1, iMax_Right = -1, iMax_Up = -1, iMax_Down = -1;

		int iMaxX2 = -1, iMinX2 = 9999;
		int iMaxY2 = -1, iMinY2 = 9999;
		int iMax_Left2 = -1, iMax_Right2 = -1, iMax_Up2 = -1, iMax_Down2 = -1;

		int iSum;
		int iGap;

		int iSum_Left, iSum_Right;
		int iSum_Top, iSum_Bottom;

		iSx = clRectRoi[i].left;
		iSy = clRectRoi[i].top;
		iEx = clRectRoi[i].right;
		iEy = clRectRoi[i].bottom;

		::memset(aiHistY, 0, sizeof(int)*(5000));
		::memset(aiHistX, 0, sizeof(int)*(5000));


		/* X방향 히스토그램 */
		for (x = iSx; x < iEx; x++)
		{
			iPos = iSy * nPitch + x;
			iSum = 0;

			for (y = iSy; y < iEy; y++)
			{
				//				iSum += (ucImage[iPos]*ucImage[iPos]);
				iSum += (pImage[iPos]);
				iPos += nPitch;
			}

			aiHistX[x - iSx] = iSum;
		}

		/* X방향부터 엣지 찾기 */
		for (x = iSx + 5; x < iEx - 5; x++)
		{
			iSum_Left = aiHistX[x - iSx - 4] + aiHistX[x - iSx - 3] + aiHistX[x - iSx - 2] + aiHistX[x - iSx - 1];
			iSum_Right = aiHistX[x - iSx + 4] + aiHistX[x - iSx + 3] + aiHistX[x - iSx + 2] + aiHistX[x - iSx + 1];

			iGap = iSum_Left - iSum_Right;

			if (iGap > 300 && iGap > iMax_Left)
			{
				iMax_Left = iGap;
				iMinX = x;
			}

			iGap = iSum_Right - iSum_Left;

			if (iGap>300 && iGap > iMax_Right)
			{
				iMax_Right = iGap;
				iMaxX = x;
			}
		}


		iMax_Left = 0;
		iMinX2 = 0;
		int tmpSx = iMaxX - 400;
		int tmpEx = iMinX - 30;
		if (tmpSx < (iSx + 5))
			tmpSx = (iSx + 5);
		if (tmpEx >(iEx - 5))
			tmpEx = (iSx - 5);

		for (x = tmpSx; x < iMaxX; x++)
		{
			iSum_Left = aiHistX[x - iSx - 4] + aiHistX[x - iSx - 3] + aiHistX[x - iSx - 2] + aiHistX[x - iSx - 1];
			iSum_Right = aiHistX[x - iSx + 4] + aiHistX[x - iSx + 3] + aiHistX[x - iSx + 2] + aiHistX[x - iSx + 1];

			iGap = iSum_Left - iSum_Right;

			if (iGap>400 && iGap > iMax_Left)
			{
				iMax_Left = iGap;
				iMinX2 = x;
			}
		}


		iMax_Right = 0;
		iMaxX2 = 0;

		tmpSx = iMinX + 30;
		tmpEx = iMinX + 400;
		if (tmpSx < (iSx + 5))
			tmpSx = (iSx + 5);
		if (tmpEx >(iEx - 5))
			tmpEx = (iEx - 5);


		for (x = tmpSx; x < tmpEx; x++)
		{
			iSum_Left = aiHistX[x - iSx - 4] + aiHistX[x - iSx - 3] + aiHistX[x - iSx - 2] + aiHistX[x - iSx - 1];
			iSum_Right = aiHistX[x - iSx + 4] + aiHistX[x - iSx + 3] + aiHistX[x - iSx + 2] + aiHistX[x - iSx + 1];

			iGap = iSum_Right - iSum_Left;

			if (iGap > 400 && iGap > iMax_Right)
			{
				iMax_Right = iGap;
				iMaxX2 = x;
			}
		}


		if (iMaxX - iMinX > 30 && iMaxX - iMinX < maxSize && iMinX > 0)
		{
			iMinX = iMinX;
			iMaxX = iMaxX;
		}
		else if (iMaxX2 - iMinX > 30 && iMaxX2 - iMinX < maxSize && iMinX > 0)
		{
			iMinX = iMinX;
			iMaxX = iMaxX2;
		}
		else if (iMaxX - iMinX2 > 30 && iMaxX - iMinX2 < maxSize && iMinX2 > 0)
		{
			iMinX = iMinX2;
			iMaxX = iMaxX;
		}

		/* Y 방향 히스토그램 */
		for (y = iSy; y < iEy; y++)
		{
			iPos = y * nPitch + iMinX;
			iSum = 0;

			for (x = iMinX; x<iMaxX; x++)
			{
				iSum += pImage[iPos++];
			}

			aiHistY[y - iSy] = iSum;
		}

		for (y = iSy + 5; y < iEy - 5; y++)
		{
			iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
			iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

			iGap = iSum_Top - iSum_Bottom;

			if (iGap > iMax_Up)
			{
				iMax_Up = iGap;
				iMinY = y;
			}

			iGap = iSum_Bottom - iSum_Top;

			if (iGap > iMax_Down)
			{
				iMax_Down = iGap;
				iMaxY = y;
			}
		}


		if (iMinY >= iMaxY)
		{
			int iMinY2 = -9999;
			int iMaxY2 = -9999;
			int iMax_Up2 = 0;
			int iMax_Down2 = 0;

			int tmpSy = iMinY + 5;
			int tmpEy = iEy - 5;

			for (y = tmpSy; y < tmpEy; y++)
			{
				iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
				iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

				iGap = iSum_Bottom - iSum_Top;

				if (iGap > iMax_Down2 && (iGap>1000))
				{
					iMax_Down2 = iGap;
					iMaxY2 = y;
				}
			}


			tmpSy = iSy + 5;
			tmpEy = iMaxY - 5;

			for (y = tmpSy; y < tmpEy; y++)
			{
				iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
				iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

				iGap = iSum_Top - iSum_Bottom;

				if (iGap > iMax_Up2 && (iGap>1000))
				{
					iMax_Up2 = iGap;
					iMinY2 = y;
				}
			}

			if ((iMaxY - iMinY2) > 50 && (iMaxY - iMinY2) < 250)
			{
				iMinY = iMinY2;
			}
			else if ((iMaxY2 - iMinY) > 50 && (iMaxY2 - iMinY) < 250)
			{
				iMaxY = iMaxY2;
			}
		}
		else if ((iMaxY - iMinY) > 400)
		{
			int iMaxY2 = -9999;
			int iMinY2 = -9999;
			int iMax_Up2 = 0;
			int iMax_Down2 = 0;

			int tmpSy = iMinY + 5;
			int tmpEy = iMaxY - 5;

			for (y = tmpSy; y < tmpEy; y++)
			{
				iSum_Top = aiHistY[y - iSy - 4] + aiHistY[y - iSy - 3] + aiHistY[y - iSy - 2] + aiHistY[y - iSy - 1];
				iSum_Bottom = aiHistY[y - iSy + 4] + aiHistY[y - iSy + 3] + aiHistY[y - iSy + 2] + aiHistY[y - iSy + 1];

				iGap = iSum_Top - iSum_Bottom;

				if (iGap > iMax_Up2 && (iGap > 1000))
				{
					iMax_Up2 = iGap;
					iMinY2 = y;
				}

				iGap = iSum_Bottom - iSum_Top;

				if (iGap > iMax_Down2 && (iGap > 1000))
				{
					iMax_Down2 = iGap;
					iMaxY2 = y;
				}
			}

			if ((iMinY2 > 0) && ((iMaxY - iMinY2) > 50 && (iMaxY - iMinY2) < 250))
			{
				iMinY = iMinY2;
			}
			else if ((iMaxY2 > 0) && ((iMaxY2 - iMinY) > 50 && (iMaxY2 - iMinY) < 250))
			{
				iMaxY = iMaxY2;
			}
		}


		if (iMinX > iMaxX || (iMaxX - iMinX > maxSize))
		{
			g_clVision.DrawMOverlayBox(nUnit, iMinX, iMinY, iMaxX, iMaxY, M_COLOR_RED, 2, FALSE, PS_SOLID);

			_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 좌우 인식 위치가 비정상 입니다. (좌 %d, 우 %d)"), i + 1, iMinX, iMaxX);
			AddLog(szLog, 0, nUnit);
			return false;
		}


		if (iMinY > iMaxY || (iMaxY - iMinY > maxSize))
		{
			g_clVision.DrawMOverlayBox(nUnit, iMinX, iMinY, iMaxX, iMaxY, M_COLOR_RED, 2, FALSE, PS_SOLID);

			_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 상하 인식 위치가 비정상 입니다. (상 %d, 하 %d)"), i + 1, iMinY, iMaxY);
			AddLog(szLog, 0, nUnit);
			return false;
		}


		if (iMaxX < 0 || iMaxY < 0 || iMaxX > nSizeX || iMaxY > nSizeY ||
			iMinX < 0 || iMinY < 0 || iMinX > nSizeX || iMinY > nSizeY)
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] Max, Min 위치를 찾지 못했습니다."), i + 1);
			AddLog(szLog, 0, nUnit);
			return false;
		}

		g_clVision.DrawMOverlayBox(nUnit, iMinX, iMinY, iMaxX, iMaxY, M_COLOR_DARK_CYAN, 1, FALSE, PS_SOLID);

		g_clTaskWork[nUnit].m_clPtCircle[i].x = (iMaxX + iMinX) / 2;
		g_clTaskWork[nUnit].m_clPtCircle[i].y = (iMaxY + iMinY) / 2;

		g_clTaskWork[nUnit].m_FindCircleRect[i].left = iMinX;
		g_clTaskWork[nUnit].m_FindCircleRect[i].right = iMaxX;
		g_clTaskWork[nUnit].m_FindCircleRect[i].top = iMinY;
		g_clTaskWork[nUnit].m_FindCircleRect[i].bottom = iMaxY;
		//g_clModelData[nUnit].Save(g_clSysData.m_szModelName);

        g_clVision.DrawMOverlayCross(nUnit, g_clTaskWork[nUnit].m_clPtCircle[i], 200, M_COLOR_DARK_CYAN, 1, FALSE);// TRUE);

	}
	return true;
}


//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_FindRectPos(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, int nIndex, CRect& clRect)
{
	TCHAR szLog[SIZE_OF_1K];
	int nOffsetX, nOffsetY;

	nOffsetX = (int)((clRect.right - clRect.left) / 3);
	nOffsetY = (clRect.bottom - clRect.top) / 2;

	int nMinMaxGap = 1000;

	if (pImage == NULL)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("영상 버퍼가 잘못되었습니다."));
		AddLog(szLog, 1, nUnit);

		return false;
	}

	if (nSizeX <= 0 || nSizeY <= 0)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("영상 사이즈가 잘못되었습니다. ( X : %d Y : %d )"), nSizeX, nSizeY);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	int nHistX[5000];
	int nHistY[5000];

	if ((clRect.left < 0) || (clRect.top < 0) || (clRect.right > nSizeX) || (clRect.bottom > nSizeY))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("원형 마크 검색 영역이 잘못 되었습니다. ( L : %d T : %d R : %d B : %d )"), clRect.left, clRect.top, clRect.right, clRect.bottom);
		AddLog(szLog, 1, nUnit);

		return false;
	}


	int nSx, nSy, nEx, nEy, nCx, nCy;
	int x, y, nPos, nSum, nAvgX, nAvgY;

	memset(nHistY, 0, sizeof(int)*(5000));
	memset(nHistX, 0, sizeof(int)*(5000));


	nSx = clRect.left + nOffsetX;
	nEx = clRect.right - nOffsetX;
	nSy = clRect.top - nOffsetY;
	nEy = clRect.bottom + nOffsetY;
	nCy = (nSy + nEy) / 2;

	if (nSx < 0)				nSx = 0;
	if (nSy < 0)				nSy = 0;
	if (nEx >= nSizeX)			nEx = nSizeX - 1;
	if (nEy >= nSizeY)			nEy = nSizeY - 1;

	nAvgY = 0;
	for (y = nSy; y < nEy; y++)
	{
		nSum = 0;
		nPos = y * nPitch + nSx;

		for (x = nSx; x < nEx; x++)
		{
			nSum += pImage[nPos];
			nPos++;
		}

		nHistY[y] = nSum;
		nAvgY += nSum;
	}

	nAvgY = (int)(nAvgY / (nEy - nSy) * 0.9);

	int nMaxX = -1, nMinX = 9999;
	int nMaxY = -1, nMinY = 9999;
	int nMaxLeft = -1, nMaxRight = -1, nMaxTop = -1, nMaxBottom = -1;
	int nSumTop, nSumBottom;

	for (y = nCy; y > nSy + 8; y--)
	{
		if ((nHistY[y - 1] > nAvgY) && (nHistY[y - 3] > nAvgY) && (nHistY[y - 5] > nAvgY) && (nHistY[y - 7] > nAvgY))
		{
			nSumTop = nHistY[y - 7] + nHistY[y - 5] + nHistY[y - 3] + nHistY[y - 1];
			nSumBottom = nHistY[y + 7] + nHistY[y + 5] + nHistY[y + 3] + nHistY[y + 1];

			nMaxTop = nSumTop - nSumBottom;
			nMinY = y;

			break;
		}
	}

	if (y == nSy + 8)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 상부 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	for (y = nCy; y < nEy - 8; y++)
	{
		if ((nHistY[y + 1] > nAvgY) && (nHistY[y + 3] > nAvgY) && (nHistY[y + 5] > nAvgY) && (nHistY[y + 7] > nAvgY))
		{
			nSumTop = nHistY[y - 7] + nHistY[y - 5] + nHistY[y - 3] + nHistY[y - 1];
			nSumBottom = nHistY[y + 7] + nHistY[y + 5] + nHistY[y + 3] + nHistY[y + 1];

			nMaxBottom = nSumBottom - nSumTop;
			nMaxY = y;

			break;
		}
	}

	if (y == nEy - 8)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 하부 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	if (nMaxTop < nMinMaxGap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 상부 경계선이 불분명합니다. (%d)"), nIndex, nMaxTop);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	if (nMaxBottom < nMinMaxGap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 하부 경계선이 불분명합니다. (%d)"), nIndex, nMaxBottom);
		AddLog(szLog, 0, nUnit);

		return false;
	}

	if ((nMinY >= nMaxY) || (nMinY < 1))
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 상하 경계선 인식 결과가 비정상 입니다. [상:%d, 하:%d]"), nIndex, nMinY, nMaxY);
		AddLog(szLog, 0, nUnit);

		return false;
	}


	nOffsetX = (clRect.right - clRect.left) / 2;
	nOffsetY = (int)((clRect.bottom - clRect.top) / 3);

	nSx = clRect.left - nOffsetX;
	nEx = clRect.right + nOffsetX;
	nSy = nMinY + nOffsetY;
	nEy = nMaxY - nOffsetY;
	nCx = (nSx + nEx) / 2;

	if (nSx < 0)			nSx = 0;
	if (nSy < 0)			nSy = 0;
	if (nEx >= nSizeX)		nEx = nSizeX - 1;
	if (nEy >= nSizeY)		nEy = nSizeY - 1;

	/* X방향 히스토그램 */
	nAvgX = 0;
	for (x = nSx; x < nEx; x++)
	{
		nSum = 0;
		nPos = nSy * nPitch + x;

		for (y = nSy; y < nEy; y++)
		{
			nSum += pImage[nPos];
			nPos += nPitch;
		}

		nHistX[x] = nSum;
		nAvgX += nSum;
	}

	nAvgX = (int)(nAvgX / ((nEx - nSx) * 0.9));

	int nSumLeft, nSumRight;

	for (x = nCx; x > nSx + 5; x--)
	{
		if ((nHistX[x - 4] > nAvgX) && (nHistX[x - 3] > nAvgX) && (nHistX[x - 2] > nAvgX) && (nHistX[x - 1] > nAvgX))
		{
			nSumLeft = nHistX[x - 4] + nHistX[x - 3] + nHistX[x - 2] + nHistX[x - 1];
			nSumRight = nHistX[x + 4] + nHistX[x + 3] + nHistX[x + 2] + nHistX[x + 1];

			nMaxLeft = nSumLeft - nSumRight;
			nMinX = x;

			break;
		}
	}

	if ((x == nSx + 5) && (nIndex != 15) && (nIndex != 18))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 좌측 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	for (x = nCx; x < nEx - 5; x++)
	{
		if ((nHistX[x + 1] > nAvgX) && (nHistX[x + 2] > nAvgX) && (nHistX[x + 3] > nAvgX) && (nHistX[x + 4] > nAvgX))
		{
			nSumLeft = nHistX[x - 4] + nHistX[x - 3] + nHistX[x - 2] + nHistX[x - 1];
			nSumRight = nHistX[x + 4] + nHistX[x + 3] + nHistX[x + 2] + nHistX[x + 1];

			nMaxRight = nSumRight - nSumLeft;
			nMaxX = x;

			break;
		}
	}

	if ((x == nEx - 5) && (nIndex != 16) && (nIndex != 17))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 우측 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	if ((nIndex == 15) || (nIndex == 18))
	{
		if (nMaxRight > nMinMaxGap)
			nMinX = nMaxX - g_clModelData[nUnit].m_clSfrInfo.m_nSizeX;
		else
			nMinX = clRect.left;
	}
	else if (nMaxLeft < nMinMaxGap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 좌측 경계선이 불분명합니다. (%d)"), nIndex, nMaxLeft);
		AddLog(szLog, 1, nUnit);

		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nCx, nCy, M_COLOR_BLUE, 1, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayLine(nUnit, nMinX, clRect.top, nMinX, clRect.bottom, M_COLOR_RED, 1, FALSE, PS_SOLID);

		return false;
	}

	if ((nIndex == 16) || (nIndex == 17))
	{
		if (nMaxLeft > nMinMaxGap)
			nMaxX = nMinX + g_clModelData[nUnit].m_clSfrInfo.m_nSizeX;
		else
			nMaxX = clRect.right;
	}
	else if (nMaxRight < nMinMaxGap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 우측 경계선이 불분명합니다. (%d)"), nIndex, nMaxRight);
		AddLog(szLog, 1, nUnit);

		g_clVision.DrawMOverlayBox(nUnit, nCx, nSy, nEx, nEy, M_COLOR_BLUE, 1, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayLine(nUnit, nMaxX, clRect.top, nMaxX, clRect.bottom, M_COLOR_RED, 1, FALSE, PS_SOLID);

		return false;
	}


	if (nMinX < 5)
	{
		if ((nIndex == 15) || (nIndex == 18))
			nMinX = 5;
	}

	if ((nMinX > nMaxX) || (nMinX < 1))
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 좌우 경계선 인식 결과가 비정상 입니다. (좌:%d 우:%d)"), nIndex, nMinX, nMaxX);
		AddLog(szLog, 1, nUnit);

		return false;
	}
	///////////////////////////////////////////////////////////////////////하이데이타

	CRect HiRect;
	CPoint point;

	HiRect.left = nMaxX - 20;
	HiRect.right = nMaxX + 20;
	HiRect.top = (nMinY + nMaxY) / 2 - 20;
	HiRect.bottom = (nMinY + nMaxY) / 2 + 20;
	//HiRect.left = nMinX - 20;
	//HiRect.right = nMinX + 20;
	//HiRect.top = (nMinY + nMaxY) / 2 - 20;
	//HiRect.bottom = (nMinY + nMaxY) / 2 + 20;


	//point.x = nMinX;
	//point.y = (nMinY + nMaxY) / 2;

	point.x = nMaxX;
	point.y = (nMinY + nMaxY) / 2;

	//g_clVision.DrawMOverlayCross(CAM_CCD, point, 200, M_COLOR_BLUE, 2, FALSE, PS_SOLID);
	//g_clVision.DrawMOverlayBox(CAM_CCD, HiRect, M_COLOR_RED, 2, FALSE, PS_SOLID);


	////////////////////////////////////////////////////////////////////////


	clRect.left = nMinX;
	clRect.right = nMaxX;
	clRect.top = nMinY;
	clRect.bottom = nMaxY;

	return true;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_FindRectPos2(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, int nIndex, CRect& clRect)
{
	TCHAR szLog[SIZE_OF_1K];
	//int offsetX = (int)((rcRoi.right-rcRoi.left) / 3);
	//int offsetY = (rcRoi.bottom-rcRoi.top) / 2;
	int nOffsetX = (int)((clRect.right - clRect.left) / 3);
	int nOffsetY = (clRect.bottom - clRect.top) / 2;


	//	if(index == 8 || index == 12) 구자현 수정
	//		offsetY = 0;

	int min_max_Gap = 1000;

	if (pImage == NULL)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("영상 버퍼가 잘못되었습니다."));
		AddLog(szLog, 1, nUnit);
		return false;
	}

	if (nSizeX <= 0 || nSizeY <= 0)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("영상 사이즈가 잘못되었습니다. ( X : %d Y : %d )"), nSizeX, nSizeY);
		AddLog(szLog, 1, nUnit);
		return false;
	}


	int aiHistX[5000];
	int aiHistY[5000];

	if (clRect.left < 0 || clRect.top < 0 || clRect.right > nSizeX || clRect.bottom > nSizeY)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("원형 마크 검색 영역이 잘못 되었습니다. ( L : %d T : %d R : %d B : %d )"), clRect.left, clRect.top, clRect.right, clRect.bottom);
		AddLog(szLog, 1, nUnit);
		return false;
	}

	//	vision.boxlist[CCD].addList(rcRoi, PS_DOT, M_COLOR_BLUE);

	int iSx, iSy, iEx, iEy, iCx, iCy;
	int x, y, iPos, iSum, avgX, avgY;

	::memset(aiHistY, 0, sizeof(int)*(5000));
	::memset(aiHistX, 0, sizeof(int)*(5000));


	iSx = clRect.left + nOffsetX;
	iEx = clRect.right - nOffsetX;
	iSy = clRect.top - nOffsetY;
	iEy = clRect.bottom + nOffsetY;
	//iSy = rcRoi.top		- offsetY;
	//iEy = rcRoi.bottom	+ offsetY;
	iCy = (iSy + iEy) / 2;


	if (iSx<0)				iSx = 0;
	if (iSy<0)				iSy = 0;
	if (iEx >= nSizeX)			iEx = nSizeX - 1;
	if (iEy >= nSizeY)			iEy = nSizeY - 1;

	avgY = 0;
	for (y = iSy; y < iEy; y++)
	{
		iSum = 0;
		iPos = y * nPitch + iSx;

		for (x = iSx; x < iEx; x++)
		{
			iSum += pImage[iPos];
			iPos++;
		}

		aiHistY[y] = iSum;
		avgY += iSum;
	}

	avgY = (int)(avgY / (iEy - iSy) * 0.9);


	int iMaxX = -1, iMinX = 9999;
	int iMaxY = -1, iMinY = 9999;
	int iMax_Left = -1, iMax_Right = -1, iMax_Top = -1, iMax_Bottom = -1;

	int iSum_Top, iSum_Bottom;

	for (y = iCy; y > iSy + 8; y--)
	{
		if (aiHistY[y - 1] > avgY && aiHistY[y - 3] > avgY && aiHistY[y - 5] > avgY && aiHistY[y - 7] > avgY)
		{
			iSum_Top = aiHistY[y - 7] + aiHistY[y - 5] + aiHistY[y - 3] + aiHistY[y - 1];
			iSum_Bottom = aiHistY[y + 7] + aiHistY[y + 5] + aiHistY[y + 3] + aiHistY[y + 1];

			iMax_Top = iSum_Top - iSum_Bottom;
			iMinY = y;

			break;
		}
	}

	if (y == iSy + 8)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 상부 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);
		return false;
	}

	// 	vision.boxlist[CCD].addList(iSx, iSy, iEx, iCy, PS_SOLID, M_COLOR_BLUE);
	// 	vision.linelist[CCD].addList(rcRoi.left, iMinY, rcRoi.right, iMinY, PS_SOLID, M_COLOR_BLUE);


	for (y = iCy; y < iEy - 8; y++)
	{
		if (aiHistY[y + 1] > avgY && aiHistY[y + 3] > avgY && aiHistY[y + 5] > avgY && aiHistY[y + 7] > avgY)
		{
			iSum_Top = aiHistY[y - 7] + aiHistY[y - 5] + aiHistY[y - 3] + aiHistY[y - 1];
			iSum_Bottom = aiHistY[y + 7] + aiHistY[y + 5] + aiHistY[y + 3] + aiHistY[y + 1];

			iMax_Bottom = iSum_Bottom - iSum_Top;
			iMaxY = y;

			break;
		}
	}

	if (y == iEy - 8)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 하부 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);
		return false;
	}


	//  	vision.boxlist[CCD].addList(iSx, iCy, iEx, iEy, PS_SOLID, M_COLOR_GREEN);
	//  	vision.linelist[CCD].addList(rcRoi.left, iMaxY, rcRoi.right, iMaxY, PS_SOLID, M_COLOR_GREEN);

	if (iMax_Top < min_max_Gap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 상부 경계선이 불분명합니다. (%d)"), nIndex, iMax_Top);
		AddLog(szLog, 0, nUnit);
		return false;
	}

	if (iMax_Bottom < min_max_Gap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 하부 경계선이 불분명합니다. (%d)"), nIndex, iMax_Bottom);
		AddLog(szLog, 0, nUnit);
		return false;
	}

	if (iMinY >= iMaxY || iMinY<1)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 상하 경계선 인식 결과가 비정상 입니다. [상:%d, 하:%d]"), nIndex, iMinY, iMaxY);
		AddLog(szLog, 0, nUnit);
		return false;
	}


	nOffsetX = (clRect.right - clRect.left) / 2;
	nOffsetY = (int)((clRect.bottom - clRect.top) / 3);

	//	if(index == 8 || index==12)
	//		offsetY = 10;

	iSx = clRect.left - nOffsetX;
	iEx = clRect.right + nOffsetX;
	iSy = iMinY + nOffsetY;
	iEy = iMaxY - nOffsetY;
	iCx = (iSx + iEx) / 2;

	if (iSx < 0)			iSx = 0;
	if (iSy < 0)			iSy = 0;
	if (iEx >= nSizeX)		iEx = nSizeX - 1;
	if (iEy >= nSizeY)		iEy = nSizeY - 1;


	/* X방향 히스토그램 */
	avgX = 0;
	for (x = iSx; x < iEx; x++)
	{
		iSum = 0;
		iPos = iSy * nPitch + x;

		for (y = iSy; y < iEy; y++)
		{
			iSum += pImage[iPos];
			iPos += nPitch;
		}

		aiHistX[x] = iSum;
		avgX += iSum;
	}

	avgX = (int)(avgX / ((iEx - iSx) * 0.9));


	int iSum_Left, iSum_Right;

	for (x = iCx; x > iSx + 5; x--)
	{
		if (aiHistX[x - 4] > avgX && aiHistX[x - 3] > avgX && aiHistX[x - 2] > avgX && aiHistX[x - 1] > avgX)
		{
			iSum_Left = aiHistX[x - 4] + aiHistX[x - 3] + aiHistX[x - 2] + aiHistX[x - 1];
			iSum_Right = aiHistX[x + 4] + aiHistX[x + 3] + aiHistX[x + 2] + aiHistX[x + 1];

			iMax_Left = iSum_Left - iSum_Right;
			iMinX = x;

			break;
		}
	}

	if ((x == iSx + 5) && (nIndex != 15) && (nIndex != 18))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 좌측 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);
		return false;
	}

	// 	vision.boxlist[CCD].addList(iSx, iSy, iCx, iEy, PS_SOLID, M_COLOR_BLUE);
	// 	vision.linelist[CCD].addList(iMinX, rcRoi.top, iMinX, rcRoi.bottom, PS_SOLID, M_COLOR_RED);

	for (x = iCx; x < iEx - 5; x++)
	{
		if (aiHistX[x + 1] > avgX && aiHistX[x + 2] > avgX && aiHistX[x + 3] > avgX && aiHistX[x + 4] > avgX)
		{
			iSum_Left = aiHistX[x - 4] + aiHistX[x - 3] + aiHistX[x - 2] + aiHistX[x - 1];
			iSum_Right = aiHistX[x + 4] + aiHistX[x + 3] + aiHistX[x + 2] + aiHistX[x + 1];

			iMax_Right = iSum_Right - iSum_Left;
			iMaxX = x;

			break;
		}
	}

	if ((x == iEx - 5) && (nIndex != 16) && (nIndex != 17))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 사각형[#%d] 우측 인식 실패."), nIndex);
		AddLog(szLog, 1, nUnit);
		return false;
	}

	// 	vision.boxlist[CCD].addList(iCx, iSy, iEx, iEy, PS_SOLID, M_COLOR_GREEN);
	// 	vision.linelist[CCD].addList(iMaxX, rcRoi.top, iMaxX, rcRoi.bottom, PS_SOLID, M_COLOR_GREEN);


	if (nIndex == 15 || nIndex == 18)
	{
		if (iMax_Right > min_max_Gap)
			iMinX = iMaxX - g_clModelData[nUnit].m_clSfrInfo.m_nSizeX;
		else
			iMinX = clRect.left;
	}
	else if (iMax_Left < min_max_Gap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 좌측 경계선이 불분명합니다. (%d)"), nIndex, iMax_Left);
		AddLog(szLog, 0, nUnit);

		g_clVision.DrawMOverlayBox(nUnit, iSx, iSy, iCx, iEy, M_COLOR_BLUE, 1, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayLine(nUnit, iMinX, clRect.top, iMinX, clRect.bottom, M_COLOR_RED, 1, FALSE, PS_SOLID);
		return false;
	}

	if (nIndex == 16 || nIndex == 17)
	{
		if (iMax_Left > min_max_Gap)
			iMaxX = iMinX + g_clModelData[nUnit].m_clSfrInfo.m_nSizeX;
		else
			iMaxX = clRect.right;
	}
	else if (iMax_Right < min_max_Gap)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 우측 경계선이 불분명합니다. (%d)"), nIndex, iMax_Right);
		AddLog(szLog, 0, nUnit);

		g_clVision.DrawMOverlayBox(nUnit, iCx, iSy, iEx, iEy, M_COLOR_BLUE, 1, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayLine(nUnit, iMaxX, clRect.top, iMaxX, clRect.bottom, M_COLOR_RED, 1, FALSE, PS_SOLID);

		return false;
	}


	if (iMinX<5)
	{
		if (nIndex == 15 || nIndex == 18)
			iMinX = 5;
	}

	if (iMinX>iMaxX || iMinX<1)
	{
		g_clVision.DrawMOverlayBox(nUnit, clRect, M_COLOR_RED, 1, FALSE, PS_SOLID);

		_stprintf_s(szLog, SIZE_OF_1K, _T("[마크 #%d] 좌우 경계선 인식 결과가 비정상 입니다. (좌:%d 우:%d)"), nIndex, iMinX, iMaxX);
		AddLog(szLog, 0, nUnit);

		return false;
	}
	///////////////////////////////////////////////////////////////////////하이데이타

	CRect HiRect;
	CPoint point;

	HiRect.left = iMaxX - 20;
	HiRect.right = iMaxX + 20;
	HiRect.top = (iMinY + iMaxY) / 2 - 20;
	HiRect.bottom = (iMinY + iMaxY) / 2 + 20;

	point.x = iMaxX;
	point.y = (iMinY + iMaxY) / 2;

	//g_clVision.DrawMOverlayCross(CAM_CCD, point, 20, M_COLOR_RED, 2, FALSE, PS_SOLID);
	//g_clVision.DrawMOverlayBox(CAM_CCD, HiRect, M_COLOR_RED, 2, FALSE, PS_SOLID);


	////////////////////////////////////////////////////////////////////////


	clRect.left = iMinX;
	clRect.right = iMaxX;
	clRect.top = iMinY;
	clRect.bottom = iMaxY;

	//	vision.crosslist[CCD].addList((iMaxX+iMinX)/2, (iMaxY + iMinY)/2, 10, M_COLOR_MAGENTA);

	return true;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_FindSfrRectPos(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, int nIndex, CRect clRectRoi)
{
	TCHAR szLog[SIZE_OF_1K];
	int nOffsetX = 10;
	int nOffsetY = 20;
	int nIndexLeft, nIndexRight, nIndexTop, nIndexBottom;
	const int nRoiSizeX = 20;// 50;
	const int nRoiSizeY = 20;// 70;

	if (pImage == NULL)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR  검사 영상 버퍼가 잘못되었습니다."));
		AddLog(szLog, 1, nUnit);

		return false;
	}

	if ((nSizeX <= 0) || (nSizeY <= 0))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 검사 영상 사이즈가 잘못되었습니다. ( X : %d Y : %d )"), nSizeX, nSizeY);
		AddLog(szLog, 1, nUnit);

		return false;
	}


	//////////////////////////////////////////////////////////////////////////////////////////
	
	// 구자현 수정.
    if (nIndex == 0) { nIndexLeft = 3;		nIndexRight = 4;		nIndexTop = 1;		nIndexBottom = 2; }
    //if (nIndex == 0)		{ nIndexLeft = 1;		nIndexRight = 2;		nIndexTop = 3;		nIndexBottom = 4; }
	else if (nIndex == 1)	{ nIndexLeft = 5;		nIndexRight = 0;		nIndexTop = 6;		nIndexBottom = 0; }
	else if (nIndex == 2)	{ nIndexLeft = 0;		nIndexRight = 7;		nIndexTop = 8;		nIndexBottom = 0; }
	else if (nIndex == 3)	{ nIndexLeft = 0;		nIndexRight = 9;		nIndexTop = 0;		nIndexBottom = 10; }
	else if (nIndex == 4)	{ nIndexLeft = 11;		nIndexRight = 0;		nIndexTop = 0;		nIndexBottom = 12; }
	else if (nIndex == 5)	{ nIndexLeft = 0;		nIndexRight = 13;		nIndexTop = 14;		nIndexBottom = 0; }
	else if (nIndex == 6)	{ nIndexLeft = 15;		nIndexRight = 0;		nIndexTop = 16;		nIndexBottom = 0; }
	else if (nIndex == 7)	{ nIndexLeft = 17;		nIndexRight = 0;		nIndexTop = 18;		nIndexBottom = 0; }
	else if (nIndex == 8)	{ nIndexLeft = 0;		nIndexRight = 19;		nIndexTop = 20;		nIndexBottom = 0; }
	else if (nIndex == 9)	{ nIndexLeft = 0;		nIndexRight = 21;		nIndexTop = 0;		nIndexBottom = 22; }
	else if (nIndex == 10)	{ nIndexLeft = 23;		nIndexRight = 0;		nIndexTop = 0;		nIndexBottom = 24; }
	//	else if(index==11)		{	index_Left = 34;	index_Right = 50;		index_Top = 40;		index_Bottom = 46;	}
	// 	else if(index==12)		{	index_Left = 0;		index_Right = 0;		index_Top = 30;		index_Bottom = 42;	}
	// 	else if(index==13)		{	index_Left = 49;	index_Right = 33;		index_Top = 39;		index_Bottom = 45;	}
	// 	else if(index==14)		{	index_Left = 55;	index_Right = 35;		index_Top = 53;		index_Bottom = 51;	}
	//	else if(index==15)		{	index_Left = 0;		index_Right = 57;		index_Top = 0;		index_Bottom = 61;	}
	//	else if(index==16)		{	index_Left = 58;	index_Right = 0;		index_Top = 0;		index_Bottom = 62;	}
	//	else if(index==17)		{	index_Left = 60;	index_Right = 0;		index_Top = 64;		index_Bottom = 0;	}
	//	else if(index==18)		{	index_Left = 0;		index_Right = 59;		index_Top = 63;		index_Bottom = 0;	}
	else
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 검사 마크 Index가 비정상입니다. [Index %d]"), nIndex);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	nIndexLeft--;
	nIndexRight--;
	nIndexTop--;
	nIndexBottom--;

	if ((clRectRoi.right > nSizeX - 5) && (nIndex == 8 || nIndex == 9))
	{
		clRectRoi.right = nSizeX - 5;
	}

	if ((clRectRoi.left < 5) && (nIndex == 7 || nIndex == 10))
	{
		clRectRoi.left = 5;
	}

	if ((clRectRoi.left < 0) || (clRectRoi.top < 0) || (clRectRoi.right > nSizeX) || (clRectRoi.bottom > nSizeY))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 마크 인식 위치가 비정상 입니다. ( L %d, T %d, R %d, B %d )"), clRectRoi.left, clRectRoi.top, clRectRoi.right, clRectRoi.bottom);
		AddLog(szLog, 1, nUnit);

		return false;
	}

	int nCx = (clRectRoi.left + clRectRoi.right) / 2;
	int nCy = (clRectRoi.top + clRectRoi.bottom) / 2;


	// 영상에 맞게 수정해서 사용하세요..
	//////////////////////////////////////////////////////////////////////////////////////////
	// 정재호 수정.

	/*	//////////////////////////////////////////////////////////////////////////////////////////
	// 정재호 20140905.			기존 검사 영역 크기 입력하면 2배 크기로 검사 하던것을 검사 크기 만큼만 검사.
	int sx	= cx - model.m_iSize_ROI_X / 2;
	int ex	= sx + model.m_iSize_ROI_X;
	int sy	= cy - model.m_iSize_ROI_Y / 2;
	int ey	= sy + model.m_iSize_ROI_Y;
	////////////////////////////////////////////////////////////////////////////////////////// 수정 끝..


	if(index_Left>=0)										// 20140905		if문 안에 등호 포함....		// 상하 좌우 전부 같은 값으로 입력.. (실제로는 1개만 검사..)
	{
	SFR._64_Sfr_Rect[index_Left].left		= sx;
	SFR._64_Sfr_Rect[index_Left].right		= ex;
	SFR._64_Sfr_Rect[index_Left].top		= sy;
	SFR._64_Sfr_Rect[index_Left].bottom		= ey;
	}

	if(index_Right>=0)										// 20140905		if문 안에 등호 포함....
	{
	SFR._64_Sfr_Rect[index_Right].left		= sx;
	SFR._64_Sfr_Rect[index_Right].right		= ex;
	SFR._64_Sfr_Rect[index_Right].top		= sy;
	SFR._64_Sfr_Rect[index_Right].bottom	= ey;
	}

	if(index_Top>=0)										// 20140905		if문 안에 등호 포함....
	{
	SFR._64_Sfr_Rect[index_Top].left		= sx;
	SFR._64_Sfr_Rect[index_Top].right		= ex;
	SFR._64_Sfr_Rect[index_Top].top			= sy;
	SFR._64_Sfr_Rect[index_Top].bottom		= ey;
	}

	if(index_Bottom>=0)										// 20140905		if문 안에 등호 포함....
	{
	SFR._64_Sfr_Rect[index_Bottom].left		= sx;
	SFR._64_Sfr_Rect[index_Bottom].right	= ex;
	SFR._64_Sfr_Rect[index_Bottom].top		= sy;
	SFR._64_Sfr_Rect[index_Bottom].bottom	= ey;
	}

	vision.boxlist[CCD].addList(sx, sy, ex, ey, PS_SOLID, M_COLOR_RED);			// 20140905		Box 위치 확인 용..
	//////////////////////////////////////////////////////////////////////////////////////////  수정 끝..
	*/


	int nHist[1000];

	int nSx, nSy, nEx, nEy;
	int x, y, nPos, nSum, nMaxPos, nMaxVal, nTmpVal;
	int nPosTop, nPosBottom, nPosLeft, nPosRight;

	if (nIndexTop >= 0)
	{
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].left = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].right = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].top = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].bottom = -1;

		nSx = nCx - nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nEx = nCx + nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nSy = clRectRoi.top - nRoiSizeY;// g_clModelData.m_nRoiSizeY;
		nEy = clRectRoi.top + nRoiSizeY;// g_clModelData.m_nRoiSizeY;
#ifdef _DEBUG
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_DARK_GREEN, 1, 1, PS_SOLID);
#endif
		if (nSx < 0)				nSx = 0;
		if (nSy < 0)				nSy = 0;
		if (nEx >= nSizeX)			nEx = nSizeX - 1;
		if (nEy >= nSizeY)			nEy = nSizeY - 1;


		memset(nHist, 0, sizeof(int)*(1000));

		for (y = nSy; y < nEy; y++)
		{
			nSum = 0;
			nPos = y * nPitch + nSx;

			for (x = nSx; x < nEx; x++)
			{
				nSum += pImage[nPos];
				nPos++;
			}

			nHist[y - nSy] = nSum;
		}

		nMaxPos = -1;
		nMaxVal = 0;

		for (y = nSy + 5; y < nEy - 5; y++)
		{
			nTmpVal = (nHist[y - nSy] + nHist[y - nSy - 1] + nHist[y - nSy - 2] + nHist[y - nSy - 3]) - (nHist[y - nSy + 1] + nHist[y - nSy + 2] + nHist[y - nSy + 3] + nHist[y - nSy + 4]);

			if (nTmpVal > nMaxVal)
			{
				nMaxVal = nTmpVal;
				nMaxPos = y;
			}
		}

		nPosTop = nMaxPos;

		if (g_clSysData.m_nSFR_Type[nIndex] == 0)
		{
			nOffsetX = -2;
			nOffsetY = +5;
		}
		else
		{
			nOffsetX = +2;
			nOffsetY = +5;
		}

		//vision.crosslist[CCD].addList(cx, cy, 10, M_COLOR_MAGENTA);
		g_clVision.DrawMOverlayCross(nUnit, nCx, nCy, 10, M_COLOR_MAGENTA, 1, FALSE, PS_SOLID);

		nSx = nCx - g_clModelData[nUnit].m_nRoiSizeY + nOffsetX;
		nEx = nCx + g_clModelData[nUnit].m_nRoiSizeY + nOffsetX;
		nSy = nMaxPos - g_clModelData[nUnit].m_nRoiSizeX + nOffsetX;
		nEy = nMaxPos + g_clModelData[nUnit].m_nRoiSizeX + nOffsetX;

		if (nSx < 5)			nSx = 5;
		if (nSy < 5)			nSy = 5;
		if (nEx > nSizeX - 5)	nEx = nSizeX - 5;
		if (nEy > nSizeY - 5)	nEy = nSizeY - 5;

		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].left = nSx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].right = nEx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].top = nSy;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexTop].bottom = nEy;

		//g_clVision.DrawMOverlayCross(CAM_CCD, (nSx + nEx) / 2, nMaxPos, 30, M_COLOR_RED, 3, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
        _stprintf_s(szLog, SIZE_OF_100BYTE, _T("%d"), nIndexTop);
        g_clVision.DrawMOverlayText(nUnit, nSx, nSy, szLog, M_COLOR_CYAN, _T("Arial"), 10, 0);

	}


	if (nIndexBottom >= 0)
	{
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].left = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].right = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].top = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].bottom = -1;

		nSx = nCx - nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nEx = nCx + nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nSy = clRectRoi.bottom - nRoiSizeY;// g_clModelData.m_nRoiSizeY;
		nEy = clRectRoi.bottom + nRoiSizeY;// g_clModelData.m_nRoiSizeY;
#ifdef _DEBUG
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_DARK_GREEN, 1, 1, PS_SOLID);
#endif
		if (nSx < 0)				nSx = 0;
		if (nSy < 0)				nSy = 0;
		if (nEx >= nSizeX)			nEx = nSizeX - 1;
		if (nEy >= nSizeY)			nEy = nSizeY - 1;

		memset(nHist, 0, sizeof(int)*(1000));

		for (y = nSy; y < nEy; y++)
		{
			nSum = 0;
			nPos = y * nPitch + nSx;

			for (x = nSx; x < nEx; x++)
			{
				nSum += pImage[nPos];
				nPos++;
			}
			nHist[y - nSy] = nSum;
		}

		nMaxPos = -1;
		nMaxVal = 0;

		for (y = nSy + 5; y < nEy - 5; y++)
		{
			nTmpVal = (nHist[y - nSy] + nHist[y - nSy + 1] + nHist[y - nSy + 2] + nHist[y - nSy + 3]) - (nHist[y - nSy - 1] + nHist[y - nSy - 2] + nHist[y - nSy - 3] + nHist[y - nSy - 4]);

			if (nTmpVal > nMaxVal)
			{
				nMaxVal = nTmpVal;
				nMaxPos = y;
			}
		}

		nPosBottom = nMaxPos;

		if (g_clSysData.m_nSFR_Type[nIndex] == 0)
		{
			nOffsetX = +2;
			nOffsetY = -2;
		}
		else
		{
			nOffsetX = -2;
			nOffsetY = -2;
		}

		//vision.crosslist[CCD].addList(cx, cy, 10, M_COLOR_MAGENTA);
		g_clVision.DrawMOverlayCross(nUnit, nCx, nCy, 10, M_COLOR_MAGENTA, 1, FALSE, PS_SOLID);

		nSx = nCx - g_clModelData[nUnit].m_nRoiSizeY + nOffsetX;
		nEx = nCx + g_clModelData[nUnit].m_nRoiSizeY + nOffsetX;
		nSy = nMaxPos - g_clModelData[nUnit].m_nRoiSizeX + nOffsetY;
		nEy = nMaxPos + g_clModelData[nUnit].m_nRoiSizeX + nOffsetY;

		if (nSx < 5)				nSx = 5;
		if (nSy < 5)				nSy = 5;
		if (nEx > nSizeX - 5)		nEx = nSizeX - 5;
		if (nEy > nSizeY - 5)		nEy = nSizeY - 5;

		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].left = nSx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].right = nEx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].top = nSy;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexBottom].bottom = nEy;

		//g_clVision.DrawMOverlayCross(CAM_CCD, (nSx + nEx) / 2, nMaxPos, 30, M_COLOR_MAGENTA, 3, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
        _stprintf_s(szLog, SIZE_OF_100BYTE, _T("%d"), nIndexBottom);
        g_clVision.DrawMOverlayText(nUnit, nSx, nSy, szLog, M_COLOR_CYAN, _T("Arial"), 10, 0);
	}

	if (nIndexLeft >= 0)
	{
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].left = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].right = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].top = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].bottom = -1;

		nSx = clRectRoi.left - nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nEx = clRectRoi.left + nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nSy = nCy - nRoiSizeY;// g_clModelData.m_nRoiSizeY;
		nEy = nCy + nRoiSizeY;// g_clModelData.m_nRoiSizeY;
#ifdef _DEBUG
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_DARK_GREEN, 1, 1, PS_SOLID);
#endif
		if (nSx < 0)				nSx = 0;
		if (nSy < 0)				nSy = 0;
		if (nEx >= nSizeX)			nEx = nSizeX - 1;
		if (nEy >= nSizeY)			nEy = nSizeY - 1;

		memset(nHist, 0, sizeof(int)*(1000));

		for (x = nSx; x < nEx; x++)
		{
			nSum = 0;
			nPos = nSy * nPitch + x;

			for (y = nSy; y < nEy; y++)
			{
				nSum += pImage[nPos];
				nPos += nPitch;
			}

			nHist[x - nSx] = nSum;
		}

		nMaxPos = -1;
		nMaxVal = 0;

		for (x = nSx + 5; x < nEx - 5; x++)
		{
			nTmpVal = (nHist[x - nSx] + nHist[x - nSx - 1] + nHist[x - nSx - 2] + nHist[x - nSx - 3]) - (nHist[x - nSx + 1] + nHist[x - nSx + 2] + nHist[x - nSx + 3] + nHist[x - nSx + 4]);

			if (nTmpVal > nMaxVal)
			{
				nMaxVal = nTmpVal;
				nMaxPos = x;
			}
		}

		nPosLeft = nMaxPos;

		if (g_clSysData.m_nSFR_Type[nIndex] == 0)
		{
			nOffsetX = +5;
			nOffsetY = +5;
		}
		else
		{
			nOffsetX = +5;
			nOffsetY = -5;
		}

		nSx = nMaxPos - g_clModelData[nUnit].m_nRoiSizeX + nOffsetX;
		nEx = nMaxPos + g_clModelData[nUnit].m_nRoiSizeX + nOffsetX;
		nSy = nCy - g_clModelData[nUnit].m_nRoiSizeY + nOffsetY;
		nEy = nCy + g_clModelData[nUnit].m_nRoiSizeY + nOffsetY;

		if (nSx < 5)				nSx = 5;
		if (nSy < 5)				nSy = 5;
		if (nEx > nSizeX - 5)		nEx = nSizeX - 5;
		if (nEy > nSizeY - 5)		nEy = nSizeY - 5;

		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].left = nSx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].right = nEx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].top = nSy;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexLeft].bottom = nEy;

		//g_clVision.DrawMOverlayCross(CAM_CCD, nMaxPos, (nSy + nEy) / 2, 30, M_COLOR_MAGENTA, 3, FALSE, PS_SOLID);

		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
        _stprintf_s(szLog, SIZE_OF_100BYTE, _T("%d"), nIndexLeft);
        g_clVision.DrawMOverlayText(nUnit, nSx, nSy, szLog, M_COLOR_CYAN, _T("Arial"), 10, 0);
	}


	if (nIndexRight >= 0)
	{
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].left = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].right = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].top = -1;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].bottom = -1;

		nSx = clRectRoi.right - nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nEx = clRectRoi.right + nRoiSizeX;// g_clModelData.m_nRoiSizeX;
		nSy = nCy - nRoiSizeY;// g_clModelData.m_nRoiSizeY;
		nEy = nCy + nRoiSizeY;// g_clModelData.m_nRoiSizeY;
#ifdef _DEBUG
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_DARK_GREEN, 1, 1, PS_SOLID);
#endif
		if (nSx < 0)				nSx = 0;
		if (nSy < 0)				nSy = 0;
		if (nEx >= nSizeX)			nEx = nSizeX - 1;
		if (nEy >= nSizeY)			nEy = nSizeY - 1;

		memset(nHist, 0, sizeof(int)*(1000));

		for (x = nSx; x < nEx; x++)
		{
			nSum = 0;
			nPos = nSy * nPitch + x;

			for (y = nSy; y < nEy; y++)
			{
				nSum += pImage[nPos];
				nPos += nPitch;
			}
			nHist[x - nSx] = nSum;
		}

		nMaxPos = -1;
		nMaxVal = 0;

		for (x = nSx + 5; x < nEx - 5; x++)
		{
			nTmpVal = (nHist[x - nSx] + nHist[x - nSx + 1] + nHist[x - nSx + 2] + nHist[x - nSx + 3]) - (nHist[x - nSx - 1] + nHist[x - nSx - 2] + nHist[x - nSx - 3] + nHist[x - nSx - 4]);

			if (nTmpVal > nMaxVal)
			{
				nMaxVal = nTmpVal;
				nMaxPos = x;
			}
		}

		nPosRight = nMaxPos;

		if (g_clSysData.m_nSFR_Type[nIndex] == 0)
		{
			nOffsetX = -2;
			nOffsetY = -5;
		}
		else
		{
			nOffsetX = -2;
			nOffsetY = +5;
		}

		nSx = nMaxPos - g_clModelData[nUnit].m_nRoiSizeX + nOffsetX;
		nEx = nMaxPos + g_clModelData[nUnit].m_nRoiSizeX + nOffsetX;
		nSy = nCy - g_clModelData[nUnit].m_nRoiSizeY + nOffsetY;
		nEy = nCy + g_clModelData[nUnit].m_nRoiSizeY + nOffsetY;

		if (nSx < 5)				nSx = 5;
		if (nSy < 5)				nSy = 5;
		if (nEx > nSizeX - 5)		nEx = nSizeX - 5;
		if (nEy > nSizeY - 5)		nEy = nSizeY - 5;

		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].left = nSx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].right = nEx;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].top = nSy;
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndexRight].bottom = nEy;

		//g_clVision.DrawMOverlayCross(CAM_CCD, nMaxPos, (nSy + nEy) / 2, 30, M_COLOR_MAGENTA, 3, FALSE, PS_SOLID);
		g_clVision.DrawMOverlayBox(nUnit, nSx, nSy, nEx, nEy, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
        _stprintf_s(szLog, SIZE_OF_100BYTE, _T("%d"), nIndexRight);
        g_clVision.DrawMOverlayText(nUnit, nSx, nSy, szLog, M_COLOR_CYAN, _T("Arial"), 10, 0);
	}

	return true;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool findSmallSfrRectPos(int nUnit, unsigned char* ucImage, int pitch, int sizeX, int sizeY, int index, CRect rcRoi)
{
    char szTmp[256];
    int iSfrIndex = 0;
    int iWidth = 0;
    int iHeight = 0;
    int initNum = 0;
    TCHAR szPos[SIZE_OF_100BYTE];
#if  (____MODEL_NAME == TESLA_WIDE)
    int boxIndex[MAX_LAST_INSP_COUNT] =
    {
        SFR_CENTER_INDEX_4,
        MAX_SFR_INSP_COUNT - 7 , MAX_SFR_INSP_COUNT - 5,
        MAX_SFR_INSP_COUNT - 3 , MAX_SFR_INSP_COUNT - 1
    };
#elif  (____MODEL_NAME == TESLA_MAIN_NARROW)
    int boxIndex[MAX_LAST_INSP_COUNT] =
    {
        SFR_CENTER_INDEX_4,
        MAX_SFR_INSP_COUNT - 15 , MAX_SFR_INSP_COUNT - 13,
        MAX_SFR_INSP_COUNT - 11 , MAX_SFR_INSP_COUNT - 9,
        MAX_SFR_INSP_COUNT - 7 , MAX_SFR_INSP_COUNT - 5,
        MAX_SFR_INSP_COUNT - 3 , MAX_SFR_INSP_COUNT - 1
    };
#endif
   
    //index = 0, 1, 2,3,4
    if (index == 0)
    {
        initNum = 0;
    }
    else
    {
        initNum = boxIndex[index] - 1;
    }
    


    for (iSfrIndex = initNum; iSfrIndex <= boxIndex[index]; iSfrIndex++)
    {
        if (g_clModelData[nUnit].m_nDirection[iSfrIndex] == SFR_ROI_HORIZONTAL)
        {
            iWidth = g_clModelData[nUnit].m_nRoiSizeX;
            iHeight = g_clModelData[nUnit].m_nRoiSizeY;
        }
        else
        {
            iWidth = g_clModelData[nUnit].m_nRoiSizeY;
            iHeight = g_clModelData[nUnit].m_nRoiSizeX;
        }
        g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].left = rcRoi.left - (iHeight)+g_clModelData[nUnit].m_MTF_ROI_Pos[iSfrIndex].x;
        g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].right = g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].left + (iHeight);
        g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].top = rcRoi.top - (iWidth)+g_clModelData[nUnit].m_MTF_ROI_Pos[iSfrIndex].y;
        g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].bottom = g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].top + (iWidth);

        //g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex], M_COLOR_YELLOW, 1, FALSE);
        _stprintf_s(szPos, SIZE_OF_100BYTE, _T("%d"), iSfrIndex);
        //g_clVision.DrawMOverlayText(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].left + 10, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex].top + 10, szPos, M_COLOR_GREEN, _T("Arial"), 10, 12);
#ifdef NORINDA_MODE
        g_clVision.SaveSfrImage(nUnit, ucImage, pitch, iWidth, iHeight, iSfrIndex, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[iSfrIndex]);
#endif
    }
     
    //
    return true;
}

bool findRectPosPattern(int nUnit, unsigned char* ucImage, int pitch, int sizeX, int sizeY, int index, CRect& rcRoi)
{
    TCHAR szLog[SIZE_OF_1K];
    int offsetX = (int)((rcRoi.right - rcRoi.left) / 3);
    int offsetY = (rcRoi.bottom - rcRoi.top) / 2;

    if (ucImage == NULL)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("SFR 영상 버퍼가 잘못되었습니다."));
        AddLog(szLog, 1, nUnit);
        return false;
    }

    if (sizeX <= 0 || sizeY <= 0)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("영상 사이즈가 잘못되었습니다. "));
        AddLog(szLog, 1, nUnit);
        return false;
    }

    if (rcRoi.left < 0 || rcRoi.top < 0 || rcRoi.right > sizeX || rcRoi.bottom > sizeY)
    {
        _stprintf_s(szLog, SIZE_OF_1K, _T("ROI 검색 영역이 잘못 되었습니다."));
        AddLog(szLog, 1, nUnit);
        return false;
    }


    double dCenterPosX, dCenterPosY, dAngle, dRate;
    int i = index;
    {
        if (FieldPatternMatching(nUnit, i, dCenterPosX, dCenterPosY, dAngle, dRate))
        {
            rcRoi.left = dCenterPosX - g_clModelData[nUnit].m_nPatternSize[i].x / 2;
            rcRoi.right = dCenterPosX + g_clModelData[nUnit].m_nPatternSize[i].x / 2;
            rcRoi.top = dCenterPosY - g_clModelData[nUnit].m_nPatternSize[i].y / 2;
            rcRoi.bottom = dCenterPosY + g_clModelData[nUnit].m_nPatternSize[i].y / 2;
        }
    }
    return true;
}

bool FieldPatternMatching(int nUnit, int iFieldNo, double &dCenterPosX, double &dCenterPosY, double &dAngle, double &dRate)
{
    CRect rcArea;
    bool bResult = false;
    rcArea.left = (int)g_clModelData[nUnit].m_nPatternPos[iFieldNo].x - 100;
    rcArea.top = (int)g_clModelData[nUnit].m_nPatternPos[iFieldNo].y - 100;
    rcArea.right = (int)g_clModelData[nUnit].m_nPatternPos[iFieldNo].x + g_clModelData[nUnit].m_nPatternSize[iFieldNo].x + 100;
    rcArea.bottom = (int)g_clModelData[nUnit].m_nPatternPos[iFieldNo].y + g_clModelData[nUnit].m_nPatternSize[iFieldNo].y + 100;
	 
    rcArea.left = (rcArea.left<0) ? 0 : rcArea.left;
    rcArea.top = (rcArea.top<0) ? 0 : rcArea.top;
    rcArea.right = (rcArea.right>g_clModelData[nUnit].m_nWidth) ? g_clModelData[nUnit].m_nWidth : rcArea.right;
    rcArea.bottom = (rcArea.bottom>g_clModelData[nUnit].m_nHeight) ? g_clModelData[nUnit].m_nHeight : rcArea.bottom;

    if (g_clVision.FieldPatternResult[nUnit][iFieldNo])
    {
        MpatFree(g_clVision.FieldPatternResult[nUnit][iFieldNo]);
        g_clVision.FieldPatternResult[nUnit][iFieldNo] = NULL;
    }

    MpatAllocResult(g_clVision.m_MilSystem[0], M_DEFAULT, &g_clVision.FieldPatternResult[nUnit][iFieldNo]);
	if (iFieldNo == 0) {
		MpatSetPosition(g_clVision.FieldPatternImage[nUnit][iFieldNo], 
		rcArea.left, rcArea.top, g_clModelData[nUnit].m_nPatternSize[iFieldNo].x + 100, g_clModelData[nUnit].m_nPatternSize[iFieldNo].y + 100);
	}
	else {
		MpatSetPosition(g_clVision.FieldPatternImage[nUnit][iFieldNo],
		rcArea.left, rcArea.top, g_clModelData[nUnit].m_nPatternSize[iFieldNo].x + 100, g_clModelData[nUnit].m_nPatternSize[iFieldNo].y + 100);
	}
    MpatSetAcceptance(g_clVision.FieldPatternImage[nUnit][iFieldNo], 80);
    MpatSetAccuracy(g_clVision.FieldPatternImage[nUnit][iFieldNo], M_LOW);
    MpatSetCertainty(g_clVision.FieldPatternImage[nUnit][iFieldNo], 70);
    MpatSetNumber(g_clVision.FieldPatternImage[nUnit][iFieldNo], 1L);
    MpatSetSpeed(g_clVision.FieldPatternImage[nUnit][iFieldNo], M_HIGH);
    MpatSetSearchParameter(g_clVision.FieldPatternImage[nUnit][iFieldNo], M_FAST_FIND, M_DISABLE);

    MpatPreprocModel(g_clVision.m_MilCcdProcChild[nUnit][2], g_clVision.FieldPatternImage[nUnit][iFieldNo], M_DEFAULT);
    MpatFindModel(g_clVision.m_MilCcdProcChild[nUnit][2], g_clVision.FieldPatternImage[nUnit][iFieldNo], g_clVision.FieldPatternResult[nUnit][iFieldNo]);

    double px;
    if (MpatGetNumber(g_clVision.FieldPatternResult[nUnit][iFieldNo], M_NULL) == 1L)
    {
        MpatGetResult(g_clVision.FieldPatternResult[nUnit][iFieldNo], M_POSITION_X, &dCenterPosX);
        MpatGetResult(g_clVision.FieldPatternResult[nUnit][iFieldNo], M_POSITION_Y, &dCenterPosY);
        //MpatGetResult(g_clVision.FieldPatternResult[nUnit][iFieldNo], M_ANGLE, &dAngle);
        MpatGetResult(g_clVision.FieldPatternResult[nUnit][iFieldNo], M_SCORE, &dRate);

        bResult = true;
    }
    else
    {
        dCenterPosX = (unsigned char)g_clModelData[nUnit].m_nWidth >> 1;
        dCenterPosY = (unsigned char)g_clModelData[nUnit].m_nHeight >> 1;
        dRate = 0.0;
        bResult = false;
    }
    MpatFree(g_clVision.FieldPatternResult[nUnit][iFieldNo]);
    g_clVision.FieldPatternResult[nUnit][iFieldNo] = NULL;
    return bResult;
}


//-----------------------------------------------------------------------------
//
//	COLLIMATOR MTF 측정
//
//-----------------------------------------------------------------------------
int	g_GetMTF_Ct(int nUnit, int nMode)
{
	TCHAR	szLog[SIZE_OF_1K];
	int i;

#ifdef ON_LINE_MIL
	g_clVision.ClearOverlay(nUnit);
#endif

	float fMaxSfrN4[MAX_SFR_INSP_CNT] = { 0.0, };
	float fMaxSfrN8[MAX_SFR_INSP_CNT] = { 0.0, };


#ifdef ON_LINE_MIL
	g_clVision.ClearOverlay(nUnit);
#endif

#ifdef ON_LINE_MIL
	int nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_X, NULL);
	int nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_Y, NULL);
	int nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_PITCH, NULL);

	if (nSizeX <= 0 || nSizeY <= 0)
	{
		AddLog(_T("MilProcImageChild 사이즈 오류."), 1, nUnit);
		return - 1;
	}
#endif

	for (i = 0; i < 4; i++)
	{
		g_clTaskWork[nUnit].m_stSfrInsp.clRectROI[i] = g_clModelData[nUnit].m_clSfrInfo.m_clRectCircle[i];
#ifdef ON_LINE_MIL
		g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp.clRectROI[i], M_COLOR_GREEN, 1, FALSE, PS_DOT);
#endif
	}

	if (g_GetSfrRectRoi_Ct(nUnit, nMode) == false)
	{
		g_clVision.DrawOverlayAll(nUnit);
		return -1;
	}

	g_clVision.DrawOverlayAll(nUnit);
	//return 1;

	for (i = 0; i < MAX_SFR_INSP_CNT + 2; i++)
	{
		/*if (nMode != SFR_FINAL)
		{
			if ((i != SFR_CENTER_INDEX) && (i != SFR_CENTER_INDEX_2) && (i != SFR_CENTER_INDEX_3) && (i != SFR_CENTER_INDEX_4) &&
				(i != SFR_LEFT_UP_INDEX) && (i != SFR_RIGHT_UP_INDEX) && (i != SFR_RIGHT_DOWN_INDEX) && (i != SFR_LEFT_DOWN_INDEX) &&
				(i != SFR_LEFT_UP_INDEX_2) && (i != SFR_RIGHT_UP_INDEX_2) && (i != SFR_RIGHT_DOWN_INDEX_2) && (i != SFR_LEFT_DOWN_INDEX_2))
				continue;
		}*/

		if (g_GetPatchCenterAndSFR(nUnit, i) == false && (i < MAX_MTF_COUNT))
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[SFR 측정] SFR 계산 실패 : POS (%d)"), i);
			AddLog(szLog, 1, nUnit);
			//return -1;
		}
		else
		{
			_stprintf_s(szLog, SIZE_OF_1K, _T("[SFR 측정] SFR 계산 : POS(%d) = %.03lf"), i, g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i]);
			AddLog(szLog, 0, nUnit);
		}

		if (g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] > fMaxSfrN4[i])
		{
			fMaxSfrN4[i] = g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i];
			fMaxSfrN8[i] = g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN8[i];
		}
	}

	/*int curIndexA;
	int boxIndex[12] = { SFR_CENTER_INDEX, SFR_LEFT_UP_INDEX, SFR_RIGHT_UP_INDEX, SFR_LEFT_DOWN_INDEX, SFR_RIGHT_DOWN_INDEX, SFR_CENTER_INDEX_2, SFR_LEFT_UP_INDEX_2, SFR_RIGHT_UP_INDEX_2, SFR_LEFT_DOWN_INDEX_2, SFR_RIGHT_DOWN_INDEX_2, SFR_CENTER_INDEX_3, SFR_CENTER_INDEX_4 };*/
	int nStep = g_clTaskWork[nUnit].m_nCountOfTotalStepAA;

	/*for (int i = 0; i < 5; i++)
	{
		curIndexA = boxIndex[i];

		if (i == 0)
		{
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][i] = (float)((fMaxSfrN4[boxIndex[i]] + fMaxSfrN4[boxIndex[i + 5]] + fMaxSfrN4[boxIndex[i + 10]] + fMaxSfrN4[boxIndex[i + 11]]) / 4.0);
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStep][i] = (float)((fMaxSfrN8[boxIndex[i]] + fMaxSfrN8[boxIndex[i + 5]] + fMaxSfrN8[boxIndex[i + 10]] + fMaxSfrN8[boxIndex[i + 11]]) / 4.0);


			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].x =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].right) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].right) / 2.0) +
					((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].right) / 2.0) +
					((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].right) / 2.0)) / 4.0;

			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].y =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].bottom) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].bottom) / 2.0) +
					((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 10]].bottom) / 2.0) +
					((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 11]].bottom) / 2.0)) / 4.0;
		}
		else
		{
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][i] = (float)((fMaxSfrN4[boxIndex[i]] + fMaxSfrN4[boxIndex[i + 5]]) / 2.0);
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStep][i] = (float)((fMaxSfrN8[boxIndex[i]] + fMaxSfrN8[boxIndex[i + 5]]) / 2.0);

			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].x =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].right) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].left + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].right) / 2.0)) / 2.0;
			g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[nStep][i].y =
				(((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i]].bottom) / 2.0) +
				((g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].top + g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[boxIndex[i + 5]].bottom) / 2.0)) / 2.0;
		}
	}*/

	/*for (int i = MOTOR_LENS_X; i <= MOTOR_LENS_TY; i++)
	{
		if ((i == MOTOR_LENS_TY) || (i == MOTOR_PCB_TX) || (i == MOTOR_PCB_TY))
		{
			g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStep][i - MOTOR_LENS_X] = (float)g_clMotorSet.GetCommandPos(nUnit, i);
		}
		else
		{
#ifdef ON_LINE_MOTOR		
			g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStep][i - MOTOR_LENS_X] = (float)g_clMotorSet.GetEncoderPos(nUnit, i);
#endif
		}
	}*/

	//! Log Save 추가 해야함.
	//if (!saveSfrLog(Mode))
	//{
	//	return -1;
	//}

	if (g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][0] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][1] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][2] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][3] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF ||
		g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStep][4] > g_clModelData[nUnit].m_stAFInfo[0].fLimitMTF)
	{/* 센터 MTF 값이 리미트 이상이면 fine pitch 이동 */
		g_clTaskWork[nUnit].m_bFlagFineMove = true;
	}

	//g_clTaskWork.m_nCountOfTotalStepAA++;
	//TRACE("g_clTaskWork.m_nCountOfTotalStepAA=================>%d\n", g_clTaskWork.m_nCountOfTotalStepAA);

	if (nMode == SFR_FINAL)
	{
		for (int i = 0; i < MAX_SFR_INSP_COUNT; i++)
		{
			g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i] = fMaxSfrN4[i];
			g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN8[i] = fMaxSfrN8[i];
		}
	}

	if (nMode != 2)
	{
		//g_pCarAABonderDlg->DrawGraph(2);
	}

#ifdef ON_LINE_MIL
	g_clVision.DrawOverlayAll(nUnit);
#endif

	return 1;
}

//-----------------------------------------------------------------------------
//
//	SFR RECT ROI BLOB 측정
//
//-----------------------------------------------------------------------------
bool g_GetSfrRectRoi_Ct(int nUnit, int nMode)
{
	bool bFindBlob = false;
	int i = 0;
	int nPitch = 0, nSizeX = 0, nSizeY = 0;
	CRect		rcFindBlob;
	CMBlobObj	clMilBlob;
	STRUC_FIND_BLOB	stFindBlob;
	MIL_ID		MBinarizeImg = M_NULL;
	MIL_ID		MTargetImg = M_NULL;
	CPoint clCenter;

	memset(&stFindBlob, 0x00, sizeof(STRUC_FIND_BLOB));

	nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_PITCH, M_NULL);
	nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_X, M_NULL);
	nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_Y, M_NULL);

	if (g_FindCirclePos(nUnit, g_clVision.m_pImgBuff[nUnit][1], nPitch, nSizeX, nSizeY, g_clModelData[nUnit].m_clSfrInfo.m_clRectCircle) == false)
		return false;

	::MbufAlloc2d(g_clVision.m_MilSystem[0], nSizeX, nSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, &MBinarizeImg);
	MTargetImg = g_clVision.m_MilCcdProcChild[nUnit][1];
#ifdef _DEBUG
	MbufSave(_T("D:\\Debug\\1_OriginImg.bmp"), MTargetImg);
#endif
	::MimBinarize(MTargetImg, MBinarizeImg, M_LESS_OR_EQUAL, 150, M_NULL);	//! 이진화 반전
#ifdef _DEBUG
	MbufSave(_T("D:\\Debug\\2_Binarize.bmp"), MBinarizeImg);
#endif
		
	for (i = 0; i < 13; i++)
	{
		/*if (nMode != SFR_FINAL)
		{
			if ((i != 0) && (i != 5) && (i != 6) &&
				(i != 11) && (i != 12))		continue;
		}*/

		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].left = g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].x;
		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].top = g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].y;
		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].right = g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].x + g_clModelData[nUnit].m_clSfrInfo.m_nSizeX;
		g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].bottom = g_clModelData[nUnit].m_clSfrInfo.m_clPtOffset[i].y + g_clModelData[nUnit].m_clSfrInfo.m_nSizeY;

		MIL_ID MilTmp = M_NULL;
		
		if (i == 0)
		{
			::MimOpen(MBinarizeImg, MBinarizeImg, 5, M_BINARY);
#ifdef _DEBUG
			MbufSave(_T("D:\\Debug\\3_Open.bmp"), MBinarizeImg);
#endif

			/*::MimClose(MBinarizeImg, MBinarizeImg, 5, M_BINARY);
#ifdef _DEBUG
			MbufSave(_T("D:\\Debug\\3_Close.bmp"), MBinarizeImg);
#endif*/

//#ifdef _DEBUG
//			MbufChild2d(MBinarizeImg, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].left, g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].top,
//				g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].right - g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].left,
//				g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].bottom - g_clTaskWork[nUnit].m_stSfrInsp.clRect[i].top,
//				&MilTmp);
//			CString sFile = _T("");
//			sFile.Format(_T("D:\\Debug\\Roi_Crop_%d.bmp"), i);
//			MbufSave(sFile, MilTmp);
//			MbufFree(MilTmp);
//#endif

			bFindBlob = clMilBlob.FindBlob(g_clVision.m_MilSystem[0],
				MBinarizeImg, i,
				g_clTaskWork[nUnit].m_stSfrInsp.clRect[i],
				50,
				10, 10, 500, 500,
				stFindBlob, 0, 0);

			
			::MimBinarize(MBinarizeImg, MBinarizeImg, M_LESS_OR_EQUAL, 50, M_NULL);	//! 이진화 반전
		}
		else
		{
			/*::MimClose(MBinarizeImg, MBinarizeImg, 5, M_BINARY);
			#ifdef _DEBUG
			MbufSave(_T("D:\\Debug\\3_Close.bmp"), MBinarizeImg);
			#endif*/

			bFindBlob = clMilBlob.FindBlob(g_clVision.m_MilSystem[0],
				MBinarizeImg, i,
				g_clTaskWork[nUnit].m_stSfrInsp.clRect[i],
				50,
				10, 10, 500, 500,
				stFindBlob, 0, 0);			
		}
		if (bFindBlob == false)
		{
			TRACE("Not Found===========>%d\n", i);
			continue;
		}

		rcFindBlob = stFindBlob.clRect;

		/*rcFindBlob.left		= (int)(stFindBlob.dResultX - (stFindBlob.dMarkSizeX / 2.));
		rcFindBlob.top		= (int)(stFindBlob.dResultY - (stFindBlob.dMarkSizeY / 2.));
		rcFindBlob.right	= (int)(stFindBlob.dResultX + (stFindBlob.dMarkSizeX / 2.));
		rcFindBlob.bottom	= (int)(stFindBlob.dResultY + (stFindBlob.dMarkSizeY / 2.));*/
#ifdef _DEBUG
		if (i > 0)
		{
			int nMinX = 999;
			int nMinY = 999;
			int nSum = 0;
			int nFindIndex = -1;

			MIL_INT nWidth = 0;
			MIL_INT nHeight = 0;

			MbufChild2d(MBinarizeImg, stFindBlob.clRect.left, stFindBlob.clRect.top,
				stFindBlob.clRect.right - stFindBlob.clRect.left,
				stFindBlob.clRect.bottom - stFindBlob.clRect.top,
				&MilTmp);
			MbufInquire(MBinarizeImg, M_SIZE_X, &nWidth);
			MbufInquire(MBinarizeImg, M_SIZE_Y, &nHeight);


			CString sFile = _T("");
			sFile.Format(_T("D:\\Debug\\Roi_Crop%d.bmp"), i);
			MbufSave(sFile, MilTmp);

			IplImage* pImage = cvCreateImage(cvSize(nWidth, nHeight), IPL_DEPTH_8U, 1);
			MbufGet(MBinarizeImg, pImage->imageData);


#ifdef _DEBUG
			cvSaveImage("d:\\Debug\\IplImage.bmp", pImage);
#endif
			CvRect roi = cvRect(stFindBlob.clRect.left, stFindBlob.clRect.top, (stFindBlob.clRect.right - stFindBlob.clRect.left), (stFindBlob.clRect.bottom - stFindBlob.clRect.top));
			IplImage* cropped = cvCreateImage(cvSize(roi.width, roi.height), pImage->depth, pImage->nChannels);
			cvSetImageROI(pImage, roi);

			cvCopy(pImage, cropped);
			cvResetImageROI(pImage);

#ifdef _DEBUG
			cvSaveImage("d:\\Debug\\cropped.bmp", cropped);
#endif

			CvMemStorage* pStorage = cvCreateMemStorage(0);
			CvSeq* contours;
			CvSeq* result;
			CvMat arr = cvarrToMat(cropped);

			cvFindContours(&arr, pStorage, &contours, sizeof(CvContour), CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);
			while (contours)
			{
				result = cvApproxPoly(contours, sizeof(CvContour), pStorage, CV_POLY_APPROX_DP, cvContourPerimeter(contours)*0.02, 0);
				CvPoint* pt[50];
				

				for (int j = 0; j < result->total; j++)
				{
					pt[j] = (CvPoint*)cvGetSeqElem(result, j);

					// 센터에서 가장 가까운 포인트 찾는다.
					nSum = abs((int)stFindBlob.dResultX - (pt[j]->x + stFindBlob.clRect.left)) + abs((int)stFindBlob.dResultY - (pt[j]->y + stFindBlob.clRect.top));
					if (nSum < nMinX)
					{
						nMinX = nSum;
						nFindIndex = j;

						stFindBlob.nCenterX = stFindBlob.clRect.left + pt[j]->x;
						stFindBlob.nCenterY = stFindBlob.clRect.top + pt[j]->y;
					}

					g_clVision.DrawMOverlayCross(nUnit,
						(int)(pt[j]->x + stFindBlob.clRect.left), (int)(pt[j]->y + stFindBlob.clRect.top),
						10, M_COLOR_BLUE, 1, FALSE, PS_SOLID);
					TRACE("[%d][%d] =====<%d, %d> RECT(L:%d,T:%d,R:%d,B:%d)===========>%d, %d\n", i, j, (int)stFindBlob.dResultX, (int)stFindBlob.dResultY,
						stFindBlob.clRect.left, stFindBlob.clRect.top, stFindBlob.clRect.right, stFindBlob.clRect.bottom,
						(pt[j]->x + stFindBlob.clRect.left), (pt[j]->y + stFindBlob.clRect.top));
				}

				contours = contours->h_next;
			}			

			MbufFree(MilTmp);
			cvReleaseImage(&pImage);
			cvReleaseMemStorage(&pStorage);
		}
		
#endif
				
		//g_clVision.DrawMOverlayCircle(nUnit, rcFindBlob, M_COLOR_MAGENTA, 1, FALSE);
		g_clVision.DrawMOverlayBox(nUnit, rcFindBlob, M_COLOR_MAGENTA, 1, FALSE);
		g_clVision.DrawMOverlayCross(nUnit, 
			(int)(stFindBlob.dResultX), (int)(stFindBlob.dResultY), 
			10, M_COLOR_MAGENTA, 1, FALSE, PS_SOLID);

		/*g_clVision.DrawMOverlayCross(nUnit,
			stFindBlob.nCenterX, stFindBlob.nCenterY,
			10, M_COLOR_BLUE, 1, FALSE, PS_SOLID);*/
		
		if (i == 0)
		{
			clCenter.x = (int)stFindBlob.dResultX;
			clCenter.y = (int)stFindBlob.dResultY;
		}
		else
		{
			clCenter.x = (int)stFindBlob.nCenterX;// stFindBlob.dResultX;
			clCenter.y = (int)stFindBlob.nCenterY;// stFindBlob.dResultY;
			//clCenter.x = (int)((stFindBlob.clRect.right + stFindBlob.clRect.left) / 2);
			//clCenter.y = (int)((stFindBlob.clRect.bottom + stFindBlob.clRect.top) / 2);
		}

		g_FindRectPos_Ct(nUnit, g_clVision.m_pImgBuff[nUnit][2], nPitch, nSizeX, nSizeY, i, rcFindBlob, clCenter);
	}

	if (NULL != MBinarizeImg){
		MbufFree(MBinarizeImg);
		MBinarizeImg = M_NULL;
	}
	clMilBlob.ReleaseBlob();

	return true;
}

//-----------------------------------------------------------------------------
//
//	SFR INDEX별 RECT 영역 측정
//
//-----------------------------------------------------------------------------
bool g_FindRectPos_Ct(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, int nIndex, CRect rcRoi, CPoint clCenter)
{
	int		nNumIndexL = -1,
			nNumIndexR = -1,
			nNumIndexT = -1,
			nNumIndexB = -1;	
	CRect	rcBuff;
	TCHAR	szLog[SIZE_OF_1K];
	int nOffSetX = 0;
	int nOffSetY = 0;

	if (NULL == pImage)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 검사 영상 버퍼가 잘못되었습니다."));
		return false;
	}
	if (nSizeX <= 0 || nSizeY <= 0)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 검사 영상 사이즈가 잘못되었습니다. ( X : %d Y : %d )"), nSizeX, nSizeY);
		return false;
	}

	switch (nIndex)
	{
		/*case 0:		nNumIndexL = 0;		nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 1;		break;
		case 1:		nNumIndexL = -1;	nNumIndexR = 2;		nNumIndexT = -1;	nNumIndexB = 3;		break;
		case 2:		nNumIndexL = 4;		nNumIndexR = -1;	nNumIndexT = 5;		nNumIndexB = -1;	break;
		case 3:		nNumIndexL = -1;	nNumIndexR = 6;		nNumIndexT = 7;		nNumIndexB = -1;	break;
		case 4:		nNumIndexL = 8;		nNumIndexR = -1;	nNumIndexT = 9;		nNumIndexB = -1;	break;
		case 5:		nNumIndexL = -1;	nNumIndexR = 10;	nNumIndexT = -1;	nNumIndexB = 11;	break;
		case 6:		nNumIndexL = 12;	nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 13;	break;
		case 7:		nNumIndexL = -1;	nNumIndexR = 14;	nNumIndexT = 15;	nNumIndexB = -1;	break;
		case 8:		nNumIndexL = 16;	nNumIndexR = -1;	nNumIndexT = 17;	nNumIndexB = -1;	break;
		case 9:		nNumIndexL = -1;	nNumIndexR = 18;	nNumIndexT = -1;	nNumIndexB = 19;	break;
		case 10:	nNumIndexL = 20;	nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 21;	break;
		case 11:	nNumIndexL = -1;	nNumIndexR = 22;	nNumIndexT = 23;	nNumIndexB = -1;	break;
		case 12:	nNumIndexL = 24;	nNumIndexR = -1;	nNumIndexT = 25;	nNumIndexB = -1;	break;*/
		case 0:		nNumIndexL = 0;		nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 1;		break;
		case 1:		nNumIndexL = 3;		nNumIndexR = -1;	nNumIndexT = 2;		nNumIndexB = -1;	break;
		case 2:		nNumIndexL = -1;	nNumIndexR = 5;		nNumIndexT = -1;	nNumIndexB = 4;		break;
		case 3:		nNumIndexL = 7;		nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 6;		break;
		case 4:		nNumIndexL = -1;	nNumIndexR = 9;		nNumIndexT = -1;	nNumIndexB = 8;		break;
		case 5:		nNumIndexL = 11;	nNumIndexR = -1;	nNumIndexT = 10;	nNumIndexB = -1;	break;
		case 6:		nNumIndexL = -1;	nNumIndexR = 13;	nNumIndexT = 12;	nNumIndexB = -1;	break;
		case 7:		nNumIndexL = 15;	nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 14;	break;
		case 8:		nNumIndexL = -1;	nNumIndexR = 17;	nNumIndexT = -1;	nNumIndexB = 16;	break;
		case 9:		nNumIndexL = 19;	nNumIndexR = -1;	nNumIndexT = 18;	nNumIndexB = -1;	break;
		case 10:	nNumIndexL = -1;	nNumIndexR = 21;	nNumIndexT = 20;	nNumIndexB = -1;	break;
		case 11:	nNumIndexL = 23;	nNumIndexR = -1;	nNumIndexT = -1;	nNumIndexB = 22;	break;
		case 12:	nNumIndexL = -1;	nNumIndexR = 25;	nNumIndexT = -1;	nNumIndexB = 24;	break;
		default:
			_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 검사 마크 Index가 비정상입니다. [Index=%d]"), nIndex);
			return false;
	}

	if (rcRoi.left < 0 || rcRoi.top < 0 || rcRoi.right > nSizeX || rcRoi.bottom > nSizeY)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("SFR 마크 인식 위치가 비정상 입니다. ( L=%d, T=%d, R=%d, B=%d )"), rcRoi.left, rcRoi.top, rcRoi.right, rcRoi.bottom);
		return false;
	}	

	if (nIndex > 0)
	{
		if (nNumIndexL >= 0)
		{//! INDEX - LEFT SFR RECT POSITION
			nOffSetX = (clCenter.x - rcRoi.left) / 2;
			
			rcBuff.left = rcRoi.left + nOffSetX - (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.top = clCenter.y - (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.right = rcRoi.left + nOffSetX + (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.bottom = clCenter.y + (g_clModelData[nUnit].m_nRoiSizeX / 2);
			
			//rcBuff = g_GetField_RectLeft(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi, clCenter);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexL] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif		
		}
		if (nNumIndexR >= 0)
		{//! INDEX - RIGHT SFR RECT POSITION
			nOffSetX = (rcRoi.right - clCenter.x) / 2;

			rcBuff.left = clCenter.x + nOffSetX - (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.top = clCenter.y - (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.right = clCenter.x + nOffSetX + (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.bottom = clCenter.y + (g_clModelData[nUnit].m_nRoiSizeX / 2);

			//rcBuff = g_GetField_RectRight(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexR] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif
		}
		if (nNumIndexT >= 0)
		{//! INDEX - TOP SFR RECT POSITION

			//nOffSetX = (clCenter.x - rcRoi.left) / 2;
			nOffSetY = (clCenter.y - rcRoi.top) / 2;

			rcBuff.left = clCenter.x - (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.top = clCenter.y - nOffSetY - (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.right = clCenter.x + (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.bottom = rcRoi.top + nOffSetY + (g_clModelData[nUnit].m_nRoiSizeY / 2);

			//rcBuff = g_GetField_RectTop(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexT] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif
		}
		if (nNumIndexB >= 0)
		{//! INDEX - BOTTOM SFR RECT POSITION
			nOffSetY = (rcRoi.bottom - clCenter.y) / 2;

			rcBuff.left = clCenter.x - (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.top = clCenter.y + nOffSetY - (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.right = clCenter.x + (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.bottom = rcRoi.bottom - nOffSetY + (g_clModelData[nUnit].m_nRoiSizeY / 2);

			//rcBuff = g_GetField_RectBot(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexB] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif
		}
	}
	else
	{
		if (nNumIndexL >= 0)
		{//! INDEX - LEFT SFR RECT POSITION
			
			rcBuff.left = rcRoi.left - (g_clModelData[nUnit].m_nRoiSizeX / 2) + 5;
			rcBuff.right = rcRoi.left + (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.top = rcRoi.top + ((rcRoi.bottom - rcRoi.top) / 2) - (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.bottom = rcRoi.top + ((rcRoi.bottom - rcRoi.top) / 2) + (g_clModelData[nUnit].m_nRoiSizeY / 2);
			//rcBuff = g_GetField_RectLeft(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi, clCenter);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexL] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif		
		}
		if (nNumIndexR >= 0)
		{//! INDEX - RIGHT SFR RECT POSITION
			rcBuff = g_GetField_RectRight(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexR] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif
		}
		if (nNumIndexT >= 0)
		{//! INDEX - TOP SFR RECT POSITION
		 	rcBuff = g_GetField_RectTop(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexT] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif
		}
		if (nNumIndexB >= 0)
		{//! INDEX - BOTTOM SFR RECT POSITION			
			rcBuff.left = rcRoi.left + ((rcRoi.right - rcRoi.left) / 2) - (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.top = rcRoi.bottom - (g_clModelData[nUnit].m_nRoiSizeX / 2);
			rcBuff.right = rcRoi.left + ((rcRoi.right - rcRoi.left) / 2) + (g_clModelData[nUnit].m_nRoiSizeY / 2);
			rcBuff.bottom = rcRoi.bottom + (g_clModelData[nUnit].m_nRoiSizeX / 2);

			//rcBuff = g_GetField_RectBot(nUnit, pImage, nPitch, nSizeX, nSizeY, rcRoi);
			g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nNumIndexB] = rcBuff;

#ifdef ON_LINE_MIL
			g_clVision.DrawMOverlayBox(nUnit, rcBuff, M_COLOR_CYAN, 1, FALSE, PS_SOLID);
#endif
		}
	}

	return true;
}

//-----------------------------------------------------------------------------
//
//	INDEX BOTTOM LEFT
//
//-----------------------------------------------------------------------------
CRect g_GetField_RectLeft(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, CRect rcRoi, CPoint clCenter)
{
	CSize	siOffset = CSize(10, 10);
	int		x = 0, y = 0, sum = 0, pos = 0;
	int		maxPos = -1, maxVal = 0, tmpVal = 0;
	int		sx = 0, sy = 0, ex = 0, ey = 0;
	int		cx = 0, cy = 0;
	int		tmpHist[1000];
	CRect	rcResult = CRect(-1, -1, -1, -1);
	CRect rcRect;

	::memset(tmpHist, 0, sizeof(int)*(1000));

	rcRect.left = rcRoi.left;
	rcRect.top = rcRoi.top;
	rcRect.right = clCenter.x;
	rcRect.bottom = rcRoi.bottom;

	//cx	= (rcRoi.left + rcRoi.right) / 2;
	//cy	= (rcRoi.top + rcRoi.bottom) / 2;
	cx = clCenter.x;
	cy = clCenter.y;

	sx = rcRect.left - siOffset.cx;//(rcRect.left + rcRect.Width() / 4) - siOffset.cx;
	ex = rcRect.right + siOffset.cx;// (rcRect.left + rcRect.Width() / 4) + siOffset.cx;
	sy	= rcRect.top - siOffset.cy;
	ey	= rcRect.bottom + siOffset.cy;

	g_clVision.DrawMOverlayBox(nUnit, rcRect, M_COLOR_GREEN, 1, 1, PS_DOT);
	g_clVision.DrawMOverlayBox(nUnit, sx, sy, ex, ey, M_COLOR_RED, 1, 1, PS_SOLID);

	if (sx < 0)			sx = 0;
	if (sy < 0)			sy = 0;
	if (ex >= nSizeX)	ex = nSizeX - 1;
	if (ey >= nSizeY)	ey = nSizeY - 1;

	for (y = sy; y < ey; y++)
	{
		sum = 0;

		for (x = sx; x < ex; x++)
		{
			pos = y * nPitch + x;
			sum += pImage[pos];
		}
		tmpHist[y - sy] = sum;
	}

	for (y = sy + 5; y < ey - 5; y++)
	{
		tmpVal = tmpHist[y - sy] + tmpHist[y - sy - 1] - (tmpHist[y - sy + 1] + tmpHist[y - sy + 2]);

		if (tmpVal > maxVal)
		{
			maxVal = tmpVal;
			maxPos = y;
		}
	}

	sx	= ((rcRect.left + rcRect.Width() / 4) - g_clModelData[nUnit].m_nRoiSizeX);
	ex	= ((rcRect.left + rcRect.Width() / 4) + g_clModelData[nUnit].m_nRoiSizeX);
	sy	= (maxPos - g_clModelData[nUnit].m_nRoiSizeY);
	ey	= (maxPos + g_clModelData[nUnit].m_nRoiSizeY);
	if (sx < 5)				sx = 5;
	if (sy < 5)				sy = 5;
	if (ex >= nSizeX - 5)	ex = nSizeX - 5;
	if (ey >= nSizeY - 5)	ey = nSizeY - 5;


	rcResult.left	= sx;
	rcResult.right	= ex;
	rcResult.top	= sy;
	rcResult.bottom = ey;

	return rcResult;
}

//-----------------------------------------------------------------------------
//
//	INDEX BOTTOM RIGHT
//
//-----------------------------------------------------------------------------
CRect g_GetField_RectRight(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, CRect rcRoi)
{
	CSize	siOffset = CSize(50, 50);
	int		x = 0, y = 0, sum = 0, pos = 0;
	int		minPos = -1, minVal = 0, tmpVal = 0;
	int		sx = 0, sy = 0, ex = 0, ey = 0;
	int		cx = 0, cy = 0;
	int		tmpHist[1000];
	CRect	rcResult = CRect(-1, -1, -1, -1);

	::memset(tmpHist, 0, sizeof(int)*(1000));

	cx	= (rcRoi.left + rcRoi.right) / 2;
	cy	= (rcRoi.top + rcRoi.bottom) / 2;

	sx	= (rcRoi.right - rcRoi.Width() / 4) - siOffset.cx;
	ex	= (rcRoi.right - rcRoi.Width() / 4) + siOffset.cx;
	sy	= cy - siOffset.cy;
	ey	= cy + siOffset.cy;
	if (sx < 0)			sx = 0;
	if (sy < 0)			sy = 0;
	if (ex >= nSizeX)	ex = nSizeX - 1;
	if (ey >= nSizeY)	ey = nSizeY - 1;

	for (y = sy; y < ey; y++)
	{
		sum = 0;

		for (x = sx; x < ex; x++)
		{
			pos = y * nPitch + x;
			sum += pImage[pos];
		}
		tmpHist[y - sy] = sum;
	}

	for (y = sy + 5; y < ey - 5; y++)
	{
		tmpVal = tmpHist[y - sy] + tmpHist[y - sy - 1] - (tmpHist[y - sy + 1] + tmpHist[y - sy + 2]);

		if (tmpVal < minVal)
		{
			minVal = tmpVal;
			minPos = y;
		}
	}

	sx	= ((rcRoi.right - rcRoi.Width() / 4) - g_clModelData[nUnit].m_nRoiSizeX);
	ex	= ((rcRoi.right - rcRoi.Width() / 4) + g_clModelData[nUnit].m_nRoiSizeX);
	sy	= (minPos - g_clModelData[nUnit].m_nRoiSizeY);
	ey	= (minPos + g_clModelData[nUnit].m_nRoiSizeY);
	if (sx < 5)				sx = 5;
	if (sy < 5)				sy = 5;
	if (ex >= nSizeX - 5)	ex = nSizeX - 5;
	if (ey >= nSizeY - 5)	ey = nSizeY - 5;


	rcResult.left	= sx;
	rcResult.right	= ex;
	rcResult.top	= sy;
	rcResult.bottom = ey;

	return rcResult;
}

//-----------------------------------------------------------------------------
//
//	INDEX BOTTOM TOP
//
//-----------------------------------------------------------------------------
CRect g_GetField_RectTop(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, CRect rcRoi)
{
	CSize	siOffset = CSize(50, 50);
	int		x = 0, y = 0, sum = 0, pos = 0;
	int		maxPos = -1, maxVal = 0, tmpVal = 0;
	int		sx = 0, sy = 0, ex = 0, ey = 0;
	int		cx = 0, cy = 0;
	int		tmpHist[1000];
	CRect	rcResult = CRect(-1, -1, -1, -1);

	::memset(tmpHist, 0, sizeof(int)*(1000));

	cx	= (rcRoi.left + rcRoi.right) / 2;
	cy	= (rcRoi.top + rcRoi.bottom) / 2;

	sx	= cx - siOffset.cx;
	ex	= cx + siOffset.cx;
	sy	= (rcRoi.top + rcRoi.Height() / 4) - siOffset.cy;
	ey	= (rcRoi.top + rcRoi.Height() / 4) + siOffset.cy;
	if (sx < 0)			sx = 0;
	if (sy < 0)			sy = 0;
	if (ex >= nSizeX)	ex = nSizeX - 1;
	if (ey >= nSizeY)	ey = nSizeY - 1;

	for (x = sx; x < ex; x++)
	{	
		sum = 0;

		for (y = sy; y < ey; y++)
		{
			pos = y * nPitch + x;
			sum += pImage[pos];
		}
		tmpHist[x - sx] = sum;
	}

	for (x = sx + 5; x < ex - 5; x++)
	{
		tmpVal = tmpHist[x - sx] + tmpHist[x - sx - 1] - (tmpHist[x - sx + 1] + tmpHist[x - sx + 2]);

		if (tmpVal > maxVal)
		{
			maxVal = tmpVal;
			maxPos = x;
		}
	}

	sx	= (maxPos - g_clModelData[nUnit].m_nRoiSizeY);
	ex	= (maxPos + g_clModelData[nUnit].m_nRoiSizeY);
	sy	= ((rcRoi.top + rcRoi.Height() / 4) - g_clModelData[nUnit].m_nRoiSizeX);
	ey	= ((rcRoi.top + rcRoi.Height() / 4) + g_clModelData[nUnit].m_nRoiSizeX);
	if (sx < 5)				sx = 5;
	if (sy < 5)				sy = 5;
	if (ex >= nSizeX - 5)	ex = nSizeX - 5;
	if (ey >= nSizeY - 5)	ey = nSizeY - 5;

	rcResult.left	= sx;
	rcResult.right	= ex;
	rcResult.top	= sy;
	rcResult.bottom = ey;

	return rcResult;
}

//-----------------------------------------------------------------------------
//
//	INDEX BOTTOM FIELD
//
//-----------------------------------------------------------------------------
CRect g_GetField_RectBot(int nUnit, unsigned char* pImage, int nPitch, int nSizeX, int nSizeY, CRect rcRoi)
{
	CSize	siOffset = CSize(50, 50);
	int		x = 0, y = 0, sum = 0, pos = 0;
	int		minPos = -1, minVal = 0, tmpVal = 0;
	int		sx = 0, sy = 0, ex = 0, ey = 0;
	int		cx = 0, cy = 0;
	int		tmpHist[1000];
	CRect	rcResult = CRect(-1, -1, -1, -1);

	::memset(tmpHist, 0, sizeof(int)*(1000));

	cx	= (rcRoi.left + rcRoi.right) / 2;
	cy	= (rcRoi.top + rcRoi.bottom) / 2;

	sx	= cx - siOffset.cx;
	ex	= cx + siOffset.cx;
	sy	= (rcRoi.bottom - rcRoi.Width() / 4) - siOffset.cy;
	ey	= (rcRoi.bottom - rcRoi.Width() / 4) + siOffset.cy;
	if (sx < 0)			sx = 0;
	if (sy < 0)			sy = 0;
	if (ex >= nSizeX)	ex = nSizeX - 1;
	if (ey >= nSizeY)	ey = nSizeY - 1;

	for (x = sx; x < ex; x++)
	{
		sum = 0;

		for (y = sy; y < ey; y++)
		{
			pos = y * nPitch + x;
			sum += pImage[pos];
		}
		tmpHist[x - sx] = sum;
	}

	for (x = ex - 5; x > sx + 5; x--)
	{
		tmpVal = tmpHist[x - sx] + tmpHist[x - sx - 1] - (tmpHist[x - sx + 1] + tmpHist[x - sx + 2]);

		if (tmpVal < minVal)
		{
			minVal = tmpVal;
			minPos = x;
		}
	}

	sx	= (minPos - g_clModelData[nUnit].m_nRoiSizeY);
	ex	= (minPos + g_clModelData[nUnit].m_nRoiSizeY);
	sy	= ((rcRoi.bottom - rcRoi.Height() / 4) - g_clModelData[nUnit].m_nRoiSizeX);
	ey	= ((rcRoi.bottom - rcRoi.Height() / 4) + g_clModelData[nUnit].m_nRoiSizeX);
	if (sx < 5)				sx = 5;
	if (sy < 5)				sy = 5;
	if (ex >= nSizeX - 5)	ex = nSizeX - 5;
	if (ey >= nSizeY - 5)	ey = nSizeY - 5;

	rcResult.left	= sx;
	rcResult.right	= ex;
	rcResult.top	= sy;
	rcResult.bottom = ey;

	return rcResult;
}


//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_GetPatchCenterAndSFR(int nUnit, int nIndex)
{// SFR 값 계산..
	bool	bRetVal;
	int		nPitch, nSizeX, nSizeY;
	int		nCntCheck;
	//TCHAR szLog[SIZE_OF_1K];

	nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_PITCH, M_NULL);
	nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_X, M_NULL);
	nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcChild[nUnit][1], M_SIZE_Y, M_NULL);


#ifdef _DEBUG
	MIL_ID MilTmp;

	MbufChild2d(g_clVision.m_MilCcdProcChild[nUnit][1], g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex].top,
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex].right - g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex].left,
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex].bottom - g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex].top,
		&MilTmp);
	CString sFile = _T("");
	sFile.Format(_T("D:\\Debug\\%d_Roi.bmp"), nIndex);
	MbufSave(sFile, MilTmp);
	MbufFree(MilTmp);
#endif


	//! m_pImgBuff -> RGB 영역으로 변경 필요함.
	bRetVal = g_clAlg[nUnit].getSFR2(
		g_clVision.m_pImgBuff[nUnit][0],
		g_clVision.m_pImgBuff[nUnit][1],
		g_clVision.m_pImgBuff[nUnit][2],
		nPitch, nSizeY,
		(float)g_clModelData[nUnit].m_dCcdCellSize,
		g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[nIndex],
		g_clTaskWork[nUnit].m_stSfrInsp.nDataCount[nIndex],
		g_clTaskWork[nUnit].m_stSfrInsp.dSfrDataX[nIndex],
		g_clTaskWork[nUnit].m_stSfrInsp.dSfrDataY[nIndex],
		1);



	////////////////////////////////////////////////////////////////////////////////////////////
	//// 정재호 20140905. 기존 해상도 큰 영상에서는 iDataCnt 값이 크게 나옴.. (SFR 검사 Box 크기가 큼)	int nCntCheck;
	//// iDataCnt 값이 SFR 검사 영역 크기의 1/4 보다 크면 검사 성공으로 판단.

	if (g_clModelData[nUnit].m_nRoiSizeX < g_clModelData[nUnit].m_nRoiSizeY)
		nCntCheck = g_clModelData[nUnit].m_nRoiSizeX / 4;
	else
		nCntCheck = g_clModelData[nUnit].m_nRoiSizeY / 4;

	if (g_clTaskWork[nUnit].m_stSfrInsp.nDataCount[nIndex] > nCntCheck &&
		bRetVal == true)
		//	if(SFR.iDataCnt[iInspPos]>30 && okFlag)
		//	////////////////////////////////////////////////////////////////////////////////////////// 수정 끝.
	{
		g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[nIndex] = (float)(g_clAlg[nUnit].GetValue_SFR_N_4());
		g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN8[nIndex] = (float)(g_clAlg[nUnit].GetValue_SFR_N_8());
		//		if(SFR._64_fSfrN4[iInspPos] > SFR._64_fSfrN8[iInspPos])
		//			SFR._64_fSfrN4[iInspPos] = 0;
	}
	else
	{
		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------
//
//	광축검사
//
//-----------------------------------------------------------------------------
bool g_FindOpticalCenter(int nUnit)
{
	TCHAR szLog[SIZE_OF_1K];
	double dShiftX, dShiftY;
	CRect roi;
	bool bRetVal;

	roi.left = (int)(g_clModelData[nUnit].m_nWidth * 0.1 + 0.5);
	roi.top = (int)((g_clModelData[nUnit].m_nHeight - 4) * 0.1 + 0.5);
	roi.right = (int)(g_clModelData[nUnit].m_nWidth * 0.9 + 0.5);
	roi.bottom = (int)((g_clModelData[nUnit].m_nHeight - 4) * 0.9 + 0.5);

	g_clVision.ClearOverlay(nUnit);

	bRetVal = g_GetOpticAxis(nUnit, 4, 0, dShiftX, dShiftY);	

	if (bRetVal == true)
	{
		g_clVision.DrawMOverlayCross(nUnit, (int)dShiftX, (int)dShiftY, 500, M_COLOR_RED, 1, FALSE, PS_SOLID);
		g_clVision.DrawOverlayAll(nUnit);
		
		_stprintf_s(szLog, SIZE_OF_1K, _T("광축 Shift (%.01f, %.01f) 검사 완료."), dShiftX, dShiftY);
		AddLog(szLog, 0, nUnit);
	}
	else
	{		
		//g_SaveInspImage(OPTIC_IMAGE_SAVE, g_clTaskWork[nUnit].m_nCurrentStep);
		AddLog(_T("광축 검사 실패."), 1, nUnit);
		return false;
	}

	g_clTaskWork[nUnit].m_dOpticalPosX = dShiftX;
	g_clTaskWork[nUnit].m_dOpticalPosY = dShiftY;

	g_clTaskWork[nUnit].m_dOpticalShiftX = (g_clModelData[nUnit].m_nWidth / 2 - dShiftX) * g_clModelData[nUnit].m_dCcdCellSize / 1000;
	g_clTaskWork[nUnit].m_dOpticalShiftY = ((g_clModelData[nUnit].m_nHeight - 4) / 2 - dShiftY) * g_clModelData[nUnit].m_dCcdCellSize / 1000;

	if (fabs(g_clTaskWork[nUnit].m_dOpticalShiftX) > 1 || fabs(g_clTaskWork[nUnit].m_dOpticalShiftY) > 1)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("광축 Shift(%.03lf, %.03lf) Spec Over"), g_clTaskWork[nUnit].m_dOpticalShiftX, g_clTaskWork[nUnit].m_dOpticalShiftY);
		AddLog(szLog, 0, nUnit);

		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------
//
//	광축 검사
//
//-----------------------------------------------------------------------------
bool g_GetOpticAxis(int nUnit, int nScale, int nTh, double& dOffsetX, double& dOffsetY)
{
	CRect  centRoi, upperRoi, inspRoi;
	int* pHistX;
	int* pHistY;
	int centAvg, upperAvg, inspAvg;
	int x, y, nPos, nSum;
	int sx, ex, sy, ey;
	int nVal;

	int nPitch = (int)MbufInquire(g_clVision.m_MilCcdProcImage[nUnit], M_PITCH, NULL);
	int nSizeX = (int)MbufInquire(g_clVision.m_MilCcdProcImage[nUnit], M_SIZE_X, NULL);
	int nSizeY = (int)MbufInquire(g_clVision.m_MilCcdProcImage[nUnit], M_SIZE_Y, NULL);

	dOffsetX = nSizeX >> 1;
	dOffsetY = nSizeY >> 1;

	pHistX = new int[nSizeX];
	memset(pHistX, 0, sizeof(int) * nSizeX);
	pHistY = new int[nSizeY];
	memset(pHistY, 0, sizeof(int) * nSizeY);

	centRoi.left = (long)dOffsetX - nSizeX / 20;
	centRoi.right = (long)dOffsetX + nSizeX / 20;
	centRoi.top = (long)dOffsetY - nSizeY / 20;
	centRoi.bottom = (long)dOffsetY + nSizeY / 20;

	upperRoi.left = (long)dOffsetX - nSizeX / 20;
	upperRoi.right = (long)dOffsetX + nSizeX / 20;
	upperRoi.top = (long)0;
	upperRoi.bottom = (long)nSizeY / 20;

	inspRoi.left = (long)nSizeX / 20;
	inspRoi.right = (long)nSizeX - inspRoi.left;
	inspRoi.top = (long)nSizeY / 20;
	inspRoi.bottom = (long)nSizeY - inspRoi.top;

#ifdef ON_LINE_MIL
	g_clVision.DrawMOverlayBox(nUnit, centRoi, M_COLOR_GREEN, 1, FALSE, PS_SOLID);
	g_clVision.DrawMOverlayBox(nUnit, upperRoi, M_COLOR_RED, 1, FALSE, PS_SOLID);
	g_clVision.DrawMOverlayBox(nUnit, inspRoi, M_COLOR_BLUE, 1, FALSE, PS_SOLID);
#endif

	sx = centRoi.left;
	ex = centRoi.right;
	sy = centRoi.top;
	ey = centRoi.bottom;

	nSum = 0;
	for (y = sy; y < ey; y++)
	{
		nPos = y * nPitch + sx;
		for (x = sx; x < ex; x++)
		{
			nSum += g_clVision.m_pImgBuff[nUnit][1][nPos];
			nPos++;
		}
	}
	centAvg = nSum / ((ex - sx) * (ey - sy));

	sx = upperRoi.left;
	ex = upperRoi.right;
	sy = upperRoi.top;
	ey = upperRoi.bottom;

	nSum = 0;
	for (y = sy; y < ey; y++)
	{
		nPos = y * nPitch + sx;
		for (x = sx; x < ex; x++)
		{
			nSum += g_clVision.m_pImgBuff[nUnit][1][nPos];
			nPos++;
		}
	}
	upperAvg = nSum / ((ex - sx) * (ey - sy));


	if (centAvg < 20/*60*/)	//KYH Mando Camera 측정 수정
	{
		AddLog(_T("[광축 검사 실패] 중앙부의 밝기 값이 20보다 낮습니다."), 0, nUnit);
		return false;
	}

	if (centAvg < upperAvg)
	{
		AddLog(_T("[광축 검사 실패] 중앙부의 밝기 값이 상부 밝기 값 보다 낮습니다."), 0, nUnit);
		return false;
	}

	if (centAvg - upperAvg < 10/*20*/)	//KYH Mando Camera 측정 수정
	{
		AddLog(_T("[광축 검사 실패] 중앙부와 상부의 밝기 값 차이가 10 보다 작습니다."), 0, nUnit);
		return false;
	}

	g_clTaskWork[nUnit].m_nOpticalTh = inspAvg = (centAvg + upperAvg) / 2;

	sx = inspRoi.left;
	ex = inspRoi.right;
	sy = inspRoi.top;
	ey = inspRoi.bottom;

	nSum = 0;
	for (y = sy; y < ey; y++)
	{
		nPos = y * nPitch + sx;
		for (x = sx; x < ex; x++)
		{
			nVal = g_clVision.m_pImgBuff[nUnit][1][nPos];

			if (nVal >= inspAvg)
			{
				pHistX[x]++;
				pHistY[y]++;
				nSum++;
			}
			nPos++;
		}
	}


	float fAddVal = 0;
	for (x = sx; x < ex; x++)
	{
		fAddVal += (float)(pHistX[x] * x);
	}

	float fCenterX = fAddVal / nSum;

	if ((fCenterX < (nPitch * 0.3)) || ((fCenterX > nPitch * 0.7)))
	{
		AddLog(_T("[광축 검사] X Shift 값이 비정상입니다."), 0, nUnit);
		return false;

	}


	fAddVal = 0;
	for (y = sy; y < ey; y++)
	{
		fAddVal += (float)(pHistY[y] * y);
	}

	float fCenterY = fAddVal / nSum;

	if ((fCenterY < (nSizeY * 0.3)) || ((fCenterY > nSizeY * 0.7)))
	{
		AddLog(_T("[광축 검사] Y Shift 값이 비정상입니다."), 0, nUnit);
		return false;
	}

	dOffsetX = fCenterX;
	dOffsetY = fCenterY;

	delete[] pHistX;
	pHistX = NULL;

	delete[] pHistY;
	pHistY = NULL;

	return true;
}


//-----------------------------------------------------------------------------
//
//	MTF영상으로 Shift 보정량 계산
//
//-----------------------------------------------------------------------------
bool g_CalcImageAlign(int nUnit)
{
    CString sLog = "";
	double dShiftX, dShiftY, dOcResultX,dOcResultY;
	double dRad, dAng;
	double dWidth, dHeight;
	double dCenterX = g_clModelData[nUnit].m_nWidth / 2;
	double dCenterY = (g_clModelData[nUnit].m_nHeight) / 2;//(g_clModelData[nUnit].m_nHeight - 4) / 2;
	int i = 0;

	dShiftX = ((g_clTaskWork[nUnit].m_clPtCircle[0].x + g_clTaskWork[nUnit].m_clPtCircle[1].x + g_clTaskWork[nUnit].m_clPtCircle[2].x + g_clTaskWork[nUnit].m_clPtCircle[3].x) / 4.0) - dCenterX;
	dShiftY = ((g_clTaskWork[nUnit].m_clPtCircle[0].y + g_clTaskWork[nUnit].m_clPtCircle[1].y + g_clTaskWork[nUnit].m_clPtCircle[2].y + g_clTaskWork[nUnit].m_clPtCircle[3].y) / 4.0) - dCenterY;

	dOcResultX = dShiftX;
	dOcResultY = dShiftY;

	dShiftX *= g_clModelData[nUnit].m_dCcdCellSize / 1000;
	dShiftY *= g_clModelData[nUnit].m_dCcdCellSize / 1000;
	dShiftY *= -1;


	dWidth = (g_clTaskWork[nUnit].m_clPtCircle[3].x - g_clTaskWork[nUnit].m_clPtCircle[2].x) * g_clModelData[nUnit].m_dCcdCellSize / /*1280*/1000;
	dHeight = (g_clTaskWork[nUnit].m_clPtCircle[3].y - g_clTaskWork[nUnit].m_clPtCircle[2].y) * g_clModelData[nUnit].m_dCcdCellSize / /*960*/1000;
	dRad = atan(dHeight / dWidth);
	dAng = dRad * 180.0 / M_PI;

	if (fabs(dShiftX) > 1.0 || fabs(dShiftY) > 1.0 || fabs(dAng) > 3.0)		// 임의값...
	{
		AddLog(_T("이미지 얼라인 보정값 리미트 에러."), 0, nUnit);
		return false;
	}

	g_clTaskWork[nUnit].m_dImgShiftX = dShiftX;
	g_clTaskWork[nUnit].m_dImgShiftY = dShiftY;
	g_clTaskWork[nUnit].m_dImgShiftTh = dAng;
    //
	g_clTaskWork[nUnit].m_dOcResultX = dOcResultX;//g_clTaskWork[nUnit].m_dImgShiftX / (g_clModelData[nUnit].m_dCcdCellSize / 1000);
	g_clTaskWork[nUnit].m_dOcResultY = dOcResultY;//g_clTaskWork[nUnit].m_dImgShiftY / (g_clModelData[nUnit].m_dCcdCellSize / 1000);
	g_clTaskWork[nUnit].m_dThResultY = g_clTaskWork[nUnit].m_dImgShiftTh;// / (g_clModelData[nUnit].m_dCcdCellSize / 1000);

    g_clMandoInspLog[nUnit].m_LogOC_X = dCenterX + (g_clTaskWork[nUnit].m_dOcResultX - g_clModelData[nUnit].m_dOcOffsetX[g_clModelData[0].m_nModelType]);
    g_clMandoInspLog[nUnit].m_LogOC_Y = dCenterY + (g_clTaskWork[nUnit].m_dOcResultY - g_clModelData[nUnit].m_dOcOffsetX[g_clModelData[0].m_nModelType]);

    g_clMandoInspLog[nUnit].m_LogOC_DelatX = g_clTaskWork[nUnit].m_dOcResultX - g_clModelData[nUnit].m_dOcOffsetX[g_clModelData[0].m_nModelType];
	g_clMandoInspLog[nUnit].m_LogOC_DelatY = g_clTaskWork[nUnit].m_dOcResultY - g_clModelData[nUnit].m_dOcOffsetX[g_clModelData[0].m_nModelType];

	g_clMesCommunication[nUnit].m_dMesOC[0] = g_clMandoInspLog[nUnit].m_LogOC_X;
	g_clMesCommunication[nUnit].m_dMesOC[1] = g_clMandoInspLog[nUnit].m_LogOC_Y;
	g_clMesCommunication[nUnit].m_dMesDeltaOC[0] = g_clMandoInspLog[nUnit].m_LogOC_DelatX;
	g_clMesCommunication[nUnit].m_dMesDeltaOC[1] = g_clMandoInspLog[nUnit].m_LogOC_DelatY;

	sLog.Format(_T("[CCD] Oc x: %.2lf, Oc y: %.2lf , Rotate: %.2lf"), g_clTaskWork[nUnit].m_dOcResultX, g_clTaskWork[nUnit].m_dOcResultY, g_clTaskWork[nUnit].m_dThResultY);
    AddLog(sLog, 0, nUnit);
	sLog.Format(_T("[CCD] Offset x: %.2lf, Offset y: %.2lf"), g_clMandoInspLog[nUnit].m_LogOC_DelatX, g_clMandoInspLog[nUnit].m_LogOC_DelatY);
	AddLog(sLog, 0, nUnit);
	return true;
}
void g_CheckOc(int nUnit)
{
	CString sLog = "";
	TCHAR	szLog[SIZE_OF_1K];
	int i = 0;
	for (i = 0; i < 2; i++)
	{
		g_clMesCommunication[nUnit].m_dMesOCResult[i] = 1;
		g_clMesCommunication[nUnit].m_dMesDeltaOCResult[i] = 1;
	}
	//
	if (g_clMandoInspLog[nUnit].m_LogOC_X < (g_clModelData[nUnit].m_nWidth / 2 - 20) || g_clMandoInspLog[nUnit].m_LogOC_X >(g_clModelData[nUnit].m_nWidth / 2 + 20))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[OC] OC X Spec Out %lf [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_X, (g_clModelData[nUnit].m_nWidth / 2 - 20), (g_clModelData[nUnit].m_nWidth / 2 + 20));
		g_clMandoInspLog[nUnit].m_sNGList += _T(" [OC X NG]");

		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt].Format(_T("NG OC X:%lf [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_X, (g_clModelData[nUnit].m_nWidth / 2 - 20), (g_clModelData[nUnit].m_nWidth / 2 + 20));
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, nUnit);
		g_clMandoInspLog[nUnit].m_bInspRes = false;
		g_clMesCommunication[nUnit].m_dMesOCResult[0] = 0;
	}
	if (g_clMandoInspLog[nUnit].m_LogOC_Y < (g_clModelData[nUnit].m_nHeight / 2 - 20) || g_clMandoInspLog[nUnit].m_LogOC_Y >(g_clModelData[nUnit].m_nHeight / 2 + 20))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[OC] OC Y Spec Out %lf [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_Y, (g_clModelData[nUnit].m_nHeight / 2 - 20), (g_clModelData[nUnit].m_nHeight / 2 + 20));
		g_clMandoInspLog[nUnit].m_sNGList += _T(" [OC Y NG]");

		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt].Format(_T("NG OC Y:%lf [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_Y, (g_clModelData[nUnit].m_nHeight / 2 - 20), (g_clModelData[nUnit].m_nHeight / 2 + 20));
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}

		AddLog(szLog, 0, nUnit);
		g_clMandoInspLog[nUnit].m_bInspRes = false;
		g_clMesCommunication[nUnit].m_dMesOCResult[1] = 0;
	}

	//DELTA
	if (g_clMandoInspLog[nUnit].m_LogOC_DelatX < -20 || g_clMandoInspLog[nUnit].m_LogOC_DelatX >20)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[OC] OC DELTA X Spec Out %lf [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_DelatX, -20,20);
		g_clMandoInspLog[nUnit].m_sNGList += _T(" [OC DELTA X NG]");

		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt].Format(_T("NG OC DELTA X:%lf  [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_DelatX, -20, 20);
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, nUnit);
		g_clMandoInspLog[nUnit].m_bInspRes = false;
		g_clMesCommunication[nUnit].m_dMesDeltaOCResult[0] = 0;
	}
	if (g_clMandoInspLog[nUnit].m_LogOC_DelatY <-20 || g_clMandoInspLog[nUnit].m_LogOC_DelatY > 20)
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("	[OC] OC DELTA Y Spec Out %lf [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_DelatY, -20, 20);
		g_clMandoInspLog[nUnit].m_sNGList += _T(" [OC DELTA Y NG]");

		if (g_clMandoInspLog[nUnit].m_nNGCnt < 30)
		{
			g_clMandoInspLog[nUnit].m_sDispNG[g_clMandoInspLog[nUnit].m_nNGCnt].Format(_T("NG OC DELTA Y:%lf  [%d~%d]"), g_clMandoInspLog[nUnit].m_LogOC_DelatY, -20, 20);
			g_clMandoInspLog[nUnit].m_nNGCnt++;
		}
		AddLog(szLog, 0, nUnit);
		g_clMandoInspLog[nUnit].m_bInspRes = false;
		g_clMesCommunication[nUnit].m_dMesDeltaOCResult[1] = 0;
	}
	
}
//-----------------------------------------------------------------------------
//
//	ALIGN 보정량 Limit Check
//
//-----------------------------------------------------------------------------
int g_CheckAlignLimit(int nUnit, double dX, double dY, double dTh)
{
	TCHAR szLog[SIZE_OF_1K];

	if ((fabs(dX) > g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_X]) || (fabs(dY) > g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_Y]) ||
		(fabs(dTh) > g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_TH]))
	{
		_stprintf_s(szLog, SIZE_OF_1K, _T("[ERROR] PCB부 X,Y,T 보정값(%.03lf, %.03lf, %.03lf)이 보정 Limit(%.03lf, %.03lf, %.03lf)을 초과했습니다."),
			dX, dY, dTh, g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_X], g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_Y], g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_TH]);
		AddLog(szLog, 0, nUnit);

		return 0;
	}

	
	if ((fabs(dX) > g_clModelData[nUnit].m_dOkLimit[MOTOR_PCB_X]) || (fabs(dY) > g_clModelData[nUnit].m_dOkLimit[MOTOR_PCB_Y]) ||
		(fabs(dTh) > g_clModelData[nUnit].m_dOkLimit[MOTOR_PCB_TH]))
	{			
		return 1;
	}
	
	return 2;
}

//-----------------------------------------------------------------------------
//
//	nIndex : 0 = 내측, 1 = 외측
//
//-----------------------------------------------------------------------------
//bool g_CalcLaserTilt(int nUnit, int nIndex)
bool g_CalcLaserTilt(int nUnit, double& dTx, double& dTy)
{
	double dLength[4];
	double dAvgTop, dAvgBottom;
	double dAvgLeft, dAvgRight;
	double dHeight, dWidth;
	double dRadian, dTheta;
	int i;

	dTx = 0.0;
	dTy = 0.0;

	//if (nIndex < 0 || nIndex > 2)
	//	return false;

	for (i = 0; i < 4; i++)
		dLength[i] = 0.0;
	dAvgTop = 0.0;
	dAvgBottom = 0.0;
	dAvgLeft = 0.0;
	dAvgRight = 0.0;
	dHeight = 0.0;
	dWidth = 0.0;
	dRadian = 0.0;
	dTheta = 0.0;

	// ======================= 계산
	//모터간 거리(밑변)
	dLength[0] = abs(g_clTaskWork[nUnit].m_clDpLaserPos[0].y - g_clTaskWork[nUnit].m_clDpLaserPos[3].y);  // left  
	dLength[1] = abs(g_clTaskWork[nUnit].m_clDpLaserPos[0].x - g_clTaskWork[nUnit].m_clDpLaserPos[1].x);  // top
	dLength[2] = abs(g_clTaskWork[nUnit].m_clDpLaserPos[1].y - g_clTaskWork[nUnit].m_clDpLaserPos[2].y);  // Right
	dLength[3] = abs(g_clTaskWork[nUnit].m_clDpLaserPos[2].x - g_clTaskWork[nUnit].m_clDpLaserPos[3].x);  // bottom

	// ======================= X,Y 평균( 중심 레이저)
	
	dAvgTop = (g_clTaskWork[nUnit].m_dLaserVal[0] + g_clTaskWork[nUnit].m_dLaserVal[1]) / 2;
	dAvgBottom = (g_clTaskWork[nUnit].m_dLaserVal[2] + g_clTaskWork[nUnit].m_dLaserVal[3]) / 2;
	dAvgLeft = (g_clTaskWork[nUnit].m_dLaserVal[0] + g_clTaskWork[nUnit].m_dLaserVal[3]) / 2;
	dAvgRight = (g_clTaskWork[nUnit].m_dLaserVal[1] + g_clTaskWork[nUnit].m_dLaserVal[2]) / 2;

#if  (____MODEL_NAME == TESLA_WIDE)
	// ======================= 세로 각도 계산 (TX)
	dWidth = dLength[0];                   // left
	dHeight = dAvgBottom - dAvgTop;	//+ - 부호 안맞으면 순서 바꾸기
	dRadian = atan(dHeight / dWidth);
	dTheta = dRadian * 180 / M_PI;
	dTx = dTheta*-1;
	// ======================= 가로 각도 계산 (TY)
	dWidth = dLength[1];                   // top
	dHeight = dAvgLeft - dAvgRight;    //+ - 부호 안맞으면 순서 바꾸기
	dRadian = atan(dHeight / dWidth);
	dTheta = dRadian * 180 / M_PI;
	dTy = dTheta*-1;

#elif (____MODEL_NAME == TESLA_MAIN_NARROW)
	// ======================= 세로 각도 계산 (TX)
	dWidth = dLength[0];                   // left
	dHeight = dAvgBottom- dAvgTop;	//+ - 부호 안맞으면 순서 바꾸기
	dRadian = atan(dHeight / dWidth); 
	dTheta = dRadian * 180 / M_PI;
	
	if (nUnit == 0)
	{
		dTx = dTheta*-1;
	}
	else
	{
		dTx = dTheta;
	}
	// ======================= 가로 각도 계산 (TY)
	dWidth = dLength[1];                   // top 
	dHeight =  dAvgLeft- dAvgRight;    //+ - 부호 안맞으면 순서 바꾸기
	dRadian = atan(dHeight / dWidth);
	dTheta = dRadian * 180 / M_PI;
	if (nUnit == 0)
	{
		dTy =  dTheta*-1;
	}
	else
	{
		dTy = dTheta;
	}
	

#endif
	
	
	//g_clTaskWork[nUnit].m_dLaserTiltY[nIndex] = dTheta;
	

	
	
	//g_clTaskWork[nUnit].m_dLaserTiltX[nIndex] = dTheta;
	

	return true;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
int g_CheckTiltLimit(int nUnit, int nType, double dTx, double dTy)
{
	if (nType == 0)
	{
		if ((fabs(dTx) > g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_TX]) || (fabs(dTy) > g_clModelData[nUnit].m_dErrLimit[MOTOR_PCB_TY]))
			return 0;

		if ((fabs(dTx) > g_clModelData[nUnit].m_dOkLimit[MOTOR_PCB_TX]) || (fabs(dTy) > g_clModelData[nUnit].m_dOkLimit[MOTOR_PCB_TY]))
			return 1;
	}
	else
	{
		/*if ((fabs(dTx) > g_clModelData[nUnit].m_dErrLimit[MOTOR_LENS_TX]) || (fabs(dTy) > g_clModelData[nUnit].m_dErrLimit[MOTOR_LENS_TY]))
			return 0;

		if ((fabs(dTx) > g_clModelData[nUnit].m_dOkLimit[MOTOR_LENS_TX]) || (fabs(dTy) > g_clModelData[nUnit].m_dOkLimit[MOTOR_LENS_TY]))
			return 1;*/
	}

	return 2;
}


//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void g_CalcAlignData(int nCh, CDPoint clDPtFindMark, double dAngle, double& dX, double& dY, double& dT)
{
	double dShiftX;
	double dShiftY;

	dShiftX = clDPtFindMark.x - (CCD1_CAM_SIZE_X / 2);
	dShiftY = clDPtFindMark.y - (CCD1_CAM_SIZE_Y / 2);

	dShiftX *= g_clModelData[nCh].m_dCcdCellSize / 1000;
	dShiftY *= g_clModelData[nCh].m_dCcdCellSize / 1000;
	
	dX = dShiftX;
	dY = dShiftY;

	if (dAngle > 180) dT = dAngle - 360;
	else
		dT = dAngle;		
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
double g_CalcTiltX(int nUnit)
{
	double dTopZPosA = (g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[1] + g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[2]) / 2;
	double dBottomZPosA = (g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[3] + g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[4]) / 2;

	double dHeightA = dBottomZPosA - dTopZPosA;
	double dTopPixelPosA = (g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[1]][1].y + g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[2]][2].y) / 2;
	double dBottomPixelPosA = (g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[3]][3].y + g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[4]][4].y) / 2;

	double dWidth_A = (dBottomPixelPosA - dTopPixelPosA) * g_clModelData[nUnit].m_dCcdCellSize / 1000;	/* CCD Cell 분해능*/

	double dTiltRadA = atan(dHeightA / dWidth_A);
	double dTiltDegA = dTiltRadA * 180.0 / M_PI;

	return dTiltDegA;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
double g_CalcTiltY(int nUnit)
{
	double dLeftZPosA = (g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[1] + g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[3]) / 2;
	double dRightZPosA = (g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[2] + g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[4]) / 2;

	double dHeightA = dRightZPosA - dLeftZPosA;

	double dLeftPixelPosA = (g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[1]][1].x + g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[3]][3].x) / 2;
	double dRightPixelPosA = (g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[2]][2].x + g_clTaskWork[nUnit].m_stSfrInsp.Sfr_Pos[g_clTaskWork[nUnit].m_stSfrInsp.nMaxIndex[4]][4].x) / 2;

	double dWidthA = (dRightPixelPosA - dLeftPixelPosA) * g_clModelData[nUnit].m_dCcdCellSize / 1000;		/* CCD Cell 분해능*/

	double dTiltRadA = atan(dHeightA / dWidthA);
	double dTiltDegA = dTiltRadA * 180.0 / M_PI;

	return dTiltDegA;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
bool g_GetCheckResult(int nUnit)
{
	int boxIndex[5] = { SFR_CENTER_INDEX, SFR_LEFT_UP_INDEX, SFR_RIGHT_UP_INDEX, SFR_LEFT_DOWN_INDEX, SFR_RIGHT_DOWN_INDEX };
	TCHAR szText[SIZE_OF_100BYTE];
	bool bRetVal = true;
	int i;

	double sfr_limit = 0;
		
	g_clVision.ClearOverlay(nUnit);

	// center
	if (g_clModelData[nUnit].m_dLimitSFRCent > g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[SFR_CENTER_INDEX])
	{
		_stprintf_s(szText, SIZE_OF_100BYTE, _T("%.02f / %.02f"), g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[SFR_CENTER_INDEX], g_clModelData[nUnit].m_dLimitSFRCent);		
		g_clVision.DrawMOverlayText(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX].top - 250, szText, M_COLOR_RED, _T("Arial"), 13, 7, FALSE);		
		g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX], M_COLOR_RED, 2, FALSE, PS_SOLID);
		
		bRetVal = false;
	}

	
	for (i = 1; i < 5; i++)
	{
		if (g_clModelData[nUnit].m_dLimitSFRSide > g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[boxIndex[i]])
		{
			_stprintf_s(szText, SIZE_OF_100BYTE, _T("%.02f / %.02f"), g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[boxIndex[i]], g_clModelData[nUnit].m_dLimitSFRSide);			
			g_clVision.DrawMOverlayText(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX + i - 1].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX + i - 1].top - 250, szText, M_COLOR_RED, _T("Arial"), 13, 7, FALSE);
			g_clVision.DrawMOverlayBox(nUnit, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX + i - 1], M_COLOR_RED, 2, FALSE, PS_SOLID);
			
			bRetVal = false;

		}
	}

	g_clVision.DrawOverlayAll(nUnit);

	return bRetVal;
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void g_Shift12to16BitMode(unsigned char* p12bitRaw, unsigned char* p16bitRaw, int nWidth, int nHeight)
{
	int k = 0;
	int n12bitRawSize = nWidth * nHeight * 1.5;
	register int i;

	for(i = 0; i < n12bitRawSize ; i += 3)
	{
		p16bitRaw[k + 1] = (p12bitRaw[i] & 0xF0) >> 4 ;
		p16bitRaw[k + 0] = ((p12bitRaw[i] & 0x0F) << 4 ) + ((p12bitRaw[i + 2] & 0x0F ));
		
		p16bitRaw[k + 3] = (p12bitRaw[i + 1] & 0xF0) >> 4 ;
		p16bitRaw[k + 2] = ((p12bitRaw[i + 1] & 0x0F) << 4 ) +  ((p12bitRaw[i + 2] & 0xF0 ) >> 4);

		k += 4;
	}
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void g_CCCR_Interpolation(unsigned short* pData, int nWidth, int nHeight)
{
	int nNewValue = 0;
	int nStartX = 1;
	int nStartY = 1;
	register int x, y;

	/*if(m_bRcccMoveX == true)
		nStartX = 2;

	if(m_bRcccMoveY == true)
		nStartY = 2;*/

	for (y = nStartY; y < nHeight - 1; y += 2)
	{
		for (x = nStartX; x < nWidth - 1; x += 2)
		{
			/*if(m_bCheckDir == true)
			{
				int absV = abs(pData[(i - 1) * nWidth + (j + 0)] - pData[(i + 1) * nWidth + (j + 0)]);
				int absH = abs(pData[(i + 0) * nWidth + (j - 1)] - pData[(i + 0) * nWidth + (j + 1)]);
				pData[i * nWidth + j] = (absV < absH) ? (pData[(i - 1) * nWidth + (j + 0)] + pData[(i + 1) * nWidth + (j + 0)]) / 2 : (pData[(i + 0) * nWidth + (j - 1)] + pData[(i + 0) * nWidth + (j + 1)]) / 2;
			}
			else
			{*/
				nNewValue =  pData[(y - 1) * nWidth + (x + 0)] + pData[(y + 1) * nWidth + (x + 0)] + pData[(y + 0) * nWidth + (x - 1)]  + pData[(y + 0) * nWidth + (x + 1)] ;
				
				nNewValue = nNewValue / 4;
				pData[y * nWidth + x] = (unsigned short) nNewValue;
			//}			
		}
	}
}

//-----------------------------------------------------------------------------
//
//
//
//-----------------------------------------------------------------------------
void g_Shift16to12BitMode(unsigned char* pImage, unsigned char* pDest, unsigned int nWidth, unsigned int nHeight)
{	
	unsigned int nScrWidth, nDestWidth;
	unsigned char *pcDest;
	register unsigned int i, j, k;

	nDestWidth = nWidth * 3 / 2;
	nScrWidth = nWidth * 2;

	pcDest = (unsigned char *) pDest;

	for(i = 0; i < nHeight; i++)
	{
		for(j = 0, k = 0; j < nDestWidth; j += 6, k += 8)
		{
			pcDest[j + 0] = ((pImage[k] & 0xF0) >> 4 ) +  ((pImage[k + 1]  & 0x0F ) << 4) ;
			pcDest[j + 1] = ((pImage[k + 2] & 0xF0) >> 4 ) +  ((pImage[k + 3]  & 0x0F ) << 4) ;
			pcDest[j + 2] = (pImage[k] & 0x0F) + ((pImage[k + 2]  & 0x0F ) << 4) ;

			pcDest[j + 3] = ((pImage[k + 4] & 0xF0) >> 4 ) +  ((pImage[k + 5]  & 0x0F ) << 4) ;
			pcDest[j + 4] = ((pImage[k + 6] & 0xF0) >> 4 ) +  ((pImage[k + 7]  & 0x0F ) << 4) ;
			pcDest[j + 5] = (pImage[k + 4] & 0x0F) + ((pImage[k + 6]  & 0x0F ) << 4) ;
		}

		pcDest += nDestWidth;
		pImage += nScrWidth;
	}	
}
//void CMandoInspLog::func_LogSave_Stain(CString name , CString title , CString data)//---Stain 검사시 로그  로그대대
//-----------------------------------------------------------------------------
//
//	SFR 로그 저장
//
//-----------------------------------------------------------------------------
bool g_SaveLGITLog(int nUnit, CString name, CString title, CString data)
{
    TCHAR szPath[SIZE_OF_1K];
    TCHAR szFilePath[SIZE_OF_1K];
    SYSTEMTIME stSysTime;
    CFileFind clFinder;
    CString sFileMode = _T("");
    CFile clFile;
    FILE* fp;
    int nStepNo;

    ::GetLocalTime(&stSysTime);

    if (_tcslen(g_clTaskWork[nUnit].m_szLotID) <= 0)
        _tcscpy_s(g_clTaskWork[nUnit].m_szLotID, SIZE_OF_100BYTE, _T("(NULL)"));

    if (_tcslen(g_clTaskWork[nUnit].m_szChipID) <= 0)
        _tcscpy_s(g_clTaskWork[nUnit].m_szChipID, SIZE_OF_100BYTE, _T("(NULL)"));

    if (clFinder.FindFile(BASE_LOG_PATH) == FALSE)
        CreateDirectory(BASE_LOG_PATH, NULL);
    //
    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result"), BASE_LOG_PATH);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\ACMIS"), BASE_LOG_PATH);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\ACMIS\\%04d%02d"), BASE_LOG_PATH, stSysTime.wYear, stSysTime.wMonth);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\ACMIS\\%04d%02d\\%02d"), BASE_LOG_PATH, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    nStepNo = g_clTaskWork[nUnit].m_nCountOfTotalStepAA;

    _stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%s_AA%d_%s.csv"), szPath, g_clTaskWork[nUnit].m_szChipID, nUnit + 1, name);
    if (clFinder.FindFile(szFilePath) == TRUE)
    {
        if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
        {
            AddLog(_T("파일이 사용 중 입니다."), 1, nUnit);
            return false;
        }
        else
        {
            clFile.Close();
        }
    }
#ifdef _UNICODE
    sFileMode = _T("w,ccs=UTF-8");
#else
    sFileMode = _T("w");//_T("w");
#endif

    // 파일이 없으면 헤더를 만든다.
    if (clFinder.FindFile(szFilePath) == FALSE)
    {
        _tfopen_s(&fp, szFilePath, sFileMode);
        if (fp != NULL)
        {
            _ftprintf_s(fp, _T("항목,%s,"), (LPTSTR)(LPCTSTR)title);
            _ftprintf_s(fp, "\n");
        }
        fclose(fp);
    }

#ifdef _UNICODE
    sFileMode = _T("a,ccs=UTF-8");
#else
    sFileMode = _T("a");
#endif

    _tfopen_s(&fp, szFilePath, sFileMode);
    if (fp != NULL)
    {
        _ftprintf_s(fp, _T("%s,%s"), (LPTSTR)(LPCTSTR)name,(LPTSTR)(LPCTSTR)data);
        _ftprintf_s(fp, "\n");
        fclose(fp);
    }
    return true;
}
//-----------------------------------------------------------------------------
//
//	SFR 로그 저장
//
//-----------------------------------------------------------------------------
bool g_SaveSfrLog(int nUnit, int nMode)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szFilePath[SIZE_OF_1K];
	SYSTEMTIME stSysTime;
	CFileFind clFinder;
	CString sFileMode = _T("");
	CFile clFile;
	FILE* fp;
	int nStepNo;

	::GetLocalTime(&stSysTime);

	if (_tcslen(g_clTaskWork[nUnit].m_szLotID) <= 0)
		_tcscpy_s(g_clTaskWork[nUnit].m_szLotID, SIZE_OF_100BYTE, _T("(NULL)"));

	if (_tcslen(g_clTaskWork[nUnit].m_szChipID) <= 0)
		_tcscpy_s(g_clTaskWork[nUnit].m_szChipID, SIZE_OF_100BYTE, _T("(NULL)"));

	if (clFinder.FindFile(BASE_LOG_PATH) == FALSE)
		CreateDirectory(BASE_LOG_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result"), BASE_LOG_PATH);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\%04d%02d"), BASE_LOG_PATH, stSysTime.wYear, stSysTime.wMonth);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\%04d%02d\\%02d"), BASE_LOG_PATH, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	nStepNo = g_clTaskWork[nUnit].m_nCountOfTotalStepAA;

	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%s_AA%d_Profile_%d.csv"), szPath, g_clTaskWork[nUnit].m_szChipID, nUnit + 1/*g_clSysData.m_nSysNo*/, g_clSysData.m_nUnitNo);
	if (clFinder.FindFile(szFilePath) == TRUE)
	{
		if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
		{
			AddLog(_T("파일이 사용 중 입니다."), 1, nUnit);
			return false;
		}
		else
		{
			clFile.Close();
		}
	}

#ifdef _UNICODE
	sFileMode = _T("w,ccs=UTF-8");
#else
	sFileMode = _T("w");
#endif

	// 파일이 없으면 헤더를 만든다.
	if (clFinder.FindFile(szFilePath) == FALSE)
	{
		_tfopen_s(&fp, szFilePath, sFileMode);
		if (fp != NULL)
		{
			_ftprintf_s(fp, _T("Time,"));
			_ftprintf_s(fp, _T("Machine ID,			Unit No,			Model,				SW Version,"));
			_ftprintf_s(fp, _T("LOT No,				Chip ID,"));
			_ftprintf_s(fp, _T("Step,"));
			_ftprintf_s(fp, _T("MotorTx,			MotorTy,			MotorX,				MotorY,			MotorZ,"));

			_ftprintf_s(fp, _T("OC_X,				OC_Y,				OC_Threshold,		OC_Left,		OC_Right,		OC_Top,		OC_Bottom,"));

			//_ftprintf_s(out, _T("CentSFR 0.75,			LfUpSFR 0.75,			RgtUpSFR 0.75,			LfDnSFR 0.75,		RgtDnSFR 0.75,"));
			// 20141103 LHC - 0.75 -> 0.7 변경
			_ftprintf_s(fp, _T("CentSFR 0.7,			LfUpSFR 0.7,			RgtUpSFR 0.7,			LfDnSFR 0.7,		RgtDnSFR 0.7,"));
			//_ftprintf_s(fp, _T("CentSFR 0.8,			LfUpSFR 0.8,			RgtUpSFR 0.8,			LfDnSFR 0.8,		RgtDnSFR 0.8,"));
			//_ftprintf_s(fp, _T("DFOV,				TiltX,				TiltY,				Rotation,"));
			_ftprintf_s(fp, _T("CenterROI_Left,		CenterROI_Right,	CenterROI_Top,		CenterROI_Btm,"));
			_ftprintf_s(fp, _T("LeftTopROI_Left,	LeftTopROI_Right,	LeftTopROI_Top,		LeftTopROI_Btm,"));
			_ftprintf_s(fp, _T("RightToptROI_Left,	RightTopROI_Right,	RightTopROI_Top,	RightTopROI_Btm,"));
			_ftprintf_s(fp, _T("LeftBtmROI_Left,	LeftBtmROI_Right,	LeftBtmROI_Top,		LeftBtmROI_Btm,"));
			_ftprintf_s(fp, _T("RightBtmtROI_Left,	RightBtmROI_Right,	RightBtmROI_Top,	RightBtmROI_Btm,"));

			_ftprintf_s(fp, _T("\n"));

			fclose(fp);
		}
	}

#ifdef _UNICODE
	sFileMode = _T("a,ccs=UTF-8");
#else
	sFileMode = _T("a");
#endif

	_tfopen_s(&fp, szFilePath, sFileMode);
	if (fp != NULL)
	{
		_ftprintf_s(fp, _T("'%04d-%02d-%02d %02d:%02d:%02d,"), stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);
		_ftprintf_s(fp, _T("AA %d 호기, Unit #%d, %s, %s,"), g_clSysData.m_nSysNo, g_clSysData.m_nUnitNo, g_clSysData.m_szModelName, VER_STR);
		_ftprintf_s(fp, _T("%s, %s,"), g_clTaskWork[nUnit].m_szLotID, g_clTaskWork[nUnit].m_szChipID);

		if (nMode == SFR_TILT)
		{
			// 정재호..		0.8 필드 저장 제거..
			_ftprintf_s(fp, _T(",,,,,,TiltX,%lf,TiltY,%lf,,,0.7F Focus_Pos,%.03lf,%.03lf,%.03lf,%.03lf,%.03lf,\n"),
				g_clTaskWork[nUnit].m_stSfrInsp.dTiltX, g_clTaskWork[nUnit].m_stSfrInsp.dTiltY, g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[0], g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[1],
				g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[2], g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[3], g_clTaskWork[nUnit].m_stSfrInsp.dMaxPos[4]);
		}
		else if (nMode == SFR_SHIFT)
		{
			_ftprintf_s(fp, _T(",,,,,,Align,%lf,%lf,%lf\n"),
				g_clTaskWork[nUnit].m_dImgShiftX, g_clTaskWork[nUnit].m_dImgShiftY, g_clTaskWork[nUnit].m_dImgShiftTh);
		}
		else if (nMode == OC_INSP)	// Optical Center Data 저장
		{
			_ftprintf_s(fp, _T(", , , ,,,%0.3lf, %0.3lf, %d, %d, %d, %d, %d\n"), (g_clModelData[nUnit].m_nWidth / 2) - g_clTaskWork[nUnit].m_dOpticalPosX, ((g_clModelData[nUnit].m_nHeight - 4) / 2) - g_clTaskWork[nUnit].m_dOpticalPosY,
				g_clTaskWork[nUnit].m_nOpticalTh, g_clTaskWork[nUnit].m_clOpticalRoi.left, g_clTaskWork[nUnit].m_clOpticalRoi.right, g_clTaskWork[nUnit].m_clOpticalRoi.top, g_clTaskWork[nUnit].m_clOpticalRoi.bottom);
		}
		else if (nMode == SFR_OFFSET_DATA)	// UV 경화 전 Lens X, Y, Tx, Ty, Th Offset 값 저장.
		{
			_ftprintf_s(fp, _T("OFFSET_DATA, , , , , , X, Y, Z, Tx, Ty, Theta\n"));
			_ftprintf_s(fp, _T(", , , , , , , , , , , , , %0.3lf, %0.3lf, %0.3lf, %0.3lf, %0.3lf, %0.3lf\n"), g_clModelData[nUnit].m_dOffsetPrevUV_X, g_clModelData[nUnit].m_dOffsetPrevUV_Y,
				g_clModelData[nUnit].m_dOffsetPrevUV_Z, g_clModelData[nUnit].m_dOffsetPrevUV_Tx, g_clModelData[nUnit].m_dOffsetPrevUV_Ty, g_clModelData[nUnit].m_dOffsetPrevUV_Th);
		}
		else
		{
			if (nMode == SFR_FIRST || nMode == SFR_SECOND)
				_ftprintf_s(fp, _T("%d,"), nStepNo);
			else if (nMode == SFR_BEFORE_UV)
				_ftprintf_s(fp, _T("BEFORE_UV,"));
			else if (nMode == SFR_AFTER_UV)
				_ftprintf_s(fp, _T("Grip Open,"));
			else if (nMode == SFR_FINAL)
				_ftprintf_s(fp, _T("AFTER_UV,")); // 20141103 LHC - Final -> UV After 변경
			else if (nMode == SFR_AFTER_OFFSET_MOVE)
				_ftprintf_s(fp, _T("AFTER_UV_OFFSET_MOVE, ")); // 20141103 LHC - After offset -> AA After 변경

			//_ftprintf_s(fp, _T("%f, %f, %f, %f, %f, , , , , , , ,"), g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStepNo][MOTOR_LENS_TX - MOTOR_LENS_X], g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStepNo][MOTOR_LENS_TY - MOTOR_LENS_X],
				//g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStepNo][MOTOR_LENS_X - MOTOR_LENS_X], g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStepNo][MOTOR_LENS_Y - MOTOR_LENS_X], g_clTaskWork[nUnit].m_stSfrInsp.fMotorPos[nStepNo][MOTOR_LENS_Z - MOTOR_LENS_X]);

			_ftprintf_s(fp, _T("%f, %f, %f, %f, %f,"), g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][0], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][1], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][2],
				g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][3], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][4]);

			//fprintf_s(fp, _T("%f, %f, %f, %f, %f,")		// 정재호 주석 처리.
			//	, g_clTaskWork.m_stSfrInsp.fSfrN4_B[nStepNo][0], g_clTaskWork.m_stSfrInsp.fSfrN4_B[nStepNo][1], g_clTaskWork.m_stSfrInsp.fSfrN4_B[nStepNo][2], g_clTaskWork.m_stSfrInsp.fSfrN4_B[nStepNo][3], g_clTaskWork.m_stSfrInsp.fSfrN4_B[nStepNo][4]);

			//_ftprintf_s(fp, _T("%f, %f, %f, %f,"), g_clTaskWork.m_stSfrInsp.fImageAlign[nStepNo][0], g_clTaskWork.m_stSfrInsp.fImageAlign[nStepNo][1], g_clTaskWork.m_stSfrInsp.fImageAlign[nStepNo][2],
			//		g_clTaskWork.m_stSfrInsp.fImageAlign[nStepNo][3]);

			_ftprintf_s(fp, _T("%d, %d, %d, %d,"), g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX].right,
				g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX].top, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_CENTER_INDEX].bottom);

			_ftprintf_s(fp, _T("%d, %d, %d, %d,"), g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX].right,
				g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX].top, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_UP_INDEX].bottom);

			_ftprintf_s(fp, _T("%d, %d, %d, %d,"), g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_UP_INDEX].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_UP_INDEX].right,
				g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_UP_INDEX].top, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_UP_INDEX].bottom);

			_ftprintf_s(fp, _T("%d, %d, %d, %d,"), g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_DOWN_INDEX].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_DOWN_INDEX].right,
				g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_DOWN_INDEX].top, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_LEFT_DOWN_INDEX].bottom);

			_ftprintf_s(fp, _T("%d, %d, %d, %d,"), g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_DOWN_INDEX].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_DOWN_INDEX].right,
				g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_DOWN_INDEX].top, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[SFR_RIGHT_DOWN_INDEX].bottom);

			_ftprintf_s(fp, _T("\n"));
			if (nMode == SFR_FINAL)
			{
				_ftprintf_s(fp, _T("\n"));
			}
		}

		fclose(fp);
	}
	return true;
}

//-----------------------------------------------------------------------------
//
//	SFR Summary 로그 저장
//
//-----------------------------------------------------------------------------
bool g_SaveSfrSumLog(int nUnit)
{
	TCHAR szPath[SIZE_OF_1K];
	TCHAR szFilePath[SIZE_OF_1K];
	SYSTEMTIME stSysTime;
	CFileFind clFinder;
	CString sFileMode = _T("");
	CFile clFile;
	FILE* fp;
	int nStepNo;

	::GetLocalTime(&stSysTime);

	if (_tcslen(g_clTaskWork[nUnit].m_szLotID) <= 0)
		_tcscpy_s(g_clTaskWork[nUnit].m_szLotID, SIZE_OF_100BYTE, _T("(NULL)"));

	if (_tcslen(g_clTaskWork[nUnit].m_szChipID) <= 0)
		_tcscpy_s(g_clTaskWork[nUnit].m_szChipID, SIZE_OF_100BYTE, _T("(NULL)"));

	if (clFinder.FindFile(BASE_LOG_PATH) == FALSE)
		CreateDirectory(BASE_LOG_PATH, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result"), BASE_LOG_PATH);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\AA%d"), BASE_LOG_PATH, nUnit + 1);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\AA%d\\%04d%02d"), BASE_LOG_PATH, nUnit + 1, stSysTime.wYear, stSysTime.wMonth);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	_stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\AA%d\\%04d%02d\\%02d"), BASE_LOG_PATH, nUnit + 1, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
	if (clFinder.FindFile(szPath) == FALSE)
		CreateDirectory(szPath, NULL);

	nStepNo = g_clTaskWork[nUnit].m_nCountOfTotalStepAA;

	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%s_AA%d_Final_%d.csv"), szPath, g_clTaskWork[nUnit].m_szLotID, g_clSysData.m_nSysNo, g_clSysData.m_nUnitNo);
	if (clFinder.FindFile(szFilePath) == TRUE)
	{
		if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
		{
			AddLog(_T("파일이 사용 중 입니다."), 1, nUnit);
			return false;
		}
		else
		{
			clFile.Close();
		}
	}


#ifdef _UNICODE
	sFileMode = _T("w,ccs=UTF-8");
#else
	sFileMode = _T("w");
#endif

	// 파일이 없으면 헤더를 만든다.
	if (clFinder.FindFile(szFilePath) == FALSE)
	{
		_tfopen_s(&fp, szFilePath, sFileMode);
		if (fp != NULL)
		{
			_ftprintf_s(fp, _T("Time,"));
			_ftprintf_s(fp, _T("Machine ID,			Unit No,			Model,				SW Version,"));
			_ftprintf_s(fp, _T("LOT No,				Chip ID,"));
			_ftprintf_s(fp, _T("Final_Step,"));

			_ftprintf_s(fp, _T("Teaching_Tx,		Teaching_Ty,		Teaching_X,			Teaching_Y,			Teaching_Z,"));
			_ftprintf_s(fp, _T("Tilt_X1,			Tilt_X2,			MotorTx,"));
			_ftprintf_s(fp, _T("Tilt_Y1,			Tilt_Y2,			MotorTy,"));

			_ftprintf_s(fp, _T("OC_X,				OC_Y,Rotation,"));

			_ftprintf_s(fp, _T("CentSFR 0.7,		LfUpSFR 0.7,		RgtUpSFR 0.7,		LfDnSFR 0.7,	RgtDnSFR 0.7,"));
			_ftprintf_s(fp, _T("CentSFR 0.8,		LfUpSFR 0.8,		RgtUpSFR 0.8,		LfDnSFR 0.8,	RgtDnSFR 0.8,"));
			for (int i = 0; i < 64; i++)
				_ftprintf_s(fp, _T("N/4 - %d,"), i + 1);

			for (int i = 0; i < 64; i++)
				_ftprintf_s(fp, _T("N/8 - %d,"), i + 1);

			for(int i=0; i < 24; i++)
				_ftprintf_s(fp, _T("%d-Left, %d-Right, %d-Top, %d-Bottom, "), i+1, i+1, i+1, i+1);

			_ftprintf_s(fp, _T("\n"));

			fclose(fp);
		}
	}


#ifdef _UNICODE
	sFileMode = _T("a,ccs=UTF-8");
#else
	sFileMode = _T("a");
#endif

	_tfopen_s(&fp, szFilePath, sFileMode);
	if (fp != NULL)
	{
		_ftprintf_s(fp, _T("'%04d-%02d-%02d %02d:%02d:%02d,"), stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);
		_ftprintf_s(fp, _T("AA %d 호기, Unit #%d, %s, %s,"), g_clSysData.m_nSysNo, g_clSysData.m_nUnitNo, g_clSysData.m_szModelName, VER_STR);
		_ftprintf_s(fp, _T("%s, %s,"), g_clTaskWork[nUnit].m_szLotID, g_clTaskWork[nUnit].m_szChipID);
		_ftprintf_s(fp, _T("%d,"), nStepNo);

		//_ftprintf_s(fp, _T("%0.3lf, %0.3lf, %0.3lf, %0.3lf, %0.3lf,"), g_clModelData[nUnit].m_stTeachData[CHART_POS].dPos[MOTOR_LENS_TX], g_clModelData[nUnit].m_stTeachData[BONDING_POS].dPos[MOTOR_LENS_TY],
			//g_clModelData[nUnit].m_stTeachData[CHART_POS].dPos[MOTOR_LENS_X], g_clModelData[nUnit].m_stTeachData[BONDING_POS].dPos[MOTOR_LENS_Y], g_clModelData[nUnit].m_stTeachData[BONDING_POS].dPos[MOTOR_LENS_Z]);
		_ftprintf_s(fp, _T("%0.3lf, %0.3lf, %0.3lf,"), g_clTaskWork[nUnit].m_stSfrInsp.dLogTiltX[0], g_clTaskWork[nUnit].m_stSfrInsp.dLogTiltX[1], g_clTaskWork[nUnit].m_stSfrInsp.dLogMotorTX);
		_ftprintf_s(fp, _T("%0.3lf, %0.3lf, %0.3lf,"), g_clTaskWork[nUnit].m_stSfrInsp.dLogTiltY[0], g_clTaskWork[nUnit].m_stSfrInsp.dLogTiltY[1], g_clTaskWork[nUnit].m_stSfrInsp.dLogMotorTY);


		_ftprintf_s(fp, _T("%0.3lf, %0.3lf,%.03lf,"), g_clMandoInspLog[nUnit].m_dOCResult[0], g_clMandoInspLog[nUnit].m_dOCResult[1], g_clTaskWork[nUnit].m_dImgShiftTh);

		_ftprintf_s(fp, _T("%f, %f, %f, %f, %f,"), g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][0], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][1], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][2],
			g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][3], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN4[nStepNo][4]);

		_ftprintf_s(fp, _T("%f, %f, %f, %f, %f,")						// 정재호 주석 처리.
			, g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStepNo][0], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStepNo][1], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStepNo][2], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStepNo][3], g_clTaskWork[nUnit].m_stSfrInsp.fSfrN8[nStepNo][4]);

		for (int i = 0; i<64; i++)
		{
			_ftprintf_s(fp, _T("%f,"), g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN4[i]);
		}

		for (int i = 0; i<64; i++)
		{
			_ftprintf_s(fp, _T("%f,"), g_clTaskWork[nUnit].m_stSfrInsp._64_fSfrN8[i]);
		}

		for(int i=0; i<24; i++)
		{
			_ftprintf_s(fp, _T("%d, %d, %d, %d, "), g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].left, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].right, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].top, g_clTaskWork[nUnit].m_stSfrInsp._64_Sfr_Rect[i].bottom);
		}

		_ftprintf_s(fp, _T("\n"));

		fclose(fp);
	}

	return true;
}
bool g_FinalInspLog(int nUnit)
{
    TCHAR szPath[SIZE_OF_1K];
    TCHAR szFilePath[SIZE_OF_1K];
    SYSTEMTIME stSysTime;
    CFileFind clFinder;
    CString sFileMode = _T("");
    CFile clFile;
    FILE* fp;
    int nStepNo;
    int i = 0;
    int j = 0;
    int indexX = 0;
    int indexY = 0;
    ::GetLocalTime(&stSysTime);

    if (_tcslen(g_clTaskWork[nUnit].m_szLotID) <= 0)
        _tcscpy_s(g_clTaskWork[nUnit].m_szLotID, SIZE_OF_100BYTE, _T("(NULL)"));

    if (_tcslen(g_clTaskWork[nUnit].m_szChipID) <= 0)
        _tcscpy_s(g_clTaskWork[nUnit].m_szChipID, SIZE_OF_100BYTE, _T("(NULL)"));

    if (clFinder.FindFile(BASE_LOG_PATH) == FALSE)
        CreateDirectory(BASE_LOG_PATH, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result"), BASE_LOG_PATH);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\AA%d"), BASE_LOG_PATH, nUnit + 1);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\AA%d\\%04d%02d"), BASE_LOG_PATH, nUnit + 1, stSysTime.wYear, stSysTime.wMonth);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    _stprintf_s(szPath, SIZE_OF_1K, _T("%s\\Result\\AA%d\\%04d%02d\\%02d"), BASE_LOG_PATH, nUnit + 1, stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
    if (clFinder.FindFile(szPath) == FALSE)
        CreateDirectory(szPath, NULL);

    nStepNo = g_clTaskWork[nUnit].m_nCountOfTotalStepAA;
	//dsm_FinalLog_20191021
    //_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%s_AA%d_FinalLog_%d.csv"), szPath, g_clTaskWork[nUnit].m_szLotID, g_clSysData.m_nSysNo, g_clSysData.m_nUnitNo);
	TCHAR* modelName[] = {_T("wide"), _T("main"), _T("narrow")};
#if (____MODEL_NAME == TESLA_WIDE)
	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%s_FinalLog_%04d%02d%02d.csv"), szPath, modelName[nUnit], stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
#else
	_stprintf_s(szFilePath, SIZE_OF_1K, _T("%s\\%s_FinalLog_%04d%02d%02d.csv"), szPath, modelName[nUnit +1], stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay);
#endif
	
    if (clFinder.FindFile(szFilePath) == TRUE)
    {
        if (clFile.Open(szFilePath, CFile::modeRead) == FALSE)
        {
            AddLog(_T("파일이 사용 중 입니다."), 1, nUnit);
            return false;
        }
        else
        {
            clFile.Close();
        }
    }


#ifdef _UNICODE
    sFileMode = _T("w,ccs=UTF-8");
#else
    sFileMode = _T("w");
#endif

    // 파일이 없으면 헤더를 만든다.
    if (clFinder.FindFile(szFilePath) == FALSE)
    {
        _tfopen_s(&fp, szFilePath, sFileMode);
        if (fp != NULL)
        {
            _ftprintf_s(fp, _T("Time,"));
            _ftprintf_s(fp, _T("Machine ID,			Unit No,			Model,				SW Version,"));
            _ftprintf_s(fp, _T("LOT No,				Chip ID,"));
            _ftprintf_s(fp, _T("[Defect] Bright,			    [Defect] Dark,			    [Defect] Hot,"));
            _ftprintf_s(fp, _T("[Defect] Bright Cluster,		[Defect] Dark Cluster,		[Defect] Hot Cluster,"));
            _ftprintf_s(fp, _T("[Defect] Dark Hor. Line,	    [Defect] Dark Ver. Line,	[Defect] Bright Hor. Line,"));
			_ftprintf_s(fp, _T("[Defect] Bright Ver. Line,"));
			_ftprintf_s(fp, _T("[Defect] Column FPN R,		[Defect]  Column FPN Cr, "));
			_ftprintf_s(fp, _T("[Defect] Column FPN Cb,		[Defect]  Column FPN B, "));


#if  (____MODEL_NAME == TESLA_WIDE)
			_ftprintf_s(fp, _T("[SFR] 0.0F_T_Avg,	  [SFR] 0.4F_T_Avg,	    [SFR] 0.4F_B_Avg,    [SFR] 0.4F_L_Avg,    [SFR] 0.4F_R_Avg,"));
            _ftprintf_s(fp, _T("[SFR] 0.0F_T,	  [SFR] 0.0F_B,	    [SFR] 0.0F_L,    [SFR] 0.0F_R,"));
            _ftprintf_s(fp, _T("[SFR] 0.4F_TV , [SFR] 0.4F_TH,    [SFR] 0.4F_BV , [SFR] 0.4F_BH,  [SFR] 0.4F_LV , [SFR] 0.4F_LH,  [SFR] 0.4F_RV , [SFR] 0.4F_RH,"));
#elif (____MODEL_NAME == TESLA_MAIN_NARROW)
			_ftprintf_s(fp, _T("[SFR] 0.0F_T_Avg,		[SFR] 0.4F_TL_Avg,	    [SFR] 0.4F_TR_Avg,    [SFR] 0.4F_BL_Avg,    [SFR] 0.8F_BR_Avg,	  [SFR] 0.8F_TL_Avg,	    [SFR] 0.8F_TR_Avg,    [SFR] 0.8F_BL_Avg,    [SFR] 0.8F_BR_Avg,"));
            _ftprintf_s(fp, _T("[SFR] 0.0F_T,			[SFR] 0.0F_B,			[SFR] 0.0F_L,		  [SFR] 0.0F_R,"));
            _ftprintf_s(fp, _T("[SFR] 0.4F_TLV ,		[SFR] 0.4F_TLH,			[SFR] 0.4F_TRV ,	  [SFR] 0.4F_TRH,		[SFR] 0.4F_BLV , [SFR] 0.4F_BLH,  [SFR] 0.4F_BRV , [SFR] 0.4F_BRH,"));
            _ftprintf_s(fp, _T("[SFR] 0.8F_TLV ,		[SFR] 0.8F_TLH,			[SFR] 0.8F_TRV ,	  [SFR] 0.8F_TRH,		[SFR] 0.8F_BLV , [SFR] 0.8F_BLH,  [SFR] 0.8F_BRV , [SFR] 0.8F_BRH,"));
#endif
            _ftprintf_s(fp, _T("[OC] OC_X ,	[OC] OC_Y,"));
            _ftprintf_s(fp, _T("[OC] Delta_X ,[OC] Delat_Y,"));
            _ftprintf_s(fp, _T("[Distortion],"));
            _ftprintf_s(fp, _T("[Blemish] BlackSpot,[Blemish] LCB,[Blemish] RU_Ymean,"));
            _ftprintf_s(fp, _T("[CS] RC_6500K,[CS] BC_6500K,[CS] CrCb_6500K,"));
            _ftprintf_s(fp, _T("[CS] RC_5000k,[CS] BC_5000k,[CS] CrCb_5000k,"));
            _ftprintf_s(fp, _T("[RI] Center_R,[RI] Center_Cr,[RI] Center_Cb,[RI] Center_B,"));
			
            for (i = 0; i < 4; i++)
            {
                for (j = 0; j < 100; j++)
                {
                    indexX = j / 10;
                    indexY = j % 10;
                    switch (i)
                    {
                    case 0:
                        _ftprintf_s(fp, _T("[RI]RED_6500[%d_%d],") ,indexX, indexY);
                        break;

                    case 1:
                        _ftprintf_s(fp, _T("[RI]CLEARR_6500[%d_%d],"), indexX, indexY);
                        break;

                    case 2:
                        _ftprintf_s(fp, _T("[RI]CLEARB_6500[%d_%d],"), indexX, indexY);
                        break;

                    case 3:
                        _ftprintf_s(fp, _T("[RI]BLUE_6500[%d_%d],"), indexX, indexY);
                        break;
                    }
                   
                }
            }
			_ftprintf_s(fp, _T("[RI] Corner_Variation_R,[RI] Corner_Variation_Cr,[RI] Corner_Variation_Cb,[RI] Corner_Variation_B,"));
            _ftprintf_s(fp, _T("[SNR] SNR,[SNR] DR,	"));
            _ftprintf_s(fp, _T("[CU] LT_Delta_RG[3_3],[CU] LT_Delta_RB[3_3],[CU] LT_Delta_BG[3_3],"));
            _ftprintf_s(fp, _T("[CU] RT_Delta_RG[6_3],[CU] RT_Delta_RB[6_3],[CU] RT_Delta_BG[6_3],"));
            _ftprintf_s(fp, _T("[CU] LB_Delta_RG[3_6],[CU] LB_Delta_RB[3_6],[CU] LB_Delta_BG[3_6],"));
            _ftprintf_s(fp, _T("[CU] RB_Delta_RG[6_6],[CU] RB_Delta_RB[6_6],[CU] RB_Delta_BG[6_6],"));
            _ftprintf_s(fp, _T("[FOV] H_FOV,[FOV] V_FOV,[FOV] D_FOV,[Rotate] Rotate,"));

			_ftprintf_s(fp, _T("NG LIST,JUDGE,"));
            _ftprintf_s(fp, _T("\n"));
            fclose(fp);
        }
    }


#ifdef _UNICODE
    sFileMode = _T("a,ccs=UTF-8");
#else
    sFileMode = _T("a");
#endif

    _tfopen_s(&fp, szFilePath, sFileMode);
    if (fp != NULL)
    {
        _ftprintf_s(fp, _T("'%04d-%02d-%02d %02d:%02d:%02d,"), stSysTime.wYear, stSysTime.wMonth, stSysTime.wDay, stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);
        _ftprintf_s(fp, _T("AA %d 호기, Unit #%d, %s, %s,"), g_clSysData.m_nSysNo, g_clSysData.m_nUnitNo, g_clSysData.m_szModelName, VER_STR);
        _ftprintf_s(fp, _T("%s, %s,"), g_clTaskWork[nUnit].m_szLotID, g_clTaskWork[nUnit].m_szChipID);
        //
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_LogDefectBright, g_clMandoInspLog[nUnit].m_LogDefectDark, g_clMandoInspLog[nUnit].m_LogDefectHot);
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_LogDefectBrightCluster, g_clMandoInspLog[nUnit].m_LogDefectDarkCluster, g_clMandoInspLog[nUnit].m_LogDefectHotCluster);
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf, %.03lf,"), g_clMandoInspLog[nUnit].m_LogDefectDarkHorLine, g_clMandoInspLog[nUnit].m_LogDefectDarkVerLine, g_clMandoInspLog[nUnit].m_LogDefectBrightHorLine, g_clMandoInspLog[nUnit].m_LogDefectBrightVerLine);
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_LogDefectColumnFPN[1]);//R
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_LogDefectColumnFPN[0]);//Cr
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_LogDefectColumnFPN[3]);//Cb
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_LogDefectColumnFPN[2]);//b
#if  (____MODEL_NAME == TESLA_WIDE)
        //sfr 12개
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[0] + g_clMandoInspLog[nUnit].m_LogSfr[1] + g_clMandoInspLog[nUnit].m_LogSfr[2] + g_clMandoInspLog[nUnit].m_LogSfr[3]) / 4);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[4] + g_clMandoInspLog[nUnit].m_LogSfr[5]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[6] + g_clMandoInspLog[nUnit].m_LogSfr[7]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[8] + g_clMandoInspLog[nUnit].m_LogSfr[9]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[10] + g_clMandoInspLog[nUnit].m_LogSfr[11]) / 2);
        for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
        {
            _ftprintf_s(fp, _T("%lf,"), g_clMandoInspLog[nUnit].m_LogSfr[i]);
        }
#elif (____MODEL_NAME == TESLA_MAIN_NARROW)
        //sfr 20개
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[0] + g_clMandoInspLog[nUnit].m_LogSfr[1] + g_clMandoInspLog[nUnit].m_LogSfr[2] + g_clMandoInspLog[nUnit].m_LogSfr[3]) / 4);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[4] + g_clMandoInspLog[nUnit].m_LogSfr[5]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[6] + g_clMandoInspLog[nUnit].m_LogSfr[7]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[8] + g_clMandoInspLog[nUnit].m_LogSfr[9]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[10] + g_clMandoInspLog[nUnit].m_LogSfr[11]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[12] + g_clMandoInspLog[nUnit].m_LogSfr[13]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[14] + g_clMandoInspLog[nUnit].m_LogSfr[15]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[16] + g_clMandoInspLog[nUnit].m_LogSfr[17]) / 2);
		_ftprintf_s(fp, _T("%lf,"), (g_clMandoInspLog[nUnit].m_LogSfr[18] + g_clMandoInspLog[nUnit].m_LogSfr[19]) / 2);
        for (i = 0; i < MAX_SFR_INSP_COUNT; i++)
        {
            _ftprintf_s(fp, _T("%lf,"), g_clMandoInspLog[nUnit].m_LogSfr[i]);
        }
#endif

        _ftprintf_s(fp, _T("%0.3lf, %0.3lf,%0.3lf,%0.3lf,"), g_clMandoInspLog[nUnit].m_LogOC_X, g_clMandoInspLog[nUnit].m_LogOC_Y, g_clMandoInspLog[nUnit].m_LogOC_DelatX, g_clMandoInspLog[nUnit].m_LogOC_DelatY);
        _ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_LogDistortion);
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %0.3lf,"), g_clMandoInspLog[nUnit].m_LogBlemishBlackSpot, g_clMandoInspLog[nUnit].m_LogBlemishLcb, g_clMandoInspLog[nUnit].m_LogBlemishRU_Ymean);
        //Color Sensitivity
        _ftprintf_s(fp, _T("%0.6lf, %0.6lf, %0.6lf,"), g_clMandoInspLog[nUnit].m_Log_CS_RG_6500K, g_clMandoInspLog[nUnit].m_Log_CS_BG_6500K, g_clMandoInspLog[nUnit].m_Log_CS_GrGb_6500K);
        _ftprintf_s(fp, _T("%0.6lf, %0.6lf, %0.6lf,"), g_clMandoInspLog[nUnit].m_Log_CS_RC_5000k, g_clMandoInspLog[nUnit].m_Log_CS_BC_5000k, g_clMandoInspLog[nUnit].m_Log_CS_CrCb_5000k);
        //RI =R,CR,CB,B 순서
        _ftprintf_s(fp, _T("%0.3lf,%0.3lf,%.03lf,%.03lf,"), g_clMandoInspLog[nUnit].m_Log_RI_Center_R, g_clMandoInspLog[nUnit].m_Log_RI_Center_Cr, g_clMandoInspLog[nUnit].m_Log_RI_Center_Cb, g_clMandoInspLog[nUnit].m_Log_RI_Center_B);

        for (i = 0; i < 100; i++)
        {
            _ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_RED[i]);
        }
        for (i = 0; i < 100; i++)
        {
            _ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_CLEARR[i]);
        }
        for (i = 0; i < 100; i++)
        {
            _ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_CLEARB[i]);
        }
        for (i = 0; i < 100; i++)
        {
            _ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_BLUE[i]);
        }
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_CornerVar_R);
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_CornerVar_Cr);
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_CornerVar_Cb);
		_ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_RI_CornerVar_B);

        //_ftprintf_s(fp, _T("%0.3lf, %0.3lf,%.03lf,%.03lf,"), g_clMandoInspLog[nUnit].m_Log_RI_LT_Ratio_R, g_clMandoInspLog[nUnit].m_Log_RI_LT_Ratio_Cr, g_clMandoInspLog[nUnit].m_Log_RI_LT_Ratio_Cb, g_clMandoInspLog[nUnit].m_Log_RI_LT_Ratio_B);
        //_ftprintf_s(fp, _T("%0.3lf, %0.3lf,%.03lf,%.03lf,"), g_clMandoInspLog[nUnit].m_Log_RI_RT_Ratio_R, g_clMandoInspLog[nUnit].m_Log_RI_RT_Ratio_Cr, g_clMandoInspLog[nUnit].m_Log_RI_RT_Ratio_Cb, g_clMandoInspLog[nUnit].m_Log_RI_RT_Ratio_B);
        //_ftprintf_s(fp, _T("%0.3lf, %0.3lf,%.03lf,%.03lf,"), g_clMandoInspLog[nUnit].m_Log_RI_LB_Ratio_R, g_clMandoInspLog[nUnit].m_Log_RI_LB_Ratio_Cr, g_clMandoInspLog[nUnit].m_Log_RI_LB_Ratio_Cb, g_clMandoInspLog[nUnit].m_Log_RI_LB_Ratio_B);
        //_ftprintf_s(fp, _T("%0.3lf, %0.3lf,%.03lf,%.03lf,"), g_clMandoInspLog[nUnit].m_Log_RI_RB_Ratio_R, g_clMandoInspLog[nUnit].m_Log_RI_RB_Ratio_Cr, g_clMandoInspLog[nUnit].m_Log_RI_RB_Ratio_Cb, g_clMandoInspLog[nUnit].m_Log_RI_RB_Ratio_B);

        //snr
        _ftprintf_s(fp, _T("%0.3lf,%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_SNR_SNR, g_clMandoInspLog[nUnit].m_Log_SNR_DR);
        //Color Uniform
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_Log_CU_LT_Delta_RG, g_clMandoInspLog[nUnit].m_Log_CU_LT_Delta_RB, g_clMandoInspLog[nUnit].m_Log_CU_LT_Delta_BG);
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_Log_CU_RT_Delta_RG, g_clMandoInspLog[nUnit].m_Log_CU_RT_Delta_RB, g_clMandoInspLog[nUnit].m_Log_CU_RT_Delta_BG);
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_Log_CU_LB_Delta_RG, g_clMandoInspLog[nUnit].m_Log_CU_LB_Delta_RB, g_clMandoInspLog[nUnit].m_Log_CU_LB_Delta_BG);
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_Log_CU_RB_Delta_RG, g_clMandoInspLog[nUnit].m_Log_CU_RB_Delta_RB, g_clMandoInspLog[nUnit].m_Log_CU_RB_Delta_BG);
        //fov
        _ftprintf_s(fp, _T("%0.3lf, %0.3lf, %.03lf,"), g_clMandoInspLog[nUnit].m_Log_FOV_H_FOV, g_clMandoInspLog[nUnit].m_Log_FOV_V_FOV, g_clMandoInspLog[nUnit].m_Log_FOV_D_FOV);
        _ftprintf_s(fp, _T("%0.3lf,"), g_clMandoInspLog[nUnit].m_Log_Rotate);


		if (g_clMandoInspLog[nUnit].m_bInspRes == true)		fprintf_s(fp, "%s ,OK,", g_clMandoInspLog[nUnit].m_sNGList);
		else												fprintf_s(fp, "%s ,NG,", g_clMandoInspLog[nUnit].m_sNGList);


        //
        _ftprintf_s(fp, _T("\n"));

        fclose(fp);
    }

    return true;
}
